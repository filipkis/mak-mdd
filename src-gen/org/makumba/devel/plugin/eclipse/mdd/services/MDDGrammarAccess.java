/*
* generated by Xtext
*/

package org.makumba.devel.plugin.eclipse.mdd.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class MDDGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class DataDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dataDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLINEBREAKTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cDAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cDDeclarationParserRuleCall_1_0_0 = (RuleCall)cDAssignment_1_0.eContents().get(0);
		private final RuleCall cFIELDCOMMENTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final RuleCall cLINEBREAKTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//dataDefinition:
		//  LINEBREAK* (d+=declaration FIELDCOMMENT? LINEBREAK*)+;
		public ParserRule getRule() { return rule; }

		//LINEBREAK* (d+=declaration FIELDCOMMENT? LINEBREAK*)+
		public Group getGroup() { return cGroup; }

		//LINEBREAK*
		public RuleCall getLINEBREAKTerminalRuleCall_0() { return cLINEBREAKTerminalRuleCall_0; }

		//(d+=declaration FIELDCOMMENT? LINEBREAK*)+
		public Group getGroup_1() { return cGroup_1; }

		//d+=declaration
		public Assignment getDAssignment_1_0() { return cDAssignment_1_0; }

		//declaration
		public RuleCall getDDeclarationParserRuleCall_1_0_0() { return cDDeclarationParserRuleCall_1_0_0; }

		//FIELDCOMMENT?
		public RuleCall getFIELDCOMMENTTerminalRuleCall_1_1() { return cFIELDCOMMENTTerminalRuleCall_1_1; }

		//LINEBREAK*
		public RuleCall getLINEBREAKTerminalRuleCall_1_2() { return cLINEBREAKTerminalRuleCall_1_2; }
	}

	public class DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFieldDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTitleDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTypeDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIncludeDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cValidationRuleDeclarationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cFunctionDeclarationParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNativeValidationRuleDeclarationParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cSubFieldDeclarationParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//declaration:
		//  fieldDeclaration|titleDeclaration|typeDeclaration|includeDeclaration|
		//  validationRuleDeclaration|functionDeclaration|nativeValidationRuleDeclaration|
		//  subFieldDeclaration; 
		//
		//
		//    
		//    
		//    
		//     
		//    
		//    
		//    
		//  
		//   
		//
		/// *extendedDeclaration:
		//	declaration |
		//	 FIELDCOMMENT? LINEBREAK*;* /
		//
		//		
		///////// Field Declaration
		public ParserRule getRule() { return rule; }

		//fieldDeclaration|titleDeclaration|typeDeclaration|includeDeclaration|
		//validationRuleDeclaration|functionDeclaration|nativeValidationRuleDeclaration|
		//subFieldDeclaration 
		//
		//
		//    
		//    
		//    
		//     
		//    
		//    
		//    
		//  
		//   
		//
		/// *extendedDeclaration:
		//	declaration |
		//	 FIELDCOMMENT? LINEBREAK*;* /
		//
		//		
		///////// Field Declaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//fieldDeclaration
		public RuleCall getFieldDeclarationParserRuleCall_0() { return cFieldDeclarationParserRuleCall_0; }

		//titleDeclaration
		public RuleCall getTitleDeclarationParserRuleCall_1() { return cTitleDeclarationParserRuleCall_1; }

		//typeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_2() { return cTypeDeclarationParserRuleCall_2; }

		//includeDeclaration
		public RuleCall getIncludeDeclarationParserRuleCall_3() { return cIncludeDeclarationParserRuleCall_3; }

		//validationRuleDeclaration
		public RuleCall getValidationRuleDeclarationParserRuleCall_4() { return cValidationRuleDeclarationParserRuleCall_4; }

		//functionDeclaration
		public RuleCall getFunctionDeclarationParserRuleCall_5() { return cFunctionDeclarationParserRuleCall_5; }

		//nativeValidationRuleDeclaration
		public RuleCall getNativeValidationRuleDeclarationParserRuleCall_6() { return cNativeValidationRuleDeclarationParserRuleCall_6; }

		//subFieldDeclaration
		public RuleCall getSubFieldDeclarationParserRuleCall_7() { return cSubFieldDeclarationParserRuleCall_7; }
	}

	public class FieldDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fieldDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0_0 = (RuleCall)cNameAlternatives_0_0.eContents().get(0);
		private final RuleCall cNameKeywordParserRuleCall_0_0_1 = (RuleCall)cNameAlternatives_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cModifiersAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cModifiersModifiersParserRuleCall_2_0_0 = (RuleCall)cModifiersAssignment_2_0.eContents().get(0);
		private final Assignment cTypedefAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cTypedefFieldTypeParserRuleCall_2_1_0 = (RuleCall)cTypedefAssignment_2_1.eContents().get(0);
		
		//fieldDeclaration:
		//  name=( ID | keyword ) "=" (modifiers=modifiers typedef=fieldType)?; 
		//
		/// *extendedDeclaration:
		//	declaration |
		//	 FIELDCOMMENT? LINEBREAK*;* /
		//
		//		
		///////// Field Declaration
		public ParserRule getRule() { return rule; }

		//name=( ID | keyword ) "=" (modifiers=modifiers typedef=fieldType)?
		public Group getGroup() { return cGroup; }

		//name=( ID | keyword )
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID|keyword
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0_0() { return cNameIDTerminalRuleCall_0_0_0; }

		//keyword
		public RuleCall getNameKeywordParserRuleCall_0_0_1() { return cNameKeywordParserRuleCall_0_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//(modifiers=modifiers typedef=fieldType)?
		public Group getGroup_2() { return cGroup_2; }

		//modifiers=modifiers
		public Assignment getModifiersAssignment_2_0() { return cModifiersAssignment_2_0; }

		//modifiers
		public RuleCall getModifiersModifiersParserRuleCall_2_0_0() { return cModifiersModifiersParserRuleCall_2_0_0; }

		//typedef=fieldType
		public Assignment getTypedefAssignment_2_1() { return cTypedefAssignment_2_1; }

		//fieldType
		public RuleCall getTypedefFieldTypeParserRuleCall_2_1_0() { return cTypedefFieldTypeParserRuleCall_2_1_0; }
	}

	public class ModifiersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modifiers");
		private final UnorderedGroup cUnorderedGroup = (UnorderedGroup)rule.eContents().get(1);
		private final Assignment cUniqueAssignment_0 = (Assignment)cUnorderedGroup.eContents().get(0);
		private final Keyword cUniqueUniqueKeyword_0_0 = (Keyword)cUniqueAssignment_0.eContents().get(0);
		private final Assignment cFixedAssignment_1 = (Assignment)cUnorderedGroup.eContents().get(1);
		private final Keyword cFixedFixedKeyword_1_0 = (Keyword)cFixedAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cUnorderedGroup.eContents().get(2);
		private final Assignment cNotNullAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cNotNullNotKeyword_2_0_0 = (Keyword)cNotNullAssignment_2_0.eContents().get(0);
		private final Keyword cNullKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cUnorderedGroup.eContents().get(3);
		private final Assignment cNotEmptyAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final Keyword cNotEmptyNotKeyword_3_0_0 = (Keyword)cNotEmptyAssignment_3_0.eContents().get(0);
		private final Keyword cEmptyKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		
		//modifiers:
		//  unique?="unique"? & fixed?="fixed"? & (notNull?="not" "null")? & (notEmpty?="not"
		//  "empty")?;
		public ParserRule getRule() { return rule; }

		//unique?="unique"? & fixed?="fixed"? & (notNull?="not" "null")? & (notEmpty?="not"
		//"empty")?
		public UnorderedGroup getUnorderedGroup() { return cUnorderedGroup; }

		//unique?="unique"?
		public Assignment getUniqueAssignment_0() { return cUniqueAssignment_0; }

		//"unique"
		public Keyword getUniqueUniqueKeyword_0_0() { return cUniqueUniqueKeyword_0_0; }

		//fixed?="fixed"?
		public Assignment getFixedAssignment_1() { return cFixedAssignment_1; }

		//"fixed"
		public Keyword getFixedFixedKeyword_1_0() { return cFixedFixedKeyword_1_0; }

		//(notNull?="not" "null")?
		public Group getGroup_2() { return cGroup_2; }

		//notNull?="not"
		public Assignment getNotNullAssignment_2_0() { return cNotNullAssignment_2_0; }

		//"not"
		public Keyword getNotNullNotKeyword_2_0_0() { return cNotNullNotKeyword_2_0_0; }

		//"null"
		public Keyword getNullKeyword_2_1() { return cNullKeyword_2_1; }

		//(notEmpty?="not" "empty")?
		public Group getGroup_3() { return cGroup_3; }

		//notEmpty?="not"
		public Assignment getNotEmptyAssignment_3_0() { return cNotEmptyAssignment_3_0; }

		//"not"
		public Keyword getNotEmptyNotKeyword_3_0_0() { return cNotEmptyNotKeyword_3_0_0; }

		//"empty"
		public Keyword getEmptyKeyword_3_1() { return cEmptyKeyword_3_1; }
	}

	public class FieldTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fieldType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCharTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCharEnumParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cSetKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cCharEnumParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final RuleCall cIntEnumParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cSetKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cIntEnumParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cFieldTypeAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Assignment cTypeAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final Alternatives cTypeAlternatives_5_1_0 = (Alternatives)cTypeAssignment_5_1.eContents().get(0);
		private final Keyword cTypeIntKeyword_5_1_0_0 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(0);
		private final Keyword cTypeRealKeyword_5_1_0_1 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(1);
		private final Keyword cTypeBooleanKeyword_5_1_0_2 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(2);
		private final Keyword cTypeTextKeyword_5_1_0_3 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(3);
		private final Keyword cTypeBinaryKeyword_5_1_0_4 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(4);
		private final Keyword cTypeFileKeyword_5_1_0_5 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(5);
		private final Keyword cTypeDateKeyword_5_1_0_6 = (Keyword)cTypeAlternatives_5_1_0.eContents().get(6);
		private final RuleCall cPointerParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cSetTypeParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final Assignment cTypeDecAssignment_8 = (Assignment)cAlternatives.eContents().get(8);
		private final CrossReference cTypeDecTypeDeclarationCrossReference_8_0 = (CrossReference)cTypeDecAssignment_8.eContents().get(0);
		private final RuleCall cTypeDecTypeDeclarationIDTerminalRuleCall_8_0_1 = (RuleCall)cTypeDecTypeDeclarationCrossReference_8_0.eContents().get(1);
		
		//fieldType:
		//  charType|charEnum|"set" charEnum|intEnum|"set" intEnum|{fieldType} type=( "int" |
		//  "real" | "boolean" | "text" | "binary" | "file" | "date" )|pointer|setType|typeDec=[
		//  typeDeclaration];
		public ParserRule getRule() { return rule; }

		//charType|charEnum|"set" charEnum|intEnum|"set" intEnum|{fieldType} type=( "int" |
		//"real" | "boolean" | "text" | "binary" | "file" | "date" )|pointer|setType|typeDec=[
		//typeDeclaration]
		public Alternatives getAlternatives() { return cAlternatives; }

		//charType
		public RuleCall getCharTypeParserRuleCall_0() { return cCharTypeParserRuleCall_0; }

		//charEnum
		public RuleCall getCharEnumParserRuleCall_1() { return cCharEnumParserRuleCall_1; }

		//"set" charEnum
		public Group getGroup_2() { return cGroup_2; }

		//"set"
		public Keyword getSetKeyword_2_0() { return cSetKeyword_2_0; }

		//charEnum
		public RuleCall getCharEnumParserRuleCall_2_1() { return cCharEnumParserRuleCall_2_1; }

		//intEnum
		public RuleCall getIntEnumParserRuleCall_3() { return cIntEnumParserRuleCall_3; }

		//"set" intEnum
		public Group getGroup_4() { return cGroup_4; }

		//"set"
		public Keyword getSetKeyword_4_0() { return cSetKeyword_4_0; }

		//intEnum
		public RuleCall getIntEnumParserRuleCall_4_1() { return cIntEnumParserRuleCall_4_1; }

		//{fieldType} type=( "int" | "real" | "boolean" | "text" | "binary" | "file" | "date" )
		public Group getGroup_5() { return cGroup_5; }

		//{fieldType}
		public Action getFieldTypeAction_5_0() { return cFieldTypeAction_5_0; }

		//type=( "int" | "real" | "boolean" | "text" | "binary" | "file" | "date" )
		public Assignment getTypeAssignment_5_1() { return cTypeAssignment_5_1; }

		//"int"|"real"|"boolean"|"text"|"binary"|"file"|"date"
		public Alternatives getTypeAlternatives_5_1_0() { return cTypeAlternatives_5_1_0; }

		//"int"
		public Keyword getTypeIntKeyword_5_1_0_0() { return cTypeIntKeyword_5_1_0_0; }

		//"real"
		public Keyword getTypeRealKeyword_5_1_0_1() { return cTypeRealKeyword_5_1_0_1; }

		//"boolean"
		public Keyword getTypeBooleanKeyword_5_1_0_2() { return cTypeBooleanKeyword_5_1_0_2; }

		//"text"
		public Keyword getTypeTextKeyword_5_1_0_3() { return cTypeTextKeyword_5_1_0_3; }

		//"binary"
		public Keyword getTypeBinaryKeyword_5_1_0_4() { return cTypeBinaryKeyword_5_1_0_4; }

		//"file"
		public Keyword getTypeFileKeyword_5_1_0_5() { return cTypeFileKeyword_5_1_0_5; }

		//"date"
		public Keyword getTypeDateKeyword_5_1_0_6() { return cTypeDateKeyword_5_1_0_6; }

		//pointer
		public RuleCall getPointerParserRuleCall_6() { return cPointerParserRuleCall_6; }

		//setType
		public RuleCall getSetTypeParserRuleCall_7() { return cSetTypeParserRuleCall_7; }

		//typeDec=[typeDeclaration]
		public Assignment getTypeDecAssignment_8() { return cTypeDecAssignment_8; }

		//[typeDeclaration]
		public CrossReference getTypeDecTypeDeclarationCrossReference_8_0() { return cTypeDecTypeDeclarationCrossReference_8_0; }

		//ID
		public RuleCall getTypeDecTypeDeclarationIDTerminalRuleCall_8_0_1() { return cTypeDecTypeDeclarationIDTerminalRuleCall_8_0_1; }
	}

	public class IntEnumElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "intEnum");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameIntKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesEnumValueParserRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesEnumValueParserRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//intEnum:
		//  name="int" "{" values+=enumValue ("," values+=enumValue)* "}";
		public ParserRule getRule() { return rule; }

		//name="int" "{" values+=enumValue ("," values+=enumValue)* "}"
		public Group getGroup() { return cGroup; }

		//name="int"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"int"
		public Keyword getNameIntKeyword_0_0() { return cNameIntKeyword_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//values+=enumValue
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }

		//enumValue
		public RuleCall getValuesEnumValueParserRuleCall_2_0() { return cValuesEnumValueParserRuleCall_2_0; }

		//("," values+=enumValue)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//values+=enumValue
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }

		//enumValue
		public RuleCall getValuesEnumValueParserRuleCall_3_1_0() { return cValuesEnumValueParserRuleCall_3_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class CharEnumElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "charEnum");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameCharKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesSTRINGTerminalRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesSTRINGTerminalRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//charEnum:
		//  name="char" "{" values+=STRING ("," values+=STRING)* "}"; 
		//
		//
		//	           
		//		
		//
		//   
		/// * New syntax to be introduced in mak 0.9
		//enumType:
		//  'enum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}'); 
		//
		//setEnumType:
		//  'setEnum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}');* /
		public ParserRule getRule() { return rule; }

		//name="char" "{" values+=STRING ("," values+=STRING)* "}"
		public Group getGroup() { return cGroup; }

		//name="char"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"char"
		public Keyword getNameCharKeyword_0_0() { return cNameCharKeyword_0_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//values+=STRING
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_2_0() { return cValuesSTRINGTerminalRuleCall_2_0; }

		//("," values+=STRING)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//values+=STRING
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }

		//STRING
		public RuleCall getValuesSTRINGTerminalRuleCall_3_1_0() { return cValuesSTRINGTerminalRuleCall_3_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class EnumValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enumValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameSTRINGTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cValueAlternatives_2_0 = (Alternatives)cValueAssignment_2.eContents().get(0);
		private final RuleCall cValueINTTerminalRuleCall_2_0_0 = (RuleCall)cValueAlternatives_2_0.eContents().get(0);
		private final RuleCall cValueSIGNED_INTTerminalRuleCall_2_0_1 = (RuleCall)cValueAlternatives_2_0.eContents().get(1);
		private final Keyword cDeprecatedKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//enumValue:
		//  name=STRING "=" value=( INT | SIGNED_INT ) "deprecated"?; 	
		//
		//   
		/// * New syntax to be introduced in mak 0.9
		//enumType:
		//  'enum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}'); 
		//
		//setEnumType:
		//  'setEnum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}');* /
		public ParserRule getRule() { return rule; }

		//name=STRING "=" value=( INT | SIGNED_INT ) "deprecated"?
		public Group getGroup() { return cGroup; }

		//name=STRING
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_0_0() { return cNameSTRINGTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=( INT | SIGNED_INT )
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//INT|SIGNED_INT
		public Alternatives getValueAlternatives_2_0() { return cValueAlternatives_2_0; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_2_0_0() { return cValueINTTerminalRuleCall_2_0_0; }

		//SIGNED_INT
		public RuleCall getValueSIGNED_INTTerminalRuleCall_2_0_1() { return cValueSIGNED_INTTerminalRuleCall_2_0_1; }

		//"deprecated"?
		public Keyword getDeprecatedKeyword_3() { return cDeprecatedKeyword_3; }
	}

	public class CharTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "charType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCharTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCharKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cLengthAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cLengthINTTerminalRuleCall_2_1_0 = (RuleCall)cLengthAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//charType:
		//  {charType} "char" ("[" length=INT? "]")?;
		public ParserRule getRule() { return rule; }

		//{charType} "char" ("[" length=INT? "]")?
		public Group getGroup() { return cGroup; }

		//{charType}
		public Action getCharTypeAction_0() { return cCharTypeAction_0; }

		//"char"
		public Keyword getCharKeyword_1() { return cCharKeyword_1; }

		//("[" length=INT? "]")?
		public Group getGroup_2() { return cGroup_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2_0() { return cLeftSquareBracketKeyword_2_0; }

		//length=INT?
		public Assignment getLengthAssignment_2_1() { return cLengthAssignment_2_1; }

		//INT
		public RuleCall getLengthINTTerminalRuleCall_2_1_0() { return cLengthINTTerminalRuleCall_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2_2() { return cRightSquareBracketKeyword_2_2; }
	}

	public class PointerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "pointer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPointerAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPtrKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//pointer:
		//  {pointer} "ptr" type=type?;
		public ParserRule getRule() { return rule; }

		//{pointer} "ptr" type=type?
		public Group getGroup() { return cGroup; }

		//{pointer}
		public Action getPointerAction_0() { return cPointerAction_0; }

		//"ptr"
		public Keyword getPtrKeyword_1() { return cPtrKeyword_1; }

		//type=type?
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
	}

	public class SetTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "setType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSetTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSetKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//setType:
		//  {setType} "set" type=type?;
		public ParserRule getRule() { return rule; }

		//{setType} "set" type=type?
		public Group getGroup() { return cGroup; }

		//{setType}
		public Action getSetTypeAction_0() { return cSetTypeAction_0; }

		//"set"
		public Keyword getSetKeyword_1() { return cSetKeyword_1; }

		//type=type?
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
	}

	public class SubFieldDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "subFieldDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSubFieldOfAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cSubFieldOfFieldDeclarationCrossReference_0_0 = (CrossReference)cSubFieldOfAssignment_0.eContents().get(0);
		private final RuleCall cSubFieldOfFieldDeclarationIDTerminalRuleCall_0_0_1 = (RuleCall)cSubFieldOfFieldDeclarationCrossReference_0_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDDeclarationParserRuleCall_2_0 = (RuleCall)cDAssignment_2.eContents().get(0);
		
		//subFieldDeclaration:
		//  subFieldOf=[fieldDeclaration] "->" d=declaration; 
		//
		//
		//	        
		//
		//
		////TODO: add keyword
		public ParserRule getRule() { return rule; }

		//subFieldOf=[fieldDeclaration] "->" d=declaration
		public Group getGroup() { return cGroup; }

		//subFieldOf=[fieldDeclaration]
		public Assignment getSubFieldOfAssignment_0() { return cSubFieldOfAssignment_0; }

		//[fieldDeclaration]
		public CrossReference getSubFieldOfFieldDeclarationCrossReference_0_0() { return cSubFieldOfFieldDeclarationCrossReference_0_0; }

		//ID
		public RuleCall getSubFieldOfFieldDeclarationIDTerminalRuleCall_0_0_1() { return cSubFieldOfFieldDeclarationIDTerminalRuleCall_0_0_1; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }

		//d=declaration
		public Assignment getDAssignment_2() { return cDAssignment_2; }

		//declaration
		public RuleCall getDDeclarationParserRuleCall_2_0() { return cDDeclarationParserRuleCall_2_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cKeywordParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_1_0 = (RuleCall)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cKeywordParserRuleCall_1_1_1 = (RuleCall)cAlternatives_1_1.eContents().get(1);
		
		//type returns ecore::EString:
		//  (ID|keyword) (("."|"->") (ID|keyword))*; 
		//
		//
		////TODO: add keyword
		//      
		//
		//
		//
		//// !title = name
		public ParserRule getRule() { return rule; }

		//(ID|keyword) (("."|"->") (ID|keyword))*
		public Group getGroup() { return cGroup; }

		//ID|keyword
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_0_0() { return cIDTerminalRuleCall_0_0; }

		//keyword
		public RuleCall getKeywordParserRuleCall_0_1() { return cKeywordParserRuleCall_0_1; }

		//(("."|"->") (ID|keyword))*
		public Group getGroup_1() { return cGroup_1; }

		//"."|"->"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//"."
		public Keyword getFullStopKeyword_1_0_0() { return cFullStopKeyword_1_0_0; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_0_1() { return cHyphenMinusGreaterThanSignKeyword_1_0_1; }

		//ID|keyword
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1_0() { return cIDTerminalRuleCall_1_1_0; }

		//keyword
		public RuleCall getKeywordParserRuleCall_1_1_1() { return cKeywordParserRuleCall_1_1_1; }
	}

	public class TitleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "titleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cTitleKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTitleAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTitleTitleParserRuleCall_3_0 = (RuleCall)cTitleAssignment_3.eContents().get(0);
		
		//titleDeclaration:
		//  "!" "title" "=" title=title; 
		//
		//
		//
		//// !title = name
		public ParserRule getRule() { return rule; }

		//"!" "title" "=" title=title
		public Group getGroup() { return cGroup; }

		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//"title"
		public Keyword getTitleKeyword_1() { return cTitleKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//title=title
		public Assignment getTitleAssignment_3() { return cTitleAssignment_3; }

		//title
		public RuleCall getTitleTitleParserRuleCall_3_0() { return cTitleTitleParserRuleCall_3_0; }
	}

	public class TitleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "title");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNameTypeParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final RuleCall cFunctionCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//title:
		//  name=type|functionCall; 
		//
		//       
		//
		//
		//// !include = general.Address
		public ParserRule getRule() { return rule; }

		//name=type|functionCall 
		//
		//       
		//
		//
		//// !include = general.Address
		public Alternatives getAlternatives() { return cAlternatives; }

		//name=type
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//type
		public RuleCall getNameTypeParserRuleCall_0_0() { return cNameTypeParserRuleCall_0_0; }

		//functionCall
		public RuleCall getFunctionCallParserRuleCall_1() { return cFunctionCallParserRuleCall_1; }
	}

	public class IncludeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "includeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cIncludeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cImportedNamespaceAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cImportedNamespaceTypeParserRuleCall_3_0 = (RuleCall)cImportedNamespaceAssignment_3.eContents().get(0);
		
		//includeDeclaration:
		//  "!" "include" "=" importedNamespace=type; 
		//
		//
		//// !include = general.Address
		//
		//          
		//
		//// !type.genDef = ...
		public ParserRule getRule() { return rule; }

		//"!" "include" "=" importedNamespace=type
		public Group getGroup() { return cGroup; }

		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//"include"
		public Keyword getIncludeKeyword_1() { return cIncludeKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//importedNamespace=type
		public Assignment getImportedNamespaceAssignment_3() { return cImportedNamespaceAssignment_3; }

		//type
		public RuleCall getImportedNamespaceTypeParserRuleCall_3_0() { return cImportedNamespaceTypeParserRuleCall_3_0; }
	}

	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "typeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cTypeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cFieldTypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cFieldTypeFieldTypeParserRuleCall_5_0 = (RuleCall)cFieldTypeAssignment_5.eContents().get(0);
		
		//typeDeclaration:
		//  "!" "type" "." name=ID "=" fieldType=fieldType;   
		//
		//// !type.genDef = ...
		//
		//                     
		//
		/////// Validation Rules
		public ParserRule getRule() { return rule; }

		//"!" "type" "." name=ID "=" fieldType=fieldType
		public Group getGroup() { return cGroup; }

		//"!"
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//"type"
		public Keyword getTypeKeyword_1() { return cTypeKeyword_1; }

		//"."
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }

		//name=ID
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_3_0() { return cNameIDTerminalRuleCall_3_0; }

		//"="
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }

		//fieldType=fieldType
		public Assignment getFieldTypeAssignment_5() { return cFieldTypeAssignment_5; }

		//fieldType
		public RuleCall getFieldTypeFieldTypeParserRuleCall_5_0() { return cFieldTypeFieldTypeParserRuleCall_5_0; }
	}

	public class ValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "validationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cRangeValidationRuleDeclarationParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cUniquenessValidationRuleDeclarationParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cComparisonValidationRuleDeclarationParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cRegexValidationRuleDeclarationParserRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final Assignment cErrorMessageAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cErrorMessageErrorMessageParserRuleCall_1_0 = (RuleCall)cErrorMessageAssignment_1.eContents().get(0);
		
		//validationRuleDeclaration:
		//  (rangeValidationRuleDeclaration|uniquenessValidationRuleDeclaration|
		//  comparisonValidationRuleDeclaration|regexValidationRuleDeclaration) errorMessage=
		//  errorMessage; 
		//
		/////// Validation Rules
		public ParserRule getRule() { return rule; }

		//(rangeValidationRuleDeclaration|uniquenessValidationRuleDeclaration|
		//comparisonValidationRuleDeclaration|regexValidationRuleDeclaration) errorMessage=
		//errorMessage
		public Group getGroup() { return cGroup; }

		//rangeValidationRuleDeclaration|uniquenessValidationRuleDeclaration|
		//comparisonValidationRuleDeclaration|regexValidationRuleDeclaration
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//rangeValidationRuleDeclaration
		public RuleCall getRangeValidationRuleDeclarationParserRuleCall_0_0() { return cRangeValidationRuleDeclarationParserRuleCall_0_0; }

		//uniquenessValidationRuleDeclaration
		public RuleCall getUniquenessValidationRuleDeclarationParserRuleCall_0_1() { return cUniquenessValidationRuleDeclarationParserRuleCall_0_1; }

		//comparisonValidationRuleDeclaration
		public RuleCall getComparisonValidationRuleDeclarationParserRuleCall_0_2() { return cComparisonValidationRuleDeclarationParserRuleCall_0_2; }

		//regexValidationRuleDeclaration
		public RuleCall getRegexValidationRuleDeclarationParserRuleCall_0_3() { return cRegexValidationRuleDeclarationParserRuleCall_0_3; }

		//errorMessage=errorMessage
		public Assignment getErrorMessageAssignment_1() { return cErrorMessageAssignment_1; }

		//errorMessage
		public RuleCall getErrorMessageErrorMessageParserRuleCall_1_0() { return cErrorMessageErrorMessageParserRuleCall_1_0; }
	}

	public class ComparisonValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "comparisonValidationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameCompareKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cArgsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgsFunctionArgumentsParserRuleCall_1_0 = (RuleCall)cArgsAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cComparisonExpAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cComparisonExpComparisonExpressionParserRuleCall_3_0 = (RuleCall)cComparisonExpAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//comparisonValidationRuleDeclaration:
		//  name="compare" args=functionArguments "{" comparisonExp=comparisonExpression "}"; 
		//
		//
		//	          
		//	
		//
		////////// COMPARISON EXPRESSION
		public ParserRule getRule() { return rule; }

		//name="compare" args=functionArguments "{" comparisonExp=comparisonExpression "}"
		public Group getGroup() { return cGroup; }

		//name="compare"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"compare"
		public Keyword getNameCompareKeyword_0_0() { return cNameCompareKeyword_0_0; }

		//args=functionArguments
		public Assignment getArgsAssignment_1() { return cArgsAssignment_1; }

		//functionArguments
		public RuleCall getArgsFunctionArgumentsParserRuleCall_1_0() { return cArgsFunctionArgumentsParserRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//comparisonExp=comparisonExpression
		public Assignment getComparisonExpAssignment_3() { return cComparisonExpAssignment_3; }

		//comparisonExpression
		public RuleCall getComparisonExpComparisonExpressionParserRuleCall_3_0() { return cComparisonExpComparisonExpressionParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "comparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsComparisonPartParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Assignment cOAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOOperatorParserRuleCall_1_0 = (RuleCall)cOAssignment_1.eContents().get(0);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsComparisonPartParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//comparisonExpression:
		//  lhs=comparisonPart o=operator rhs=comparisonPart; 
		//
		////////// COMPARISON EXPRESSION
		public ParserRule getRule() { return rule; }

		//lhs=comparisonPart o=operator rhs=comparisonPart
		public Group getGroup() { return cGroup; }

		//lhs=comparisonPart
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//comparisonPart
		public RuleCall getLhsComparisonPartParserRuleCall_0_0() { return cLhsComparisonPartParserRuleCall_0_0; }

		//o=operator
		public Assignment getOAssignment_1() { return cOAssignment_1; }

		//operator
		public RuleCall getOOperatorParserRuleCall_1_0() { return cOOperatorParserRuleCall_1_0; }

		//rhs=comparisonPart
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//comparisonPart
		public RuleCall getRhsComparisonPartParserRuleCall_2_0() { return cRhsComparisonPartParserRuleCall_2_0; }
	}

	public class ComparisonPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "comparisonPart");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTTypeParserRuleCall_0_0 = (RuleCall)cTAssignment_0.eContents().get(0);
		private final Assignment cNAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNINTTerminalRuleCall_1_0 = (RuleCall)cNAssignment_1.eContents().get(0);
		private final Assignment cDfAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cDfDateFunctionParserRuleCall_2_0 = (RuleCall)cDfAssignment_2.eContents().get(0);
		private final Assignment cUAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cUUpperFunctionParserRuleCall_3_0 = (RuleCall)cUAssignment_3.eContents().get(0);
		private final Assignment cLAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cLLowerFunctionParserRuleCall_4_0 = (RuleCall)cLAssignment_4.eContents().get(0);
		private final Assignment cDAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cDDateConstantParserRuleCall_5_0 = (RuleCall)cDAssignment_5.eContents().get(0);
		
		//comparisonPart:
		//  t=type|n=INT|df=dateFunction|u=upperFunction|l=lowerFunction|d=dateConstant; 
		//	
		//
		//	  
		//	    //number
		//	   
		//	  
		//	  
		//	  
		//	
		//
		//// here we pass only the type name of the argument, with the function as type
		public ParserRule getRule() { return rule; }

		//t=type|n=INT|df=dateFunction|u=upperFunction|l=lowerFunction|d=dateConstant 
		//	
		//
		//	  
		//	    //number
		//	   
		//	  
		//	  
		//	  
		//	
		//
		//// here we pass only the type name of the argument, with the function as type
		public Alternatives getAlternatives() { return cAlternatives; }

		//t=type
		public Assignment getTAssignment_0() { return cTAssignment_0; }

		//type
		public RuleCall getTTypeParserRuleCall_0_0() { return cTTypeParserRuleCall_0_0; }

		//n=INT     //number
		public Assignment getNAssignment_1() { return cNAssignment_1; }

		//INT   //number
		public RuleCall getNINTTerminalRuleCall_1_0() { return cNINTTerminalRuleCall_1_0; }

		//df=dateFunction
		public Assignment getDfAssignment_2() { return cDfAssignment_2; }

		//dateFunction
		public RuleCall getDfDateFunctionParserRuleCall_2_0() { return cDfDateFunctionParserRuleCall_2_0; }

		//u=upperFunction
		public Assignment getUAssignment_3() { return cUAssignment_3; }

		//upperFunction
		public RuleCall getUUpperFunctionParserRuleCall_3_0() { return cUUpperFunctionParserRuleCall_3_0; }

		//l=lowerFunction
		public Assignment getLAssignment_4() { return cLAssignment_4; }

		//lowerFunction
		public RuleCall getLLowerFunctionParserRuleCall_4_0() { return cLLowerFunctionParserRuleCall_4_0; }

		//d=dateConstant
		public Assignment getDAssignment_5() { return cDAssignment_5; }

		//dateConstant
		public RuleCall getDDateConstantParserRuleCall_5_0() { return cDDateConstantParserRuleCall_5_0; }
	}

	public class UpperFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "upperFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUpperKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTTypeParserRuleCall_2_0 = (RuleCall)cTAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//upperFunction:
		//  "upper" "(" t=type ")"; 
		//
		//// here we pass only the type name of the argument, with the function as type
		//
		//	        
		//	
		//
		//// here we pass only the type name of the argument, with the function as type
		public ParserRule getRule() { return rule; }

		//"upper" "(" t=type ")"
		public Group getGroup() { return cGroup; }

		//"upper"
		public Keyword getUpperKeyword_0() { return cUpperKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//t=type
		public Assignment getTAssignment_2() { return cTAssignment_2; }

		//type
		public RuleCall getTTypeParserRuleCall_2_0() { return cTTypeParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class LowerFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lowerFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLowerKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTTypeParserRuleCall_2_0 = (RuleCall)cTAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//lowerFunction:
		//  "lower" "(" t=type ")"; 
		//
		//// here we pass only the type name of the argument, with the function as type
		public ParserRule getRule() { return rule; }

		//"lower" "(" t=type ")"
		public Group getGroup() { return cGroup; }

		//"lower"
		public Keyword getLowerKeyword_0() { return cLowerKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//t=type
		public Assignment getTAssignment_2() { return cTAssignment_2; }

		//type
		public RuleCall getTTypeParserRuleCall_2_0() { return cTTypeParserRuleCall_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class OperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEqualsSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLessThanSignEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cGreaterThanSignEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cExclamationMarkEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cCircumflexAccentEqualsSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cLessThanSignGreaterThanSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cLikeKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		
		//operator returns ecore::EString:
		//  "="|"<"|">"|"<="|">="|"!="|"^="|"<>"|"like";
		public ParserRule getRule() { return rule; }

		//"="|"<"|">"|"<="|">="|"!="|"^="|"<>"|"like"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"="
		public Keyword getEqualsSignKeyword_0() { return cEqualsSignKeyword_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }

		//">"
		public Keyword getGreaterThanSignKeyword_2() { return cGreaterThanSignKeyword_2; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_3() { return cLessThanSignEqualsSignKeyword_3; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_4() { return cGreaterThanSignEqualsSignKeyword_4; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_5() { return cExclamationMarkEqualsSignKeyword_5; }

		//"^="
		public Keyword getCircumflexAccentEqualsSignKeyword_6() { return cCircumflexAccentEqualsSignKeyword_6; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_7() { return cLessThanSignGreaterThanSignKeyword_7; }

		//"like"
		public Keyword getLikeKeyword_8() { return cLikeKeyword_8; }
	}

	public class DateConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dateConstant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cNowKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cTodayKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//dateConstant returns ecore::EString:
		//  "$now"|"$today";
		public ParserRule getRule() { return rule; }

		//"$now"|"$today"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"$now"
		public Keyword getNowKeyword_0() { return cNowKeyword_0; }

		//"$today"
		public Keyword getTodayKeyword_1() { return cTodayKeyword_1; }
	}

	public class DateFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dateFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDateKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cDateFunctionArgumentParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cDateFunctionArgumentParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//dateFunction returns ecore::EString:
		//  "date" "(" dateFunctionArgument ("," dateFunctionArgument)* ")";
		public ParserRule getRule() { return rule; }

		//"date" "(" dateFunctionArgument ("," dateFunctionArgument)* ")"
		public Group getGroup() { return cGroup; }

		//"date"
		public Keyword getDateKeyword_0() { return cDateKeyword_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//dateFunctionArgument
		public RuleCall getDateFunctionArgumentParserRuleCall_2() { return cDateFunctionArgumentParserRuleCall_2; }

		//("," dateFunctionArgument)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//dateFunctionArgument
		public RuleCall getDateFunctionArgumentParserRuleCall_3_1() { return cDateFunctionArgumentParserRuleCall_3_1; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class DateFunctionArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dateFunctionArgument");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDateFunctionArgumentMemberParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final RuleCall cDateFunctionArgumentMemberParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//dateFunctionArgument returns ecore::EString:
		//  dateFunctionArgumentMember (("+"|"-") dateFunctionArgumentMember)?;
		public ParserRule getRule() { return rule; }

		//dateFunctionArgumentMember (("+"|"-") dateFunctionArgumentMember)?
		public Group getGroup() { return cGroup; }

		//dateFunctionArgumentMember
		public RuleCall getDateFunctionArgumentMemberParserRuleCall_0() { return cDateFunctionArgumentMemberParserRuleCall_0; }

		//(("+"|"-") dateFunctionArgumentMember)?
		public Group getGroup_1() { return cGroup_1; }

		//"+"|"-"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_0() { return cPlusSignKeyword_1_0_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0_1() { return cHyphenMinusKeyword_1_0_1; }

		//dateFunctionArgumentMember
		public RuleCall getDateFunctionArgumentMemberParserRuleCall_1_1() { return cDateFunctionArgumentMemberParserRuleCall_1_1; }
	}

	public class DateFunctionArgumentMemberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "dateFunctionArgumentMember");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDateConstantParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//dateFunctionArgumentMember returns ecore::EString:
		//  INT|dateConstant; 
		//	
		//
		//	    //number
		//	   
		//	
		//
		//
		////////// RANGE DEFINITION
		public ParserRule getRule() { return rule; }

		//INT|dateConstant 
		//	
		//
		//	    //number
		//	   
		//	
		//
		//
		////////// RANGE DEFINITION
		public Alternatives getAlternatives() { return cAlternatives; }

		//INT     //number
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//dateConstant
		public RuleCall getDateConstantParserRuleCall_1() { return cDateConstantParserRuleCall_1; }
	}

	public class RangeValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "rangeValidationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cNameAlternatives_0_0 = (Alternatives)cNameAssignment_0.eContents().get(0);
		private final Keyword cNameRangeKeyword_0_0_0 = (Keyword)cNameAlternatives_0_0.eContents().get(0);
		private final Keyword cNameLengthKeyword_0_0_1 = (Keyword)cNameAlternatives_0_0.eContents().get(1);
		private final Assignment cArgsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgsFunctionArgumentsParserRuleCall_1_0 = (RuleCall)cArgsAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRangeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRangeRangeParserRuleCall_3_0 = (RuleCall)cRangeAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//rangeValidationRuleDeclaration:
		//  name=( "range" | "length" ) args=functionArguments "{" range=range "}"; 
		//
		//
		////////// RANGE DEFINITION
		public ParserRule getRule() { return rule; }

		//name=( "range" | "length" ) args=functionArguments "{" range=range "}"
		public Group getGroup() { return cGroup; }

		//name=( "range" | "length" )
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"range"|"length"
		public Alternatives getNameAlternatives_0_0() { return cNameAlternatives_0_0; }

		//"range"
		public Keyword getNameRangeKeyword_0_0_0() { return cNameRangeKeyword_0_0_0; }

		//"length"
		public Keyword getNameLengthKeyword_0_0_1() { return cNameLengthKeyword_0_0_1; }

		//args=functionArguments
		public Assignment getArgsAssignment_1() { return cArgsAssignment_1; }

		//functionArguments
		public RuleCall getArgsFunctionArgumentsParserRuleCall_1_0() { return cArgsFunctionArgumentsParserRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//range=range
		public Assignment getRangeAssignment_3() { return cRangeAssignment_3; }

		//range
		public RuleCall getRangeRangeParserRuleCall_3_0() { return cRangeRangeParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class RegexValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "regexValidationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameMatchesKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cArgsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgsFunctionArgumentsParserRuleCall_1_0 = (RuleCall)cArgsAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpSTRINGTerminalRuleCall_3_0 = (RuleCall)cExpAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//regexValidationRuleDeclaration:
		//  name="matches" args=functionArguments "{" exp=STRING "}"; 
		//	
		//
		//	          
		//	
		//
		//// name%length = [1..?]
		//// age%range = [18..99]
		public ParserRule getRule() { return rule; }

		//name="matches" args=functionArguments "{" exp=STRING "}"
		public Group getGroup() { return cGroup; }

		//name="matches"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"matches"
		public Keyword getNameMatchesKeyword_0_0() { return cNameMatchesKeyword_0_0; }

		//args=functionArguments
		public Assignment getArgsAssignment_1() { return cArgsAssignment_1; }

		//functionArguments
		public RuleCall getArgsFunctionArgumentsParserRuleCall_1_0() { return cArgsFunctionArgumentsParserRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//exp=STRING
		public Assignment getExpAssignment_3() { return cExpAssignment_3; }

		//STRING
		public RuleCall getExpSTRINGTerminalRuleCall_3_0() { return cExpSTRINGTerminalRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFRangeBoundParserRuleCall_0_0 = (RuleCall)cFAssignment_0.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTRangeBoundParserRuleCall_2_0 = (RuleCall)cTAssignment_2.eContents().get(0);
		
		//range:
		//  f=rangeBound ".." t=rangeBound; 
		//
		//// name%length = [1..?]
		//// age%range = [18..99]
		//
		//     
		//            
		//    
		//
		//// [1..?] [?..5]
		public ParserRule getRule() { return rule; }

		//f=rangeBound ".." t=rangeBound
		public Group getGroup() { return cGroup; }

		//f=rangeBound
		public Assignment getFAssignment_0() { return cFAssignment_0; }

		//rangeBound
		public RuleCall getFRangeBoundParserRuleCall_0_0() { return cFRangeBoundParserRuleCall_0_0; }

		//".."
		public Keyword getFullStopFullStopKeyword_1() { return cFullStopFullStopKeyword_1; }

		//t=rangeBound
		public Assignment getTAssignment_2() { return cTAssignment_2; }

		//rangeBound
		public RuleCall getTRangeBoundParserRuleCall_2_0() { return cTRangeBoundParserRuleCall_2_0; }
	}

	public class RangeBoundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "rangeBound");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//rangeBound returns ecore::EString:
		//  INT|"?"; 
		//
		//// [1..?] [?..5]
		//
		//          
		//    
		//
		//// unique(field1, field2) : "These need to be unique"
		public ParserRule getRule() { return rule; }

		//INT|"?" 
		//
		//// [1..?] [?..5]
		//
		//          
		//    
		//
		//// unique(field1, field2) : "These need to be unique"
		public Alternatives getAlternatives() { return cAlternatives; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//"?"
		public Keyword getQuestionMarkKeyword_1() { return cQuestionMarkKeyword_1; }
	}

	public class UniquenessValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "uniquenessValidationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameUniqueKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cArgsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgsFunctionArgumentsParserRuleCall_1_0 = (RuleCall)cArgsAssignment_1.eContents().get(0);
		
		//uniquenessValidationRuleDeclaration:
		//  name="unique" args=functionArguments; 
		//
		//// unique(field1, field2) : "These need to be unique"
		public ParserRule getRule() { return rule; }

		//name="unique" args=functionArguments
		public Group getGroup() { return cGroup; }

		//name="unique"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"unique"
		public Keyword getNameUniqueKeyword_0_0() { return cNameUniqueKeyword_0_0; }

		//args=functionArguments
		public Assignment getArgsAssignment_1() { return cArgsAssignment_1; }

		//functionArguments
		public RuleCall getArgsFunctionArgumentsParserRuleCall_1_0() { return cArgsFunctionArgumentsParserRuleCall_1_0; }
	}

	public class ErrorMessageElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "errorMessage");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cMessageAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMessageSTRINGTerminalRuleCall_1_0 = (RuleCall)cMessageAssignment_1.eContents().get(0);
		
		//errorMessage:
		//  ":" message=STRING;
		public ParserRule getRule() { return rule; }

		//":" message=STRING
		public Group getGroup() { return cGroup; }

		//":"
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }

		//message=STRING
		public Assignment getMessageAssignment_1() { return cMessageAssignment_1; }

		//STRING
		public RuleCall getMessageSTRINGTerminalRuleCall_1_0() { return cMessageSTRINGTerminalRuleCall_1_0; }
	}

	public class NativeValidationRuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "nativeValidationRuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFieldAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFieldFieldDeclarationCrossReference_0_0 = (CrossReference)cFieldAssignment_0.eContents().get(0);
		private final RuleCall cFieldFieldDeclarationIDTerminalRuleCall_0_0_1 = (RuleCall)cFieldFieldDeclarationCrossReference_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cTypeAlternatives_2_0 = (Alternatives)cTypeAssignment_2.eContents().get(0);
		private final Keyword cTypeUniqueKeyword_2_0_0 = (Keyword)cTypeAlternatives_2_0.eContents().get(0);
		private final Keyword cTypeNotNullKeyword_2_0_1 = (Keyword)cTypeAlternatives_2_0.eContents().get(1);
		private final Keyword cTypeNaNKeyword_2_0_2 = (Keyword)cTypeAlternatives_2_0.eContents().get(2);
		private final Keyword cTypeNotEmptyKeyword_2_0_3 = (Keyword)cTypeAlternatives_2_0.eContents().get(3);
		private final Keyword cTypeNotIntKeyword_2_0_4 = (Keyword)cTypeAlternatives_2_0.eContents().get(4);
		private final Keyword cTypeNotRealKeyword_2_0_5 = (Keyword)cTypeAlternatives_2_0.eContents().get(5);
		private final Keyword cTypeNotBooleanKeyword_2_0_6 = (Keyword)cTypeAlternatives_2_0.eContents().get(6);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cMessageAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cMessageSTRINGTerminalRuleCall_4_0 = (RuleCall)cMessageAssignment_4.eContents().get(0);
		
		//nativeValidationRuleDeclaration:
		//  field=[fieldDeclaration] "." type=( "unique" | "notNull" | "NaN" | "notEmpty" | "notInt" |
		//  "notReal" | "notBoolean" ) "=" message=STRING; 
		//
		//
		//        
		//      
		//        
		//        
		//        
		//        
		//        
		//        
		//        
		//      
		//      
		//      
		//    
		//
		//
		/////// Functions
		public ParserRule getRule() { return rule; }

		//field=[fieldDeclaration] "." type=( "unique" | "notNull" | "NaN" | "notEmpty" | "notInt" |
		//"notReal" | "notBoolean" ) "=" message=STRING
		public Group getGroup() { return cGroup; }

		//field=[fieldDeclaration]
		public Assignment getFieldAssignment_0() { return cFieldAssignment_0; }

		//[fieldDeclaration]
		public CrossReference getFieldFieldDeclarationCrossReference_0_0() { return cFieldFieldDeclarationCrossReference_0_0; }

		//ID
		public RuleCall getFieldFieldDeclarationIDTerminalRuleCall_0_0_1() { return cFieldFieldDeclarationIDTerminalRuleCall_0_0_1; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//type=( "unique" | "notNull" | "NaN" | "notEmpty" | "notInt" | "notReal" | "notBoolean" )
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//"unique"|"notNull"|"NaN"|"notEmpty"|"notInt"|"notReal"|"notBoolean"
		public Alternatives getTypeAlternatives_2_0() { return cTypeAlternatives_2_0; }

		//"unique"
		public Keyword getTypeUniqueKeyword_2_0_0() { return cTypeUniqueKeyword_2_0_0; }

		//"notNull"
		public Keyword getTypeNotNullKeyword_2_0_1() { return cTypeNotNullKeyword_2_0_1; }

		//"NaN"
		public Keyword getTypeNaNKeyword_2_0_2() { return cTypeNaNKeyword_2_0_2; }

		//"notEmpty"
		public Keyword getTypeNotEmptyKeyword_2_0_3() { return cTypeNotEmptyKeyword_2_0_3; }

		//"notInt"
		public Keyword getTypeNotIntKeyword_2_0_4() { return cTypeNotIntKeyword_2_0_4; }

		//"notReal"
		public Keyword getTypeNotRealKeyword_2_0_5() { return cTypeNotRealKeyword_2_0_5; }

		//"notBoolean"
		public Keyword getTypeNotBooleanKeyword_2_0_6() { return cTypeNotBooleanKeyword_2_0_6; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//message=STRING
		public Assignment getMessageAssignment_4() { return cMessageAssignment_4; }

		//STRING
		public RuleCall getMessageSTRINGTerminalRuleCall_4_0() { return cMessageSTRINGTerminalRuleCall_4_0; }
	}

	public class FunctionDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "functionDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cBAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cBIDTerminalRuleCall_0_0_0 = (RuleCall)cBAssignment_0_0.eContents().get(0);
		private final Keyword cPercentSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cArgAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgFunctionArgumentDeclarationParserRuleCall_2_0 = (RuleCall)cArgAssignment_2.eContents().get(0);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyFunctionBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		private final Assignment cMAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cMErrorMessageParserRuleCall_4_0 = (RuleCall)cMAssignment_4.eContents().get(0);
		
		//functionDeclaration:
		//  (b=ID "%")? name=ID arg=functionArgumentDeclaration body=functionBody m=errorMessage?
		//; 
		//
		//
		/////// Functions
		public ParserRule getRule() { return rule; }

		//(b=ID "%")? name=ID arg=functionArgumentDeclaration body=functionBody m=errorMessage?
		public Group getGroup() { return cGroup; }

		//(b=ID "%")?
		public Group getGroup_0() { return cGroup_0; }

		//b=ID
		public Assignment getBAssignment_0_0() { return cBAssignment_0_0; }

		//ID
		public RuleCall getBIDTerminalRuleCall_0_0_0() { return cBIDTerminalRuleCall_0_0_0; }

		//"%"
		public Keyword getPercentSignKeyword_0_1() { return cPercentSignKeyword_0_1; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//arg=functionArgumentDeclaration
		public Assignment getArgAssignment_2() { return cArgAssignment_2; }

		//functionArgumentDeclaration
		public RuleCall getArgFunctionArgumentDeclarationParserRuleCall_2_0() { return cArgFunctionArgumentDeclarationParserRuleCall_2_0; }

		//body=functionBody
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }

		//functionBody
		public RuleCall getBodyFunctionBodyParserRuleCall_3_0() { return cBodyFunctionBodyParserRuleCall_3_0; }

		//m=errorMessage?
		public Assignment getMAssignment_4() { return cMAssignment_4; }

		//errorMessage
		public RuleCall getMErrorMessageParserRuleCall_4_0() { return cMErrorMessageParserRuleCall_4_0; }
	}

	public class FunctionArgumentDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "functionArgumentDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionArgumentDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFFunctionArgumentBodyParserRuleCall_2_0 = (RuleCall)cFAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cFAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cFFunctionArgumentBodyParserRuleCall_3_1_0 = (RuleCall)cFAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//functionArgumentDeclaration:
		//  {functionArgumentDeclaration} "(" f+=functionArgumentBody? ("," f+=
		//  functionArgumentBody)* ")"; 
		//  
		//
		//          
		//
		//// TODO: fix this so that function label can show param type instead of the name
		//// ugly fix until the syntax change
		public ParserRule getRule() { return rule; }

		//{functionArgumentDeclaration} "(" f+=functionArgumentBody? ("," f+=
		//functionArgumentBody)* ")"
		public Group getGroup() { return cGroup; }

		//{functionArgumentDeclaration}
		public Action getFunctionArgumentDeclarationAction_0() { return cFunctionArgumentDeclarationAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//f+=functionArgumentBody?
		public Assignment getFAssignment_2() { return cFAssignment_2; }

		//functionArgumentBody
		public RuleCall getFFunctionArgumentBodyParserRuleCall_2_0() { return cFFunctionArgumentBodyParserRuleCall_2_0; }

		//("," f+=functionArgumentBody)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//f+=functionArgumentBody
		public Assignment getFAssignment_3_1() { return cFAssignment_3_1; }

		//functionArgumentBody
		public RuleCall getFFunctionArgumentBodyParserRuleCall_3_1_0() { return cFFunctionArgumentBodyParserRuleCall_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class FunctionArgumentBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "functionArgumentBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cCharTypeParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cIntEnumParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cAlternatives_0.eContents().get(2);
		private final Keyword cSetKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final RuleCall cIntEnumParserRuleCall_0_2_1 = (RuleCall)cGroup_0_2.eContents().get(1);
		private final RuleCall cCharEnumParserRuleCall_0_3 = (RuleCall)cAlternatives_0.eContents().get(3);
		private final Group cGroup_0_4 = (Group)cAlternatives_0.eContents().get(4);
		private final Keyword cSetKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final RuleCall cCharEnumParserRuleCall_0_4_1 = (RuleCall)cGroup_0_4.eContents().get(1);
		private final Keyword cIntKeyword_0_5 = (Keyword)cAlternatives_0.eContents().get(5);
		private final Keyword cRealKeyword_0_6 = (Keyword)cAlternatives_0.eContents().get(6);
		private final Keyword cBooleanKeyword_0_7 = (Keyword)cAlternatives_0.eContents().get(7);
		private final Keyword cTextKeyword_0_8 = (Keyword)cAlternatives_0.eContents().get(8);
		private final Keyword cBinaryKeyword_0_9 = (Keyword)cAlternatives_0.eContents().get(9);
		private final Keyword cFileKeyword_0_10 = (Keyword)cAlternatives_0.eContents().get(10);
		private final Keyword cDateKeyword_0_11 = (Keyword)cAlternatives_0.eContents().get(11);
		private final Group cGroup_0_12 = (Group)cAlternatives_0.eContents().get(12);
		private final Keyword cPtrKeyword_0_12_0 = (Keyword)cGroup_0_12.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_0_12_1 = (RuleCall)cGroup_0_12.eContents().get(1);
		private final Group cGroup_0_13 = (Group)cAlternatives_0.eContents().get(13);
		private final Keyword cSetKeyword_0_13_0 = (Keyword)cGroup_0_13.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_0_13_1 = (RuleCall)cGroup_0_13.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cNameAlternatives_1_0 = (Alternatives)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_1_0_0 = (RuleCall)cNameAlternatives_1_0.eContents().get(0);
		private final RuleCall cNameKeywordParserRuleCall_1_0_1 = (RuleCall)cNameAlternatives_1_0.eContents().get(1);
		
		//functionArgumentBody:
		//  (charType|intEnum|"set" intEnum|charEnum|"set" charEnum|"int"|"real"|"boolean"|
		//  "text"|"binary"|"file"|"date"|"ptr" type|"set" type) name=( ID | keyword ); 
		//
		//// TODO: fix this so that function label can show param type instead of the name
		//// ugly fix until the syntax change
		public ParserRule getRule() { return rule; }

		//(charType|intEnum|"set" intEnum|charEnum|"set" charEnum|"int"|"real"|"boolean"|
		//"text"|"binary"|"file"|"date"|"ptr" type|"set" type) name=( ID | keyword )
		public Group getGroup() { return cGroup; }

		//charType|intEnum|"set" intEnum|charEnum|"set" charEnum|"int"|"real"|"boolean"|
		//"text"|"binary"|"file"|"date"|"ptr" type|"set" type
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//charType
		public RuleCall getCharTypeParserRuleCall_0_0() { return cCharTypeParserRuleCall_0_0; }

		//intEnum
		public RuleCall getIntEnumParserRuleCall_0_1() { return cIntEnumParserRuleCall_0_1; }

		//"set" intEnum
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"set"
		public Keyword getSetKeyword_0_2_0() { return cSetKeyword_0_2_0; }

		//intEnum
		public RuleCall getIntEnumParserRuleCall_0_2_1() { return cIntEnumParserRuleCall_0_2_1; }

		//charEnum
		public RuleCall getCharEnumParserRuleCall_0_3() { return cCharEnumParserRuleCall_0_3; }

		//"set" charEnum
		public Group getGroup_0_4() { return cGroup_0_4; }

		//"set"
		public Keyword getSetKeyword_0_4_0() { return cSetKeyword_0_4_0; }

		//charEnum
		public RuleCall getCharEnumParserRuleCall_0_4_1() { return cCharEnumParserRuleCall_0_4_1; }

		//"int"
		public Keyword getIntKeyword_0_5() { return cIntKeyword_0_5; }

		//"real"
		public Keyword getRealKeyword_0_6() { return cRealKeyword_0_6; }

		//"boolean"
		public Keyword getBooleanKeyword_0_7() { return cBooleanKeyword_0_7; }

		//"text"
		public Keyword getTextKeyword_0_8() { return cTextKeyword_0_8; }

		//"binary"
		public Keyword getBinaryKeyword_0_9() { return cBinaryKeyword_0_9; }

		//"file"
		public Keyword getFileKeyword_0_10() { return cFileKeyword_0_10; }

		//"date"
		public Keyword getDateKeyword_0_11() { return cDateKeyword_0_11; }

		//"ptr" type
		public Group getGroup_0_12() { return cGroup_0_12; }

		//"ptr"
		public Keyword getPtrKeyword_0_12_0() { return cPtrKeyword_0_12_0; }

		//type
		public RuleCall getTypeParserRuleCall_0_12_1() { return cTypeParserRuleCall_0_12_1; }

		//"set" type
		public Group getGroup_0_13() { return cGroup_0_13; }

		//"set"
		public Keyword getSetKeyword_0_13_0() { return cSetKeyword_0_13_0; }

		//type
		public RuleCall getTypeParserRuleCall_0_13_1() { return cTypeParserRuleCall_0_13_1; }

		//name=( ID | keyword )
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID|keyword
		public Alternatives getNameAlternatives_1_0() { return cNameAlternatives_1_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0_0() { return cNameIDTerminalRuleCall_1_0_0; }

		//keyword
		public RuleCall getNameKeywordParserRuleCall_1_0_1() { return cNameKeywordParserRuleCall_1_0_1; }
	}

	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "functionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cFAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFFunctionArgumentsParserRuleCall_1_0 = (RuleCall)cFAssignment_1.eContents().get(0);
		
		//functionCall:
		//  name=ID f=functionArguments;
		public ParserRule getRule() { return rule; }

		//name=ID f=functionArguments
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//f=functionArguments
		public Assignment getFAssignment_1() { return cFAssignment_1; }

		//functionArguments
		public RuleCall getFFunctionArgumentsParserRuleCall_1_0() { return cFFunctionArgumentsParserRuleCall_1_0; }
	}

	public class FunctionArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "functionArguments");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionArgumentsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cAAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cATypeParserRuleCall_2_0_0 = (RuleCall)cAAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cAAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cATypeParserRuleCall_2_1_1_0 = (RuleCall)cAAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//functionArguments:
		//  {functionArguments} "(" (a+=type ("," a+=type)*)? ")";
		public ParserRule getRule() { return rule; }

		//{functionArguments} "(" (a+=type ("," a+=type)*)? ")"
		public Group getGroup() { return cGroup; }

		//{functionArguments}
		public Action getFunctionArgumentsAction_0() { return cFunctionArgumentsAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//(a+=type ("," a+=type)*)?
		public Group getGroup_2() { return cGroup_2; }

		//a+=type
		public Assignment getAAssignment_2_0() { return cAAssignment_2_0; }

		//type
		public RuleCall getATypeParserRuleCall_2_0_0() { return cATypeParserRuleCall_2_0_0; }

		//("," a+=type)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//a+=type
		public Assignment getAAssignment_2_1_1() { return cAAssignment_2_1_1; }

		//type
		public RuleCall getATypeParserRuleCall_2_1_1_0() { return cATypeParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class FunctionBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "functionBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cSAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cSStatementParserRuleCall_1_0_0 = (RuleCall)cSAssignment_1_0.eContents().get(0);
		private final Assignment cEAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_1_0 = (RuleCall)cEAssignment_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//functionBody:
		//  "{" (s=statement|e=expression) "}"; 
		//  
		//
		//           
		//  
		//
		//
		/////// HQL stuff
		public ParserRule getRule() { return rule; }

		//"{" (s=statement|e=expression) "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//s=statement|e=expression
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//s=statement
		public Assignment getSAssignment_1_0() { return cSAssignment_1_0; }

		//statement
		public RuleCall getSStatementParserRuleCall_1_0_0() { return cSStatementParserRuleCall_1_0_0; }

		//e=expression
		public Assignment getEAssignment_1_1() { return cEAssignment_1_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_1_0() { return cEExpressionParserRuleCall_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "statement");
		private final RuleCall cQueryRuleParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//statement:
		//  queryRule; 
		//
		//
		/////// HQL stuff
		public ParserRule getRule() { return rule; }

		//queryRule
		public RuleCall getQueryRuleParserRuleCall() { return cQueryRuleParserRuleCall; }
	}

	public class UnionRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "unionRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cQAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cQQueryRuleParserRuleCall_0_0 = (RuleCall)cQAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cUnionKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cQAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cQQueryRuleParserRuleCall_1_1_0 = (RuleCall)cQAssignment_1_1.eContents().get(0);
		
		//unionRule:
		//  q+=queryRule ("union" q+=queryRule)*; 
		//
		//
		//
		//	      
		//	
		//
		////## query:
		////##     [selectClause] fromClause [whereClause] [groupByClause] [havingClause] [orderByClause];
		public ParserRule getRule() { return rule; }

		//q+=queryRule ("union" q+=queryRule)*
		public Group getGroup() { return cGroup; }

		//q+=queryRule
		public Assignment getQAssignment_0() { return cQAssignment_0; }

		//queryRule
		public RuleCall getQQueryRuleParserRuleCall_0_0() { return cQQueryRuleParserRuleCall_0_0; }

		//("union" q+=queryRule)*
		public Group getGroup_1() { return cGroup_1; }

		//"union"
		public Keyword getUnionKeyword_1_0() { return cUnionKeyword_1_0; }

		//q+=queryRule
		public Assignment getQAssignment_1_1() { return cQAssignment_1_1; }

		//queryRule
		public RuleCall getQQueryRuleParserRuleCall_1_1_0() { return cQQueryRuleParserRuleCall_1_1_0; }
	}

	public class QueryRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "queryRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSelectFromParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cWhereAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWhereWhereClauseParserRuleCall_1_0 = (RuleCall)cWhereAssignment_1.eContents().get(0);
		private final Assignment cGroupByAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cGroupByGroupByClauseParserRuleCall_2_0 = (RuleCall)cGroupByAssignment_2.eContents().get(0);
		private final Assignment cOrderByAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOrderByOrderByClauseParserRuleCall_3_0 = (RuleCall)cOrderByAssignment_3.eContents().get(0);
		
		//queryRule:
		//  selectFrom where=whereClause? groupBy=groupByClause? orderBy=orderByClause?; 
		//
		////## query:
		////##     [selectClause] fromClause [whereClause] [groupByClause] [havingClause] [orderByClause];
		public ParserRule getRule() { return rule; }

		//selectFrom where=whereClause? groupBy=groupByClause? orderBy=orderByClause?
		public Group getGroup() { return cGroup; }

		//selectFrom
		public RuleCall getSelectFromParserRuleCall_0() { return cSelectFromParserRuleCall_0; }

		//where=whereClause?
		public Assignment getWhereAssignment_1() { return cWhereAssignment_1; }

		//whereClause
		public RuleCall getWhereWhereClauseParserRuleCall_1_0() { return cWhereWhereClauseParserRuleCall_1_0; }

		//groupBy=groupByClause?
		public Assignment getGroupByAssignment_2() { return cGroupByAssignment_2; }

		//groupByClause
		public RuleCall getGroupByGroupByClauseParserRuleCall_2_0() { return cGroupByGroupByClauseParserRuleCall_2_0; }

		//orderBy=orderByClause?
		public Assignment getOrderByAssignment_3() { return cOrderByAssignment_3; }

		//orderByClause
		public RuleCall getOrderByOrderByClauseParserRuleCall_3_0() { return cOrderByOrderByClauseParserRuleCall_3_0; }
	}

	public class SelectFromElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "selectFrom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSelectFromAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSSelectClauseParserRuleCall_1_0 = (RuleCall)cSAssignment_1.eContents().get(0);
		private final Assignment cFromAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFromFromClauseParserRuleCall_2_0 = (RuleCall)cFromAssignment_2.eContents().get(0);
		
		//selectFrom:
		//  {selectFrom} s=selectClause? from=fromClause?; 
		//
		//
		//	        
		//	
		//
		////## selectClause:
		////##     SELECT DISTINCT? selectedPropertiesList | ( NEW className OPEN selectedPropertiesList CLOSE );
		public ParserRule getRule() { return rule; }

		//{selectFrom} s=selectClause? from=fromClause?
		public Group getGroup() { return cGroup; }

		//{selectFrom}
		public Action getSelectFromAction_0() { return cSelectFromAction_0; }

		//s=selectClause?
		public Assignment getSAssignment_1() { return cSAssignment_1; }

		//selectClause
		public RuleCall getSSelectClauseParserRuleCall_1_0() { return cSSelectClauseParserRuleCall_1_0; }

		//from=fromClause?
		public Assignment getFromAssignment_2() { return cFromAssignment_2; }

		//fromClause
		public RuleCall getFromFromClauseParserRuleCall_2_0() { return cFromFromClauseParserRuleCall_2_0; }
	}

	public class SelectClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "selectClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSelectCauseAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSELECTParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cDISTINCTParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cSAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cSSelectedPropertiesListParserRuleCall_3_0_0 = (RuleCall)cSAssignment_3_0.eContents().get(0);
		private final Assignment cNAssignment_3_1 = (Assignment)cAlternatives_3.eContents().get(1);
		private final RuleCall cNNewExpressionParserRuleCall_3_1_0 = (RuleCall)cNAssignment_3_1.eContents().get(0);
		private final RuleCall cSelectObjectParserRuleCall_3_2 = (RuleCall)cAlternatives_3.eContents().get(2);
		
		//selectClause:
		//  {selectCause} SELECT DISTINCT? (s=selectedPropertiesList|n=newExpression|
		//  selectObject); 
		//
		////## selectClause:
		////##     SELECT DISTINCT? selectedPropertiesList | ( NEW className OPEN selectedPropertiesList CLOSE );
		public ParserRule getRule() { return rule; }

		//{selectCause} SELECT DISTINCT? (s=selectedPropertiesList|n=newExpression|
		//selectObject)
		public Group getGroup() { return cGroup; }

		//{selectCause}
		public Action getSelectCauseAction_0() { return cSelectCauseAction_0; }

		//SELECT
		public RuleCall getSELECTParserRuleCall_1() { return cSELECTParserRuleCall_1; }

		//DISTINCT?
		public RuleCall getDISTINCTParserRuleCall_2() { return cDISTINCTParserRuleCall_2; }

		//s=selectedPropertiesList|n=newExpression|selectObject
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//s=selectedPropertiesList
		public Assignment getSAssignment_3_0() { return cSAssignment_3_0; }

		//selectedPropertiesList
		public RuleCall getSSelectedPropertiesListParserRuleCall_3_0_0() { return cSSelectedPropertiesListParserRuleCall_3_0_0; }

		//n=newExpression
		public Assignment getNAssignment_3_1() { return cNAssignment_3_1; }

		//newExpression
		public RuleCall getNNewExpressionParserRuleCall_3_1_0() { return cNNewExpressionParserRuleCall_3_1_0; }

		//selectObject
		public RuleCall getSelectObjectParserRuleCall_3_2() { return cSelectObjectParserRuleCall_3_2; }
	}

	public class NewExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "newExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNEWParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cPAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPPathParserRuleCall_1_0 = (RuleCall)cPAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSSelectedPropertiesListParserRuleCall_3_0 = (RuleCall)cSAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//newExpression:
		//  NEW p=path "(" s=selectedPropertiesList ")";
		public ParserRule getRule() { return rule; }

		//NEW p=path "(" s=selectedPropertiesList ")"
		public Group getGroup() { return cGroup; }

		//NEW
		public RuleCall getNEWParserRuleCall_0() { return cNEWParserRuleCall_0; }

		//p=path
		public Assignment getPAssignment_1() { return cPAssignment_1; }

		//path
		public RuleCall getPPathParserRuleCall_1_0() { return cPPathParserRuleCall_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//s=selectedPropertiesList
		public Assignment getSAssignment_3() { return cSAssignment_3; }

		//selectedPropertiesList
		public RuleCall getSSelectedPropertiesListParserRuleCall_3_0() { return cSSelectedPropertiesListParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class SelectObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "selectObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOBJECTParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//selectObject returns ecore::EString:
		//  OBJECT "(" identifier ")"; 
		//
		//
		//           
		//   
		//
		////## fromClause:
		////##    FROM className AS? identifier (  ( ',' className AS? identifier ) | ( joinType path AS? identifier ) )*;
		//
		//// NOTE: This *must* begin with the "FROM" token, otherwise the sub-query rule will be ambiguous
		//// with the expression rule.
		//// Also note: after a comma weak keywords are allowed and should be treated as identifiers.
		public ParserRule getRule() { return rule; }

		//OBJECT "(" identifier ")"
		public Group getGroup() { return cGroup; }

		//OBJECT
		public RuleCall getOBJECTParserRuleCall_0() { return cOBJECTParserRuleCall_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//identifier
		public RuleCall getIdentifierParserRuleCall_2() { return cIdentifierParserRuleCall_2; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class FromClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fromClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFROMParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cFromRangeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFromRangeFromRangeParserRuleCall_1_0 = (RuleCall)cFromRangeAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cFromJoinAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cFromJoinFromJoinParserRuleCall_2_0_0 = (RuleCall)cFromJoinAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cFromRangeAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cFromRangeFromRangeParserRuleCall_2_1_1_0 = (RuleCall)cFromRangeAssignment_2_1_1.eContents().get(0);
		
		//fromClause:
		//  FROM fromRange+=fromRange (fromJoin+=fromJoin|"," fromRange+=fromRange)*; 
		//
		////## fromClause:
		////##    FROM className AS? identifier (  ( ',' className AS? identifier ) | ( joinType path AS? identifier ) )*;
		//
		//// NOTE: This *must* begin with the "FROM" token, otherwise the sub-query rule will be ambiguous
		//// with the expression rule.
		//// Also note: after a comma weak keywords are allowed and should be treated as identifiers.
		//
		//
		//	                
		//	
		//
		//
		////## joinType:
		////##     ( ( 'left'|'right' 'outer'? ) | 'full' | 'inner' )? JOIN FETCH?;
		public ParserRule getRule() { return rule; }

		//FROM fromRange+=fromRange (fromJoin+=fromJoin|"," fromRange+=fromRange)*
		public Group getGroup() { return cGroup; }

		//FROM
		public RuleCall getFROMParserRuleCall_0() { return cFROMParserRuleCall_0; }

		//fromRange+=fromRange
		public Assignment getFromRangeAssignment_1() { return cFromRangeAssignment_1; }

		//fromRange
		public RuleCall getFromRangeFromRangeParserRuleCall_1_0() { return cFromRangeFromRangeParserRuleCall_1_0; }

		//(fromJoin+=fromJoin|"," fromRange+=fromRange)*
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//fromJoin+=fromJoin
		public Assignment getFromJoinAssignment_2_0() { return cFromJoinAssignment_2_0; }

		//fromJoin
		public RuleCall getFromJoinFromJoinParserRuleCall_2_0_0() { return cFromJoinFromJoinParserRuleCall_2_0_0; }

		//"," fromRange+=fromRange
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//fromRange+=fromRange
		public Assignment getFromRangeAssignment_2_1_1() { return cFromRangeAssignment_2_1_1; }

		//fromRange
		public RuleCall getFromRangeFromRangeParserRuleCall_2_1_1_0() { return cFromRangeFromRangeParserRuleCall_2_1_1_0; }
	}

	public class FromJoinElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fromJoin");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Alternatives cAlternatives_0_0_0 = (Alternatives)cGroup_0_0.eContents().get(0);
		private final RuleCall cLEFTParserRuleCall_0_0_0_0 = (RuleCall)cAlternatives_0_0_0.eContents().get(0);
		private final RuleCall cRIGHTParserRuleCall_0_0_0_1 = (RuleCall)cAlternatives_0_0_0.eContents().get(1);
		private final RuleCall cOUTERParserRuleCall_0_0_1 = (RuleCall)cGroup_0_0.eContents().get(1);
		private final RuleCall cFULLParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cINNERParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final RuleCall cJOINParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cFETCHParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cFromClassOrOuterQueryPathParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cWAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cWWithClauseParserRuleCall_4_0 = (RuleCall)cWAssignment_4.eContents().get(0);
		
		//fromJoin:
		//  ((LEFT|RIGHT) OUTER?|FULL|INNER)? JOIN FETCH? fromClassOrOuterQueryPath w=withClause?
		//; 
		//
		//
		////## joinType:
		////##     ( ( 'left'|'right' 'outer'? ) | 'full' | 'inner' )? JOIN FETCH?;
		public ParserRule getRule() { return rule; }

		//((LEFT|RIGHT) OUTER?|FULL|INNER)? JOIN FETCH? fromClassOrOuterQueryPath w=withClause?
		public Group getGroup() { return cGroup; }

		//((LEFT|RIGHT) OUTER?|FULL|INNER)?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//(LEFT|RIGHT) OUTER?
		public Group getGroup_0_0() { return cGroup_0_0; }

		//LEFT|RIGHT
		public Alternatives getAlternatives_0_0_0() { return cAlternatives_0_0_0; }

		//LEFT
		public RuleCall getLEFTParserRuleCall_0_0_0_0() { return cLEFTParserRuleCall_0_0_0_0; }

		//RIGHT
		public RuleCall getRIGHTParserRuleCall_0_0_0_1() { return cRIGHTParserRuleCall_0_0_0_1; }

		//OUTER?
		public RuleCall getOUTERParserRuleCall_0_0_1() { return cOUTERParserRuleCall_0_0_1; }

		//FULL
		public RuleCall getFULLParserRuleCall_0_1() { return cFULLParserRuleCall_0_1; }

		//INNER
		public RuleCall getINNERParserRuleCall_0_2() { return cINNERParserRuleCall_0_2; }

		//JOIN
		public RuleCall getJOINParserRuleCall_1() { return cJOINParserRuleCall_1; }

		//FETCH?
		public RuleCall getFETCHParserRuleCall_2() { return cFETCHParserRuleCall_2; }

		//fromClassOrOuterQueryPath
		public RuleCall getFromClassOrOuterQueryPathParserRuleCall_3() { return cFromClassOrOuterQueryPathParserRuleCall_3; }

		//w=withClause?
		public Assignment getWAssignment_4() { return cWAssignment_4; }

		//withClause
		public RuleCall getWWithClauseParserRuleCall_4_0() { return cWWithClauseParserRuleCall_4_0; }
	}

	public class WithClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "withClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cWITHParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		
		//withClause:
		//  WITH e=expression;
		public ParserRule getRule() { return rule; }

		//WITH e=expression
		public Group getGroup() { return cGroup; }

		//WITH
		public RuleCall getWITHParserRuleCall_0() { return cWITHParserRuleCall_0; }

		//e=expression
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }
	}

	public class FromRangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fromRange");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFromClassOrOuterQueryPathParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cAliasAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cAliasIdentifierParserRuleCall_1_0_0 = (RuleCall)cAliasAssignment_1_0.eContents().get(0);
		private final RuleCall cIN_CLASSParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cPAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cPPathParserRuleCall_1_2_0 = (RuleCall)cPAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cINParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cPAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cPPathParserRuleCall_2_2_0 = (RuleCall)cPAssignment_2_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Assignment cAliasAssignment_2_4 = (Assignment)cGroup_2.eContents().get(4);
		private final RuleCall cAliasIdentifierParserRuleCall_2_4_0 = (RuleCall)cAliasAssignment_2_4.eContents().get(0);
		private final RuleCall cInCollectionElementsDeclarationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//fromRange:
		//  fromClassOrOuterQueryPath|alias=identifier IN_CLASS p=path|IN "(" p=path ")" alias=
		//  identifier|inCollectionElementsDeclaration;
		public ParserRule getRule() { return rule; }

		//fromClassOrOuterQueryPath|alias=identifier IN_CLASS p=path|IN "(" p=path ")" alias=
		//identifier|inCollectionElementsDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//fromClassOrOuterQueryPath
		public RuleCall getFromClassOrOuterQueryPathParserRuleCall_0() { return cFromClassOrOuterQueryPathParserRuleCall_0; }

		//alias=identifier IN_CLASS p=path
		public Group getGroup_1() { return cGroup_1; }

		//alias=identifier
		public Assignment getAliasAssignment_1_0() { return cAliasAssignment_1_0; }

		//identifier
		public RuleCall getAliasIdentifierParserRuleCall_1_0_0() { return cAliasIdentifierParserRuleCall_1_0_0; }

		//IN_CLASS
		public RuleCall getIN_CLASSParserRuleCall_1_1() { return cIN_CLASSParserRuleCall_1_1; }

		//p=path
		public Assignment getPAssignment_1_2() { return cPAssignment_1_2; }

		//path
		public RuleCall getPPathParserRuleCall_1_2_0() { return cPPathParserRuleCall_1_2_0; }

		//IN "(" p=path ")" alias=identifier
		public Group getGroup_2() { return cGroup_2; }

		//IN
		public RuleCall getINParserRuleCall_2_0() { return cINParserRuleCall_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_1() { return cLeftParenthesisKeyword_2_1; }

		//p=path
		public Assignment getPAssignment_2_2() { return cPAssignment_2_2; }

		//path
		public RuleCall getPPathParserRuleCall_2_2_0() { return cPPathParserRuleCall_2_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_3() { return cRightParenthesisKeyword_2_3; }

		//alias=identifier
		public Assignment getAliasAssignment_2_4() { return cAliasAssignment_2_4; }

		//identifier
		public RuleCall getAliasIdentifierParserRuleCall_2_4_0() { return cAliasIdentifierParserRuleCall_2_4_0; }

		//inCollectionElementsDeclaration
		public RuleCall getInCollectionElementsDeclarationParserRuleCall_3() { return cInCollectionElementsDeclarationParserRuleCall_3; }
	}

	public class FromClassOrOuterQueryPathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fromClassOrOuterQueryPath");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFromClassOrOuterQueryPathAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cPathParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cAsAliasAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAsAliasAsAliasParserRuleCall_2_0 = (RuleCall)cAsAliasAssignment_2.eContents().get(0);
		private final Assignment cPropertyFetchAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPropertyFetchPropertyFetchParserRuleCall_3_0 = (RuleCall)cPropertyFetchAssignment_3.eContents().get(0);
		
		//fromClassOrOuterQueryPath:
		//  {fromClassOrOuterQueryPath} path asAlias=asAlias? propertyFetch=propertyFetch?;
		public ParserRule getRule() { return rule; }

		//{fromClassOrOuterQueryPath} path asAlias=asAlias? propertyFetch=propertyFetch?
		public Group getGroup() { return cGroup; }

		//{fromClassOrOuterQueryPath}
		public Action getFromClassOrOuterQueryPathAction_0() { return cFromClassOrOuterQueryPathAction_0; }

		//path
		public RuleCall getPathParserRuleCall_1() { return cPathParserRuleCall_1; }

		//asAlias=asAlias?
		public Assignment getAsAliasAssignment_2() { return cAsAliasAssignment_2; }

		//asAlias
		public RuleCall getAsAliasAsAliasParserRuleCall_2_0() { return cAsAliasAsAliasParserRuleCall_2_0; }

		//propertyFetch=propertyFetch?
		public Assignment getPropertyFetchAssignment_3() { return cPropertyFetchAssignment_3; }

		//propertyFetch
		public RuleCall getPropertyFetchPropertyFetchParserRuleCall_3_0() { return cPropertyFetchPropertyFetchParserRuleCall_3_0; }
	}

	public class InCollectionElementsDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "inCollectionElementsDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAliasAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAliasIdentifierParserRuleCall_0_0 = (RuleCall)cAliasAssignment_0.eContents().get(0);
		private final RuleCall cIN_ELEMENTSParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPPathParserRuleCall_3_0 = (RuleCall)cPAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//inCollectionElementsDeclaration:
		//  alias=identifier IN_ELEMENTS "(" p=path ")"; 
		//
		//
		//	           
		//    
		//
		//// Alias rule - Parses the optional 'as' token and forces an AST identifier node.
		public ParserRule getRule() { return rule; }

		//alias=identifier IN_ELEMENTS "(" p=path ")"
		public Group getGroup() { return cGroup; }

		//alias=identifier
		public Assignment getAliasAssignment_0() { return cAliasAssignment_0; }

		//identifier
		public RuleCall getAliasIdentifierParserRuleCall_0_0() { return cAliasIdentifierParserRuleCall_0_0; }

		//IN_ELEMENTS
		public RuleCall getIN_ELEMENTSParserRuleCall_1() { return cIN_ELEMENTSParserRuleCall_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//p=path
		public Assignment getPAssignment_3() { return cPAssignment_3; }

		//path
		public RuleCall getPPathParserRuleCall_3_0() { return cPPathParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class AsAliasElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "asAlias");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cASParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cAliasAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAliasIdentifierParserRuleCall_1_0 = (RuleCall)cAliasAssignment_1.eContents().get(0);
		
		//asAlias:
		//  AS? alias=identifier; 
		//
		//// Alias rule - Parses the optional 'as' token and forces an AST identifier node.
		public ParserRule getRule() { return rule; }

		//AS? alias=identifier
		public Group getGroup() { return cGroup; }

		//AS?
		public RuleCall getASParserRuleCall_0() { return cASParserRuleCall_0; }

		//alias=identifier
		public Assignment getAliasAssignment_1() { return cAliasAssignment_1; }

		//identifier
		public RuleCall getAliasIdentifierParserRuleCall_1_0() { return cAliasIdentifierParserRuleCall_1_0; }
	}

	public class PropertyFetchElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "propertyFetch");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFETCHParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cALLParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cPROPERTIESParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//propertyFetch returns ecore::EString:
		//  FETCH ALL PROPERTIES; 
		//    
		//
		//	      
		//	
		//
		////## groupByClause:
		////##     GROUP_BY path ( ',' path )*;
		public ParserRule getRule() { return rule; }

		//FETCH ALL PROPERTIES
		public Group getGroup() { return cGroup; }

		//FETCH
		public RuleCall getFETCHParserRuleCall_0() { return cFETCHParserRuleCall_0; }

		//ALL
		public RuleCall getALLParserRuleCall_1() { return cALLParserRuleCall_1; }

		//PROPERTIES
		public RuleCall getPROPERTIESParserRuleCall_2() { return cPROPERTIESParserRuleCall_2; }
	}

	public class GroupByClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "groupByClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cGROUP_BYParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cEAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_2_1_0 = (RuleCall)cEAssignment_2_1.eContents().get(0);
		private final Assignment cHAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cHHavingClauseParserRuleCall_3_0 = (RuleCall)cHAssignment_3.eContents().get(0);
		
		//groupByClause:
		//  GROUP_BY e+=expression ("," e+=expression)* h=havingClause?; 
		//
		////## groupByClause:
		////##     GROUP_BY path ( ',' path )*;
		//
		//
		//	            
		//		
		//	
		//
		////## orderByClause:
		////##     ORDER_BY selectedPropertiesList;
		public ParserRule getRule() { return rule; }

		//GROUP_BY e+=expression ("," e+=expression)* h=havingClause?
		public Group getGroup() { return cGroup; }

		//GROUP_BY
		public RuleCall getGROUP_BYParserRuleCall_0() { return cGROUP_BYParserRuleCall_0; }

		//e+=expression
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }

		//("," e+=expression)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//e+=expression
		public Assignment getEAssignment_2_1() { return cEAssignment_2_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_2_1_0() { return cEExpressionParserRuleCall_2_1_0; }

		//h=havingClause?
		public Assignment getHAssignment_3() { return cHAssignment_3; }

		//havingClause
		public RuleCall getHHavingClauseParserRuleCall_3_0() { return cHHavingClauseParserRuleCall_3_0; }
	}

	public class OrderByClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "orderByClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cORDER_BYParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cOAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOOrderElementParserRuleCall_1_0 = (RuleCall)cOAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cOAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOOrderElementParserRuleCall_2_1_0 = (RuleCall)cOAssignment_2_1.eContents().get(0);
		
		//orderByClause:
		//  ORDER_BY o+=orderElement ("," o+=orderElement)*; 
		//
		////## orderByClause:
		////##     ORDER_BY selectedPropertiesList;
		public ParserRule getRule() { return rule; }

		//ORDER_BY o+=orderElement ("," o+=orderElement)*
		public Group getGroup() { return cGroup; }

		//ORDER_BY
		public RuleCall getORDER_BYParserRuleCall_0() { return cORDER_BYParserRuleCall_0; }

		//o+=orderElement
		public Assignment getOAssignment_1() { return cOAssignment_1; }

		//orderElement
		public RuleCall getOOrderElementParserRuleCall_1_0() { return cOOrderElementParserRuleCall_1_0; }

		//("," o+=orderElement)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//o+=orderElement
		public Assignment getOAssignment_2_1() { return cOAssignment_2_1; }

		//orderElement
		public RuleCall getOOrderElementParserRuleCall_2_1_0() { return cOOrderElementParserRuleCall_2_1_0; }
	}

	public class OrderElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "orderElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cAscendingOrDescendingParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//orderElement:
		//  expression ascendingOrDescending?;
		public ParserRule getRule() { return rule; }

		//expression ascendingOrDescending?
		public Group getGroup() { return cGroup; }

		//expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//ascendingOrDescending?
		public RuleCall getAscendingOrDescendingParserRuleCall_1() { return cAscendingOrDescendingParserRuleCall_1; }
	}

	public class AscendingOrDescendingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ascendingOrDescending");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cASCParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDESCParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ascendingOrDescending returns ecore::EString:
		//  ASC|DESC; 
		//
		//
		//	  	
		//	  	
		//	
		//
		////## havingClause:
		////##     HAVING logicalExpression;
		public ParserRule getRule() { return rule; }

		//ASC|DESC 
		//
		//
		//	  	
		//	  	
		//	
		//
		////## havingClause:
		////##     HAVING logicalExpression;
		public Alternatives getAlternatives() { return cAlternatives; }

		//ASC
		public RuleCall getASCParserRuleCall_0() { return cASCParserRuleCall_0; }

		//DESC
		public RuleCall getDESCParserRuleCall_1() { return cDESCParserRuleCall_1; }
	}

	public class HavingClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "havingClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cHAVINGParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		
		//havingClause:
		//  HAVING e=expression; 
		//
		////## havingClause:
		////##     HAVING logicalExpression;
		//
		//
		//	    
		//	
		//
		////## whereClause:
		////##     WHERE logicalExpression;
		public ParserRule getRule() { return rule; }

		//HAVING e=expression
		public Group getGroup() { return cGroup; }

		//HAVING
		public RuleCall getHAVINGParserRuleCall_0() { return cHAVINGParserRuleCall_0; }

		//e=expression
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }
	}

	public class WhereClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "whereClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cWHEREParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		
		//whereClause:
		//  WHERE e=expression; 
		//
		////## whereClause:
		////##     WHERE logicalExpression;
		//
		//
		//	    
		//	
		//
		////## selectedPropertiesList:
		////##     ( path | aggregate ) ( ',' path | aggregate )*;
		public ParserRule getRule() { return rule; }

		//WHERE e=expression
		public Group getGroup() { return cGroup; }

		//WHERE
		public RuleCall getWHEREParserRuleCall_0() { return cWHEREParserRuleCall_0; }

		//e=expression
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }
	}

	public class SelectedPropertiesListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "selectedPropertiesList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAAliasedExpressionParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cAAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAAliasedExpressionParserRuleCall_1_1_0 = (RuleCall)cAAssignment_1_1.eContents().get(0);
		
		//selectedPropertiesList:
		//  a+=aliasedExpression ("," a+=aliasedExpression)*; 
		//
		////## selectedPropertiesList:
		////##     ( path | aggregate ) ( ',' path | aggregate )*;
		public ParserRule getRule() { return rule; }

		//a+=aliasedExpression ("," a+=aliasedExpression)*
		public Group getGroup() { return cGroup; }

		//a+=aliasedExpression
		public Assignment getAAssignment_0() { return cAAssignment_0; }

		//aliasedExpression
		public RuleCall getAAliasedExpressionParserRuleCall_0_0() { return cAAliasedExpressionParserRuleCall_0_0; }

		//("," a+=aliasedExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//a+=aliasedExpression
		public Assignment getAAssignment_1_1() { return cAAssignment_1_1; }

		//aliasedExpression
		public RuleCall getAAliasedExpressionParserRuleCall_1_1_0() { return cAAliasedExpressionParserRuleCall_1_1_0; }
	}

	public class AliasedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "aliasedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cASParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cIdAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIdIdentifierParserRuleCall_1_1_0 = (RuleCall)cIdAssignment_1_1.eContents().get(0);
		
		//aliasedExpression:
		//  expression (AS id=identifier)?; 
		//	
		//
		//	          
		//	
		//
		//// expressions
		//// Note that most of these expressions follow the pattern
		////   thisLevelExpression :
		////       nextHigherPrecedenceExpression
		////           (OPERATOR nextHigherPrecedenceExpression)*
		//// which is a standard recursive definition for a parsing an expression.
		////
		//// Operator precedence in HQL
		//// lowest  --> ( 7)  OR
		////             ( 6)  AND, NOT
		////             ( 5)  equality: ==, <>, =, is
		////             ( 4)  relational: <, <=, >, >=,
		////                   LIKE, NOT LIKE, BETWEEN, NOT BETWEEN, IN, NOT IN
		////             ( 3)  addition and subtraction: +(binary) -(binary)
		////             ( 2)  multiplication: * / %, concatenate: ||
		//// highest --> ( 1)  +(unary) -(unary)
		////                   []   () (method call)  . (dot -- identifier qualification)
		////                   aggregate function
		////                   ()  (explicit parenthesis)
		////
		//// Note that the above precedence levels map to the rules below...
		//// Once you have a precedence chart, writing the appropriate rules as below
		//// is usually very straightfoward
		//
		//// Main expression rule
		public ParserRule getRule() { return rule; }

		//expression (AS id=identifier)?
		public Group getGroup() { return cGroup; }

		//expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//(AS id=identifier)?
		public Group getGroup_1() { return cGroup_1; }

		//AS
		public RuleCall getASParserRuleCall_1_0() { return cASParserRuleCall_1_0; }

		//id=identifier
		public Assignment getIdAssignment_1_1() { return cIdAssignment_1_1; }

		//identifier
		public RuleCall getIdIdentifierParserRuleCall_1_1_0() { return cIdIdentifierParserRuleCall_1_1_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "expression");
		private final RuleCall cLogicalOrExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//expression:
		//  logicalOrExpression; 
		//
		//// expressions
		//// Note that most of these expressions follow the pattern
		////   thisLevelExpression :
		////       nextHigherPrecedenceExpression
		////           (OPERATOR nextHigherPrecedenceExpression)*
		//// which is a standard recursive definition for a parsing an expression.
		////
		//// Operator precedence in HQL
		//// lowest  --> ( 7)  OR
		////             ( 6)  AND, NOT
		////             ( 5)  equality: ==, <>, =, is
		////             ( 4)  relational: <, <=, >, >=,
		////                   LIKE, NOT LIKE, BETWEEN, NOT BETWEEN, IN, NOT IN
		////             ( 3)  addition and subtraction: +(binary) -(binary)
		////             ( 2)  multiplication: * / %, concatenate: ||
		//// highest --> ( 1)  +(unary) -(unary)
		////                   []   () (method call)  . (dot -- identifier qualification)
		////                   aggregate function
		////                   ()  (explicit parenthesis)
		////
		//// Note that the above precedence levels map to the rules below...
		//// Once you have a precedence chart, writing the appropriate rules as below
		//// is usually very straightfoward
		//
		//// Main expression rule
		//
		//	  
		//	
		//
		//// level 7 - OR
		public ParserRule getRule() { return rule; }

		//logicalOrExpression
		public RuleCall getLogicalOrExpressionParserRuleCall() { return cLogicalOrExpressionParserRuleCall; }
	}

	public class LogicalOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "logicalOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLLogicalAndExpressionParserRuleCall_0_0 = (RuleCall)cLAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cORParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cLAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cLLogicalAndExpressionParserRuleCall_1_1_0 = (RuleCall)cLAssignment_1_1.eContents().get(0);
		
		//logicalOrExpression:
		//  l+=logicalAndExpression (OR l+=logicalAndExpression)*; 
		//
		//// level 7 - OR
		//
		//	          
		//	
		//
		//// level 6 - AND, NOT
		public ParserRule getRule() { return rule; }

		//l+=logicalAndExpression (OR l+=logicalAndExpression)*
		public Group getGroup() { return cGroup; }

		//l+=logicalAndExpression
		public Assignment getLAssignment_0() { return cLAssignment_0; }

		//logicalAndExpression
		public RuleCall getLLogicalAndExpressionParserRuleCall_0_0() { return cLLogicalAndExpressionParserRuleCall_0_0; }

		//(OR l+=logicalAndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//OR
		public RuleCall getORParserRuleCall_1_0() { return cORParserRuleCall_1_0; }

		//l+=logicalAndExpression
		public Assignment getLAssignment_1_1() { return cLAssignment_1_1; }

		//logicalAndExpression
		public RuleCall getLLogicalAndExpressionParserRuleCall_1_1_0() { return cLLogicalAndExpressionParserRuleCall_1_1_0; }
	}

	public class LogicalAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "logicalAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNNegatedExpressionParserRuleCall_0_0 = (RuleCall)cNAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cANDParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cNAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNNegatedExpressionParserRuleCall_1_1_0 = (RuleCall)cNAssignment_1_1.eContents().get(0);
		
		//logicalAndExpression:
		//  n+=negatedExpression (AND n+=negatedExpression)*; 
		//
		//// level 6 - AND, NOT
		//
		//	          
		//	
		//
		//// NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
		//// negated, if possible.   Expressions without a NOT parent are passed through.
		public ParserRule getRule() { return rule; }

		//n+=negatedExpression (AND n+=negatedExpression)*
		public Group getGroup() { return cGroup; }

		//n+=negatedExpression
		public Assignment getNAssignment_0() { return cNAssignment_0; }

		//negatedExpression
		public RuleCall getNNegatedExpressionParserRuleCall_0_0() { return cNNegatedExpressionParserRuleCall_0_0; }

		//(AND n+=negatedExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//AND
		public RuleCall getANDParserRuleCall_1_0() { return cANDParserRuleCall_1_0; }

		//n+=negatedExpression
		public Assignment getNAssignment_1_1() { return cNAssignment_1_1; }

		//negatedExpression
		public RuleCall getNNegatedExpressionParserRuleCall_1_1_0() { return cNNegatedExpressionParserRuleCall_1_1_0; }
	}

	public class NegatedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "negatedExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cNOTParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Assignment cNAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNNegatedExpressionParserRuleCall_0_1_0 = (RuleCall)cNAssignment_0_1.eContents().get(0);
		private final RuleCall cEqualityExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//negatedExpression:
		//  NOT n=negatedExpression|equalityExpression; 
		//
		//// NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
		//// negated, if possible.   Expressions without a NOT parent are passed through.
		//
		// // Weak keywords can appear in an expression, so look ahead.
		//	      
		//	   
		//	
		//
		////## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
		//
		//// level 5 - EQ, NE
		public ParserRule getRule() { return rule; }

		//NOT n=negatedExpression|equalityExpression 
		//
		//// NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
		//// negated, if possible.   Expressions without a NOT parent are passed through.
		//
		// // Weak keywords can appear in an expression, so look ahead.
		//	      
		//	   
		//	
		//
		////## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
		//
		//// level 5 - EQ, NE
		public Alternatives getAlternatives() { return cAlternatives; }

		//NOT n=negatedExpression
		public Group getGroup_0() { return cGroup_0; }

		//NOT
		public RuleCall getNOTParserRuleCall_0_0() { return cNOTParserRuleCall_0_0; }

		//n=negatedExpression
		public Assignment getNAssignment_0_1() { return cNAssignment_0_1; }

		//negatedExpression
		public RuleCall getNNegatedExpressionParserRuleCall_0_1_0() { return cNNegatedExpressionParserRuleCall_0_1_0; }

		//equalityExpression
		public RuleCall getEqualityExpressionParserRuleCall_1() { return cEqualityExpressionParserRuleCall_1; }
	}

	public class EqualityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "equalityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRRelationalExpressionParserRuleCall_0_0 = (RuleCall)cRAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final RuleCall cISParserRuleCall_1_0_1_0 = (RuleCall)cGroup_1_0_1.eContents().get(0);
		private final RuleCall cNOTParserRuleCall_1_0_1_1 = (RuleCall)cGroup_1_0_1.eContents().get(1);
		private final Keyword cExclamationMarkEqualsSignKeyword_1_0_2 = (Keyword)cAlternatives_1_0.eContents().get(2);
		private final Keyword cLessThanSignGreaterThanSignKeyword_1_0_3 = (Keyword)cAlternatives_1_0.eContents().get(3);
		private final Assignment cRAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRRelationalExpressionParserRuleCall_1_1_0 = (RuleCall)cRAssignment_1_1.eContents().get(0);
		
		//equalityExpression:
		//  r+=relationalExpression (("="|IS NOT?|"!="|"<>") r+=relationalExpression)*; 
		//
		////## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
		//
		//// level 5 - EQ, NE
		//
		//	    
		//		  
		//		  	     
		//		  
		//		  	
		//		   
		//	
		//
		//// level 4 - LT, GT, LE, GE, LIKE, NOT LIKE, BETWEEN, NOT BETWEEN
		//// NOTE: The NOT prefix for LIKE and BETWEEN will be represented in the
		//// token type.  When traversing the AST, use the token type, and not the
		//// token text to interpret the semantics of these nodes.
		public ParserRule getRule() { return rule; }

		//r+=relationalExpression (("="|IS NOT?|"!="|"<>") r+=relationalExpression)*
		public Group getGroup() { return cGroup; }

		//r+=relationalExpression
		public Assignment getRAssignment_0() { return cRAssignment_0; }

		//relationalExpression
		public RuleCall getRRelationalExpressionParserRuleCall_0_0() { return cRRelationalExpressionParserRuleCall_0_0; }

		//(("="|IS NOT?|"!="|"<>") r+=relationalExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//"="|IS NOT?|"!="|"<>"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_0_0() { return cEqualsSignKeyword_1_0_0; }

		//IS NOT?
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//IS
		public RuleCall getISParserRuleCall_1_0_1_0() { return cISParserRuleCall_1_0_1_0; }

		//NOT?
		public RuleCall getNOTParserRuleCall_1_0_1_1() { return cNOTParserRuleCall_1_0_1_1; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_1_0_2() { return cExclamationMarkEqualsSignKeyword_1_0_2; }

		//"<>"
		public Keyword getLessThanSignGreaterThanSignKeyword_1_0_3() { return cLessThanSignGreaterThanSignKeyword_1_0_3; }

		//r+=relationalExpression
		public Assignment getRAssignment_1_1() { return cRAssignment_1_1; }

		//relationalExpression
		public RuleCall getRRelationalExpressionParserRuleCall_1_1_0() { return cRRelationalExpressionParserRuleCall_1_1_0; }
	}

	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "relationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cConcatenationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_0 = (Alternatives)cGroup_1_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_0_0_0 = (Keyword)cAlternatives_1_0_0.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_0_0_1 = (Keyword)cAlternatives_1_0_0.eContents().get(1);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_0_2 = (Keyword)cAlternatives_1_0_0.eContents().get(2);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_0_0_3 = (Keyword)cAlternatives_1_0_0.eContents().get(3);
		private final Assignment cAAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cAAdditiveExpressionParserRuleCall_1_0_1_0 = (RuleCall)cAAssignment_1_0_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final RuleCall cNOTParserRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1_1 = (Alternatives)cGroup_1_1.eContents().get(1);
		private final Group cGroup_1_1_1_0 = (Group)cAlternatives_1_1_1.eContents().get(0);
		private final RuleCall cINParserRuleCall_1_1_1_0_0 = (RuleCall)cGroup_1_1_1_0.eContents().get(0);
		private final Assignment cIAssignment_1_1_1_0_1 = (Assignment)cGroup_1_1_1_0.eContents().get(1);
		private final RuleCall cICompoundExprParserRuleCall_1_1_1_0_1_0 = (RuleCall)cIAssignment_1_1_1_0_1.eContents().get(0);
		private final Group cGroup_1_1_1_1 = (Group)cAlternatives_1_1_1.eContents().get(1);
		private final RuleCall cBETWEENParserRuleCall_1_1_1_1_0 = (RuleCall)cGroup_1_1_1_1.eContents().get(0);
		private final Assignment cBAssignment_1_1_1_1_1 = (Assignment)cGroup_1_1_1_1.eContents().get(1);
		private final RuleCall cBBetweenListParserRuleCall_1_1_1_1_1_0 = (RuleCall)cBAssignment_1_1_1_1_1.eContents().get(0);
		private final Group cGroup_1_1_1_2 = (Group)cAlternatives_1_1_1.eContents().get(2);
		private final RuleCall cLIKEParserRuleCall_1_1_1_2_0 = (RuleCall)cGroup_1_1_1_2.eContents().get(0);
		private final Assignment cCAssignment_1_1_1_2_1 = (Assignment)cGroup_1_1_1_2.eContents().get(1);
		private final RuleCall cCConcatenationParserRuleCall_1_1_1_2_1_0 = (RuleCall)cCAssignment_1_1_1_2_1.eContents().get(0);
		private final Assignment cLAssignment_1_1_1_2_2 = (Assignment)cGroup_1_1_1_2.eContents().get(2);
		private final RuleCall cLLikeEscapeParserRuleCall_1_1_1_2_2_0 = (RuleCall)cLAssignment_1_1_1_2_2.eContents().get(0);
		private final Group cGroup_1_1_1_3 = (Group)cAlternatives_1_1_1.eContents().get(3);
		private final RuleCall cMEMBERParserRuleCall_1_1_1_3_0 = (RuleCall)cGroup_1_1_1_3.eContents().get(0);
		private final RuleCall cOFParserRuleCall_1_1_1_3_1 = (RuleCall)cGroup_1_1_1_3.eContents().get(1);
		private final Assignment cPAssignment_1_1_1_3_2 = (Assignment)cGroup_1_1_1_3.eContents().get(2);
		private final RuleCall cPPathParserRuleCall_1_1_1_3_2_0 = (RuleCall)cPAssignment_1_1_1_3_2.eContents().get(0);
		
		//relationalExpression:
		//  concatenation ((("<"|">"|"<="|">=") a+=additiveExpression)*|NOT? (IN i=compoundExpr|
		//  BETWEEN b=betweenList|LIKE c=concatenation l=likeEscape|MEMBER OF? p=path)); 
		//
		//// level 4 - LT, GT, LE, GE, LIKE, NOT LIKE, BETWEEN, NOT BETWEEN
		//// NOTE: The NOT prefix for LIKE and BETWEEN will be represented in the
		//// token type.  When traversing the AST, use the token type, and not the
		//// token text to interpret the semantics of these nodes.
		//
		//	    
		//		                          
		//		// Disable node production for the optional 'not'.
		//		     
		//			// Represent the optional NOT prefix using the token type by
		//			 // testing 'n' and setting the token type accordingly.
		public ParserRule getRule() { return rule; }

		//concatenation ((("<"|">"|"<="|">=") a+=additiveExpression)*|NOT? (IN i=compoundExpr|
		//BETWEEN b=betweenList|LIKE c=concatenation l=likeEscape|MEMBER OF? p=path))     
		//		                          
		//		// Disable node production for the optional 'not'.
		//		     
		//			// Represent the optional NOT prefix using the token type by
		//			 // testing 'n' and setting the token type accordingly.
		public Group getGroup() { return cGroup; }

		//concatenation
		public RuleCall getConcatenationParserRuleCall_0() { return cConcatenationParserRuleCall_0; }

		//(("<"|">"|"<="|">=") a+=additiveExpression)*|NOT? (IN i=compoundExpr|BETWEEN b=
		//betweenList|LIKE c=concatenation l=likeEscape|MEMBER OF? p=path)   
		//		                          
		//		// Disable node production for the optional 'not'.
		//		     
		//			// Represent the optional NOT prefix using the token type by
		//			 // testing 'n' and setting the token type accordingly.
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//(("<"|">"|"<="|">=") a+=additiveExpression)*
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"<"|">"|"<="|">="
		public Alternatives getAlternatives_1_0_0() { return cAlternatives_1_0_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0_0_0() { return cLessThanSignKeyword_1_0_0_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_0_0_1() { return cGreaterThanSignKeyword_1_0_0_1; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_0_2() { return cLessThanSignEqualsSignKeyword_1_0_0_2; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_0_0_3() { return cGreaterThanSignEqualsSignKeyword_1_0_0_3; }

		//a+=additiveExpression
		public Assignment getAAssignment_1_0_1() { return cAAssignment_1_0_1; }

		//additiveExpression
		public RuleCall getAAdditiveExpressionParserRuleCall_1_0_1_0() { return cAAdditiveExpressionParserRuleCall_1_0_1_0; }

		//NOT? (IN i=compoundExpr|BETWEEN b=betweenList|LIKE c=concatenation l=likeEscape|
		//MEMBER OF? p=path)     
		//			// Represent the optional NOT prefix using the token type by
		//			 // testing 'n' and setting the token type accordingly.
		public Group getGroup_1_1() { return cGroup_1_1; }

		//NOT?
		public RuleCall getNOTParserRuleCall_1_1_0() { return cNOTParserRuleCall_1_1_0; }

		//IN i=compoundExpr|BETWEEN b=betweenList|LIKE c=concatenation l=likeEscape|MEMBER OF? p
		//=path   
		//			// Represent the optional NOT prefix using the token type by
		//			 // testing 'n' and setting the token type accordingly.
		public Alternatives getAlternatives_1_1_1() { return cAlternatives_1_1_1; }

		//IN i=compoundExpr
		public Group getGroup_1_1_1_0() { return cGroup_1_1_1_0; }

		//IN
		public RuleCall getINParserRuleCall_1_1_1_0_0() { return cINParserRuleCall_1_1_1_0_0; }

		//i=compoundExpr
		public Assignment getIAssignment_1_1_1_0_1() { return cIAssignment_1_1_1_0_1; }

		//compoundExpr
		public RuleCall getICompoundExprParserRuleCall_1_1_1_0_1_0() { return cICompoundExprParserRuleCall_1_1_1_0_1_0; }

		//BETWEEN b=betweenList
		public Group getGroup_1_1_1_1() { return cGroup_1_1_1_1; }

		//BETWEEN
		public RuleCall getBETWEENParserRuleCall_1_1_1_1_0() { return cBETWEENParserRuleCall_1_1_1_1_0; }

		//b=betweenList
		public Assignment getBAssignment_1_1_1_1_1() { return cBAssignment_1_1_1_1_1; }

		//betweenList
		public RuleCall getBBetweenListParserRuleCall_1_1_1_1_1_0() { return cBBetweenListParserRuleCall_1_1_1_1_1_0; }

		//LIKE c=concatenation l=likeEscape
		public Group getGroup_1_1_1_2() { return cGroup_1_1_1_2; }

		//LIKE
		public RuleCall getLIKEParserRuleCall_1_1_1_2_0() { return cLIKEParserRuleCall_1_1_1_2_0; }

		//c=concatenation
		public Assignment getCAssignment_1_1_1_2_1() { return cCAssignment_1_1_1_2_1; }

		//concatenation
		public RuleCall getCConcatenationParserRuleCall_1_1_1_2_1_0() { return cCConcatenationParserRuleCall_1_1_1_2_1_0; }

		//l=likeEscape
		public Assignment getLAssignment_1_1_1_2_2() { return cLAssignment_1_1_1_2_2; }

		//likeEscape
		public RuleCall getLLikeEscapeParserRuleCall_1_1_1_2_2_0() { return cLLikeEscapeParserRuleCall_1_1_1_2_2_0; }

		//MEMBER OF? p=path
		public Group getGroup_1_1_1_3() { return cGroup_1_1_1_3; }

		//MEMBER
		public RuleCall getMEMBERParserRuleCall_1_1_1_3_0() { return cMEMBERParserRuleCall_1_1_1_3_0; }

		//OF?
		public RuleCall getOFParserRuleCall_1_1_1_3_1() { return cOFParserRuleCall_1_1_1_3_1; }

		//p=path
		public Assignment getPAssignment_1_1_1_3_2() { return cPAssignment_1_1_1_3_2; }

		//path
		public RuleCall getPPathParserRuleCall_1_1_1_3_2_0() { return cPPathParserRuleCall_1_1_1_3_2_0; }
	}

	public class LikeEscapeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "likeEscape");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLikeEscapeAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cESCAPEParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cCAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCConcatenationParserRuleCall_1_1_0 = (RuleCall)cCAssignment_1_1.eContents().get(0);
		
		//likeEscape:
		//  {likeEscape} (ESCAPE c=concatenation)?;
		public ParserRule getRule() { return rule; }

		//{likeEscape} (ESCAPE c=concatenation)?
		public Group getGroup() { return cGroup; }

		//{likeEscape}
		public Action getLikeEscapeAction_0() { return cLikeEscapeAction_0; }

		//(ESCAPE c=concatenation)?
		public Group getGroup_1() { return cGroup_1; }

		//ESCAPE
		public RuleCall getESCAPEParserRuleCall_1_0() { return cESCAPEParserRuleCall_1_0; }

		//c=concatenation
		public Assignment getCAssignment_1_1() { return cCAssignment_1_1; }

		//concatenation
		public RuleCall getCConcatenationParserRuleCall_1_1_0() { return cCConcatenationParserRuleCall_1_1_0; }
	}

	public class BetweenListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "betweenList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCConcatenationParserRuleCall_0_0 = (RuleCall)cCAssignment_0.eContents().get(0);
		private final RuleCall cANDParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cCAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCConcatenationParserRuleCall_2_0 = (RuleCall)cCAssignment_2.eContents().get(0);
		
		//betweenList:
		//  c+=concatenation AND c+=concatenation; 
		//
		//
		//	      
		//	
		//
		////level 4 - string concatenation
		public ParserRule getRule() { return rule; }

		//c+=concatenation AND c+=concatenation
		public Group getGroup() { return cGroup; }

		//c+=concatenation
		public Assignment getCAssignment_0() { return cCAssignment_0; }

		//concatenation
		public RuleCall getCConcatenationParserRuleCall_0_0() { return cCConcatenationParserRuleCall_0_0; }

		//AND
		public RuleCall getANDParserRuleCall_1() { return cANDParserRuleCall_1; }

		//c+=concatenation
		public Assignment getCAssignment_2() { return cCAssignment_2; }

		//concatenation
		public RuleCall getCConcatenationParserRuleCall_2_0() { return cCConcatenationParserRuleCall_2_0; }
	}

	public class ConcatenationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "concatenation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cVerticalLineVerticalLineKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cAAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cAAdditiveExpressionParserRuleCall_1_1_0 = (RuleCall)cAAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cVerticalLineVerticalLineKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cAAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cAAdditiveExpressionParserRuleCall_1_2_1_0 = (RuleCall)cAAssignment_1_2_1.eContents().get(0);
		
		//concatenation:
		//  additiveExpression ("||" a+=additiveExpression ("||" a+=additiveExpression)*)?; 
		//
		////level 4 - string concatenation
		//
		//	   
		//	    
		//	  
		//	         
		//	  
		//	
		//
		//// level 3 - binary plus and minus
		public ParserRule getRule() { return rule; }

		//additiveExpression ("||" a+=additiveExpression ("||" a+=additiveExpression)*)?
		public Group getGroup() { return cGroup; }

		//additiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }

		//("||" a+=additiveExpression ("||" a+=additiveExpression)*)?
		public Group getGroup_1() { return cGroup_1; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_0() { return cVerticalLineVerticalLineKeyword_1_0; }

		//a+=additiveExpression
		public Assignment getAAssignment_1_1() { return cAAssignment_1_1; }

		//additiveExpression
		public RuleCall getAAdditiveExpressionParserRuleCall_1_1_0() { return cAAdditiveExpressionParserRuleCall_1_1_0; }

		//("||" a+=additiveExpression)*
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_2_0() { return cVerticalLineVerticalLineKeyword_1_2_0; }

		//a+=additiveExpression
		public Assignment getAAssignment_1_2_1() { return cAAssignment_1_2_1; }

		//additiveExpression
		public RuleCall getAAdditiveExpressionParserRuleCall_1_2_1_0() { return cAAdditiveExpressionParserRuleCall_1_2_1_0; }
	}

	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "additiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cMMultiplyExpressionParserRuleCall_0_0 = (RuleCall)cMAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Assignment cMAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cMMultiplyExpressionParserRuleCall_1_1_0 = (RuleCall)cMAssignment_1_1.eContents().get(0);
		
		//additiveExpression:
		//  m+=multiplyExpression (("+"|"-") m+=multiplyExpression)*; 
		//
		//// level 3 - binary plus and minus
		//
		//	                  
		//	
		//
		//// level 2 - binary multiply and divide
		public ParserRule getRule() { return rule; }

		//m+=multiplyExpression (("+"|"-") m+=multiplyExpression)*
		public Group getGroup() { return cGroup; }

		//m+=multiplyExpression
		public Assignment getMAssignment_0() { return cMAssignment_0; }

		//multiplyExpression
		public RuleCall getMMultiplyExpressionParserRuleCall_0_0() { return cMMultiplyExpressionParserRuleCall_0_0; }

		//(("+"|"-") m+=multiplyExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//"+"|"-"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_0() { return cPlusSignKeyword_1_0_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0_1() { return cHyphenMinusKeyword_1_0_1; }

		//m+=multiplyExpression
		public Assignment getMAssignment_1_1() { return cMAssignment_1_1; }

		//multiplyExpression
		public RuleCall getMMultiplyExpressionParserRuleCall_1_1_0() { return cMMultiplyExpressionParserRuleCall_1_1_0; }
	}

	public class MultiplyExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "multiplyExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cUAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cUUnaryExpressionParserRuleCall_0_0 = (RuleCall)cUAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0 = (Keyword)cAlternatives_1_0.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1 = (Keyword)cAlternatives_1_0.eContents().get(1);
		private final Assignment cUAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUUnaryExpressionParserRuleCall_1_1_0 = (RuleCall)cUAssignment_1_1.eContents().get(0);
		
		//multiplyExpression:
		//  u+=unaryExpression (("*"|"/") u+=unaryExpression)*; 
		//
		//// level 2 - binary multiply and divide
		//
		//	                  
		//	
		//	
		//// level 1 - unary minus, unary plus, not
		public ParserRule getRule() { return rule; }

		//u+=unaryExpression (("*"|"/") u+=unaryExpression)*
		public Group getGroup() { return cGroup; }

		//u+=unaryExpression
		public Assignment getUAssignment_0() { return cUAssignment_0; }

		//unaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_0_0() { return cUUnaryExpressionParserRuleCall_0_0; }

		//(("*"|"/") u+=unaryExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//"*"|"/"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_0_0() { return cAsteriskKeyword_1_0_0; }

		//"/"
		public Keyword getSolidusKeyword_1_0_1() { return cSolidusKeyword_1_0_1; }

		//u+=unaryExpression
		public Assignment getUAssignment_1_1() { return cUAssignment_1_1; }

		//unaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_1_1_0() { return cUUnaryExpressionParserRuleCall_1_1_0; }
	}

	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "unaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cUAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cUUnaryExpressionParserRuleCall_0_1_0 = (RuleCall)cUAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cUAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUUnaryExpressionParserRuleCall_1_1_0 = (RuleCall)cUAssignment_1_1.eContents().get(0);
		private final RuleCall cCaseExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cQuantifiedExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cAtomParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//unaryExpression:
		//  "-" u=unaryExpression|"+" u=unaryExpression|caseExpression|quantifiedExpression|
		//  atom; 
		//	
		//// level 1 - unary minus, unary plus, not
		public ParserRule getRule() { return rule; }

		//"-" u=unaryExpression|"+" u=unaryExpression|caseExpression|quantifiedExpression|
		//atom 
		//	
		//// level 1 - unary minus, unary plus, not
		public Alternatives getAlternatives() { return cAlternatives; }

		//"-" u=unaryExpression
		public Group getGroup_0() { return cGroup_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_0_0() { return cHyphenMinusKeyword_0_0; }

		//u=unaryExpression
		public Assignment getUAssignment_0_1() { return cUAssignment_0_1; }

		//unaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_0_1_0() { return cUUnaryExpressionParserRuleCall_0_1_0; }

		//"+" u=unaryExpression
		public Group getGroup_1() { return cGroup_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_0() { return cPlusSignKeyword_1_0; }

		//u=unaryExpression
		public Assignment getUAssignment_1_1() { return cUAssignment_1_1; }

		//unaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_1_1_0() { return cUUnaryExpressionParserRuleCall_1_1_0; }

		//caseExpression
		public RuleCall getCaseExpressionParserRuleCall_2() { return cCaseExpressionParserRuleCall_2; }

		//quantifiedExpression
		public RuleCall getQuantifiedExpressionParserRuleCall_3() { return cQuantifiedExpressionParserRuleCall_3; }

		//atom
		public RuleCall getAtomParserRuleCall_4() { return cAtomParserRuleCall_4; }
	}

	public class CaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "caseExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cCASEParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Assignment cWAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cWWhenClauseParserRuleCall_0_1_0 = (RuleCall)cWAssignment_0_1.eContents().get(0);
		private final Assignment cEAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cEElseClauseParserRuleCall_0_2_0 = (RuleCall)cEAssignment_0_2.eContents().get(0);
		private final RuleCall cENDParserRuleCall_0_3 = (RuleCall)cGroup_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cCASEParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cUAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUUnaryExpressionParserRuleCall_1_1_0 = (RuleCall)cUAssignment_1_1.eContents().get(0);
		private final Assignment cAAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cAAltWhenClauseParserRuleCall_1_2_0 = (RuleCall)cAAssignment_1_2.eContents().get(0);
		private final Assignment cEAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cEElseClauseParserRuleCall_1_3_0 = (RuleCall)cEAssignment_1_3.eContents().get(0);
		private final RuleCall cENDParserRuleCall_1_4 = (RuleCall)cGroup_1.eContents().get(4);
		
		//caseExpression:
		//  CASE w+=whenClause+ e=elseClause? END|CASE u=unaryExpression a+=altWhenClause+ e=
		//  elseClause? END;
		public ParserRule getRule() { return rule; }

		//CASE w+=whenClause+ e=elseClause? END|CASE u=unaryExpression a+=altWhenClause+ e=
		//elseClause? END
		public Alternatives getAlternatives() { return cAlternatives; }

		//CASE w+=whenClause+ e=elseClause? END
		public Group getGroup_0() { return cGroup_0; }

		//CASE
		public RuleCall getCASEParserRuleCall_0_0() { return cCASEParserRuleCall_0_0; }

		//w+=whenClause+
		public Assignment getWAssignment_0_1() { return cWAssignment_0_1; }

		//whenClause
		public RuleCall getWWhenClauseParserRuleCall_0_1_0() { return cWWhenClauseParserRuleCall_0_1_0; }

		//e=elseClause?
		public Assignment getEAssignment_0_2() { return cEAssignment_0_2; }

		//elseClause
		public RuleCall getEElseClauseParserRuleCall_0_2_0() { return cEElseClauseParserRuleCall_0_2_0; }

		//END
		public RuleCall getENDParserRuleCall_0_3() { return cENDParserRuleCall_0_3; }

		//CASE u=unaryExpression a+=altWhenClause+ e=elseClause? END
		public Group getGroup_1() { return cGroup_1; }

		//CASE
		public RuleCall getCASEParserRuleCall_1_0() { return cCASEParserRuleCall_1_0; }

		//u=unaryExpression
		public Assignment getUAssignment_1_1() { return cUAssignment_1_1; }

		//unaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_1_1_0() { return cUUnaryExpressionParserRuleCall_1_1_0; }

		//a+=altWhenClause+
		public Assignment getAAssignment_1_2() { return cAAssignment_1_2; }

		//altWhenClause
		public RuleCall getAAltWhenClauseParserRuleCall_1_2_0() { return cAAltWhenClauseParserRuleCall_1_2_0; }

		//e=elseClause?
		public Assignment getEAssignment_1_3() { return cEAssignment_1_3; }

		//elseClause
		public RuleCall getEElseClauseParserRuleCall_1_3_0() { return cEElseClauseParserRuleCall_1_3_0; }

		//END
		public RuleCall getENDParserRuleCall_1_4() { return cENDParserRuleCall_1_4; }
	}

	public class WhenClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "whenClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cWHENParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cWhenExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWhenExprExpressionParserRuleCall_1_0 = (RuleCall)cWhenExprAssignment_1.eContents().get(0);
		private final RuleCall cTHENParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cThenExprAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenExprUnaryExpressionParserRuleCall_3_0 = (RuleCall)cThenExprAssignment_3.eContents().get(0);
		
		//whenClause:
		//  WHEN whenExpr=expression THEN thenExpr=unaryExpression;
		public ParserRule getRule() { return rule; }

		//WHEN whenExpr=expression THEN thenExpr=unaryExpression
		public Group getGroup() { return cGroup; }

		//WHEN
		public RuleCall getWHENParserRuleCall_0() { return cWHENParserRuleCall_0; }

		//whenExpr=expression
		public Assignment getWhenExprAssignment_1() { return cWhenExprAssignment_1; }

		//expression
		public RuleCall getWhenExprExpressionParserRuleCall_1_0() { return cWhenExprExpressionParserRuleCall_1_0; }

		//THEN
		public RuleCall getTHENParserRuleCall_2() { return cTHENParserRuleCall_2; }

		//thenExpr=unaryExpression
		public Assignment getThenExprAssignment_3() { return cThenExprAssignment_3; }

		//unaryExpression
		public RuleCall getThenExprUnaryExpressionParserRuleCall_3_0() { return cThenExprUnaryExpressionParserRuleCall_3_0; }
	}

	public class AltWhenClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "altWhenClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cWHENParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cWAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWUnaryExpressionParserRuleCall_1_0 = (RuleCall)cWAssignment_1.eContents().get(0);
		private final RuleCall cTHENParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cTAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTUnaryExpressionParserRuleCall_3_0 = (RuleCall)cTAssignment_3.eContents().get(0);
		
		//altWhenClause:
		//  WHEN w=unaryExpression THEN t=unaryExpression;
		public ParserRule getRule() { return rule; }

		//WHEN w=unaryExpression THEN t=unaryExpression
		public Group getGroup() { return cGroup; }

		//WHEN
		public RuleCall getWHENParserRuleCall_0() { return cWHENParserRuleCall_0; }

		//w=unaryExpression
		public Assignment getWAssignment_1() { return cWAssignment_1; }

		//unaryExpression
		public RuleCall getWUnaryExpressionParserRuleCall_1_0() { return cWUnaryExpressionParserRuleCall_1_0; }

		//THEN
		public RuleCall getTHENParserRuleCall_2() { return cTHENParserRuleCall_2; }

		//t=unaryExpression
		public Assignment getTAssignment_3() { return cTAssignment_3; }

		//unaryExpression
		public RuleCall getTUnaryExpressionParserRuleCall_3_0() { return cTUnaryExpressionParserRuleCall_3_0; }
	}

	public class ElseClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "elseClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cELSEParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cUAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cUUnaryExpressionParserRuleCall_1_0 = (RuleCall)cUAssignment_1.eContents().get(0);
		
		//elseClause:
		//  ELSE u=unaryExpression;
		public ParserRule getRule() { return rule; }

		//ELSE u=unaryExpression
		public Group getGroup() { return cGroup; }

		//ELSE
		public RuleCall getELSEParserRuleCall_0() { return cELSEParserRuleCall_0; }

		//u=unaryExpression
		public Assignment getUAssignment_1() { return cUAssignment_1; }

		//unaryExpression
		public RuleCall getUUnaryExpressionParserRuleCall_1_0() { return cUUnaryExpressionParserRuleCall_1_0; }
	}

	public class QuantifiedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "quantifiedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cQuantifiedExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cSOMEParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cEXISTSParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final RuleCall cALLParserRuleCall_1_2 = (RuleCall)cAlternatives_1.eContents().get(2);
		private final RuleCall cANYParserRuleCall_1_3 = (RuleCall)cAlternatives_1.eContents().get(3);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final RuleCall cIdentifierParserRuleCall_2_0 = (RuleCall)cAlternatives_2.eContents().get(0);
		private final RuleCall cCollectionExprParserRuleCall_2_1 = (RuleCall)cAlternatives_2.eContents().get(1);
		private final Group cGroup_2_2 = (Group)cAlternatives_2.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cSAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cSUnionRuleParserRuleCall_2_2_1_0 = (RuleCall)cSAssignment_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2_2 = (Keyword)cGroup_2_2.eContents().get(2);
		
		//quantifiedExpression:
		//  {quantifiedExpression} (SOME|EXISTS|ALL|ANY) (identifier|collectionExpr|"(" s=
		//  unionRule ")"); 
		//	
		//
		//	                   
		//	                    
		//	
		//
		//// level 0 - expression atom
		//// ident qualifier ('.' ident ), array index ( [ expr ] ),
		//// method call ( '.' ident '(' exprList ') )
		public ParserRule getRule() { return rule; }

		//{quantifiedExpression} (SOME|EXISTS|ALL|ANY) (identifier|collectionExpr|"(" s=
		//unionRule ")")
		public Group getGroup() { return cGroup; }

		//{quantifiedExpression}
		public Action getQuantifiedExpressionAction_0() { return cQuantifiedExpressionAction_0; }

		//SOME|EXISTS|ALL|ANY
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//SOME
		public RuleCall getSOMEParserRuleCall_1_0() { return cSOMEParserRuleCall_1_0; }

		//EXISTS
		public RuleCall getEXISTSParserRuleCall_1_1() { return cEXISTSParserRuleCall_1_1; }

		//ALL
		public RuleCall getALLParserRuleCall_1_2() { return cALLParserRuleCall_1_2; }

		//ANY
		public RuleCall getANYParserRuleCall_1_3() { return cANYParserRuleCall_1_3; }

		//identifier|collectionExpr|"(" s=unionRule ")"
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//identifier
		public RuleCall getIdentifierParserRuleCall_2_0() { return cIdentifierParserRuleCall_2_0; }

		//collectionExpr
		public RuleCall getCollectionExprParserRuleCall_2_1() { return cCollectionExprParserRuleCall_2_1; }

		//"(" s=unionRule ")"
		public Group getGroup_2_2() { return cGroup_2_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_2_0() { return cLeftParenthesisKeyword_2_2_0; }

		//s=unionRule
		public Assignment getSAssignment_2_2_1() { return cSAssignment_2_2_1; }

		//unionRule
		public RuleCall getSUnionRuleParserRuleCall_2_2_1_0() { return cSUnionRuleParserRuleCall_2_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2_2() { return cRightParenthesisKeyword_2_2_2; }
	}

	public class AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "atom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_1_0_1 = (RuleCall)cGroup_1_0.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cGroup_1_0.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_1_0_2_0 = (Keyword)cGroup_1_0_2.eContents().get(0);
		private final Assignment cEAssignment_1_0_2_1 = (Assignment)cGroup_1_0_2.eContents().get(1);
		private final RuleCall cEExprListParserRuleCall_1_0_2_1_0 = (RuleCall)cEAssignment_1_0_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_0_2_2 = (Keyword)cGroup_1_0_2.eContents().get(2);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cExpAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cExpExpressionParserRuleCall_1_1_1_0 = (RuleCall)cExpAssignment_1_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_1_2 = (Keyword)cGroup_1_1.eContents().get(2);
		
		//atom:
		//  primaryExpression ("." identifier ("(" e+=exprList ")")?|"[" exp+=expression "]")*; 
		//
		//// level 0 - expression atom
		//// ident qualifier ('.' ident ), array index ( [ expr ] ),
		//// method call ( '.' ident '(' exprList ') )
		//
		//	   
		//			                
		//			     
		//		
		//	
		//
		//// level 0 - the basic element of an expression
		public ParserRule getRule() { return rule; }

		//primaryExpression ("." identifier ("(" e+=exprList ")")?|"[" exp+=expression "]")*
		public Group getGroup() { return cGroup; }

		//primaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//("." identifier ("(" e+=exprList ")")?|"[" exp+=expression "]")*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"." identifier ("(" e+=exprList ")")?
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"."
		public Keyword getFullStopKeyword_1_0_0() { return cFullStopKeyword_1_0_0; }

		//identifier
		public RuleCall getIdentifierParserRuleCall_1_0_1() { return cIdentifierParserRuleCall_1_0_1; }

		//("(" e+=exprList ")")?
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0_2_0() { return cLeftParenthesisKeyword_1_0_2_0; }

		//e+=exprList
		public Assignment getEAssignment_1_0_2_1() { return cEAssignment_1_0_2_1; }

		//exprList
		public RuleCall getEExprListParserRuleCall_1_0_2_1_0() { return cEExprListParserRuleCall_1_0_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_0_2_2() { return cRightParenthesisKeyword_1_0_2_2; }

		//"[" exp+=expression "]"
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1_0() { return cLeftSquareBracketKeyword_1_1_0; }

		//exp+=expression
		public Assignment getExpAssignment_1_1_1() { return cExpAssignment_1_1_1; }

		//expression
		public RuleCall getExpExpressionParserRuleCall_1_1_1_0() { return cExpExpressionParserRuleCall_1_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_1_2() { return cRightSquareBracketKeyword_1_1_2; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "primaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cPrimaryExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cIdentAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cIdentIdentPrimaryParserRuleCall_0_1_0 = (RuleCall)cIdentAssignment_0_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cFullStopKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final RuleCall cCLASSParserRuleCall_0_2_1 = (RuleCall)cGroup_0_2.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Alternatives cAlternatives_3_1 = (Alternatives)cGroup_3.eContents().get(1);
		private final RuleCall cExpressionOrVectorParserRuleCall_3_1_0 = (RuleCall)cAlternatives_3_1.eContents().get(0);
		private final Assignment cSAssignment_3_1_1 = (Assignment)cAlternatives_3_1.eContents().get(1);
		private final RuleCall cSUnionRuleParserRuleCall_3_1_1_0 = (RuleCall)cSAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cQuestionMarkKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		
		//primaryExpression:
		//  {primaryExpression} ident=identPrimary ("." CLASS)?|constant|":" identifier|"(" (
		//  expressionOrVector|s=unionRule) ")"|"?" INT?; 
		//
		//// level 0 - the basic element of an expression
		//
		//	            
		//	    
		//	      
		//	            
		//	      
		//	
		//
		//// This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
		//// a parent VECTOR_EXPR node will be created for the list.
		public ParserRule getRule() { return rule; }

		//{primaryExpression} ident=identPrimary ("." CLASS)?|constant|":" identifier|"(" (
		//expressionOrVector|s=unionRule) ")"|"?" INT? 
		//
		//// level 0 - the basic element of an expression
		//
		//	            
		//	    
		//	      
		//	            
		//	      
		//	
		//
		//// This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
		//// a parent VECTOR_EXPR node will be created for the list.
		public Alternatives getAlternatives() { return cAlternatives; }

		//{primaryExpression} ident=identPrimary ("." CLASS)?
		public Group getGroup_0() { return cGroup_0; }

		//{primaryExpression}
		public Action getPrimaryExpressionAction_0_0() { return cPrimaryExpressionAction_0_0; }

		//ident=identPrimary
		public Assignment getIdentAssignment_0_1() { return cIdentAssignment_0_1; }

		//identPrimary
		public RuleCall getIdentIdentPrimaryParserRuleCall_0_1_0() { return cIdentIdentPrimaryParserRuleCall_0_1_0; }

		//("." CLASS)?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"."
		public Keyword getFullStopKeyword_0_2_0() { return cFullStopKeyword_0_2_0; }

		//CLASS
		public RuleCall getCLASSParserRuleCall_0_2_1() { return cCLASSParserRuleCall_0_2_1; }

		//constant
		public RuleCall getConstantParserRuleCall_1() { return cConstantParserRuleCall_1; }

		//":" identifier
		public Group getGroup_2() { return cGroup_2; }

		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }

		//identifier
		public RuleCall getIdentifierParserRuleCall_2_1() { return cIdentifierParserRuleCall_2_1; }

		//"(" (expressionOrVector|s=unionRule) ")"
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//expressionOrVector|s=unionRule
		public Alternatives getAlternatives_3_1() { return cAlternatives_3_1; }

		//expressionOrVector
		public RuleCall getExpressionOrVectorParserRuleCall_3_1_0() { return cExpressionOrVectorParserRuleCall_3_1_0; }

		//s=unionRule
		public Assignment getSAssignment_3_1_1() { return cSAssignment_3_1_1; }

		//unionRule
		public RuleCall getSUnionRuleParserRuleCall_3_1_1_0() { return cSUnionRuleParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }

		//"?" INT?
		public Group getGroup_4() { return cGroup_4; }

		//"?"
		public Keyword getQuestionMarkKeyword_4_0() { return cQuestionMarkKeyword_4_0; }

		//INT?
		public RuleCall getINTTerminalRuleCall_4_1() { return cINTTerminalRuleCall_4_1; }
	}

	public class ExpressionOrVectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "expressionOrVector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cVAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVVectorExprParserRuleCall_1_0 = (RuleCall)cVAssignment_1.eContents().get(0);
		
		//expressionOrVector:
		//  expression v=vectorExpr?; 
		//
		//// This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
		//// a parent VECTOR_EXPR node will be created for the list.
		public ParserRule getRule() { return rule; }

		//expression v=vectorExpr?
		public Group getGroup() { return cGroup; }

		//expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }

		//v=vectorExpr?
		public Assignment getVAssignment_1() { return cVAssignment_1; }

		//vectorExpr
		public RuleCall getVVectorExprParserRuleCall_1_0() { return cVVectorExprParserRuleCall_1_0; }
	}

	public class VectorExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "vectorExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCommaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0 = (RuleCall)cEAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cEAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_2_1_0 = (RuleCall)cEAssignment_2_1.eContents().get(0);
		
		//vectorExpr:
		//  "," e+=expression ("," e+=expression)*; 
		//
		//
		//	        
		//	
		//
		//// identifier, followed by member refs (dot ident), or method calls.
		//// NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
		//// the method looks a head to find keywords after '.' and turns them into identifiers.
		public ParserRule getRule() { return rule; }

		//"," e+=expression ("," e+=expression)*
		public Group getGroup() { return cGroup; }

		//","
		public Keyword getCommaKeyword_0() { return cCommaKeyword_0; }

		//e+=expression
		public Assignment getEAssignment_1() { return cEAssignment_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_0() { return cEExpressionParserRuleCall_1_0; }

		//("," e+=expression)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//e+=expression
		public Assignment getEAssignment_2_1() { return cEAssignment_2_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_2_1_0() { return cEExpressionParserRuleCall_2_1_0; }
	}

	public class IdentPrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "identPrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIdentPrimaryAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Alternatives cAlternatives_0_2 = (Alternatives)cGroup_0.eContents().get(2);
		private final Group cGroup_0_2_0 = (Group)cAlternatives_0_2.eContents().get(0);
		private final Keyword cFullStopKeyword_0_2_0_0 = (Keyword)cGroup_0_2_0.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_0_2_0_1 = (RuleCall)cGroup_0_2_0.eContents().get(1);
		private final Group cGroup_0_2_1 = (Group)cAlternatives_0_2.eContents().get(1);
		private final Keyword cFullStopKeyword_0_2_1_0 = (Keyword)cGroup_0_2_1.eContents().get(0);
		private final RuleCall cELEMENTSParserRuleCall_0_2_1_1 = (RuleCall)cGroup_0_2_1.eContents().get(1);
		private final Group cGroup_0_2_2 = (Group)cAlternatives_0_2.eContents().get(2);
		private final Keyword cFullStopKeyword_0_2_2_0 = (Keyword)cGroup_0_2_2.eContents().get(0);
		private final RuleCall cOBJECTParserRuleCall_0_2_2_1 = (RuleCall)cGroup_0_2_2.eContents().get(1);
		private final Group cGroup_0_3 = (Group)cGroup_0.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_0_3_0 = (Keyword)cGroup_0_3.eContents().get(0);
		private final Assignment cEAssignment_0_3_1 = (Assignment)cGroup_0_3.eContents().get(1);
		private final RuleCall cEExprListParserRuleCall_0_3_1_0 = (RuleCall)cEAssignment_0_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_3_2 = (Keyword)cGroup_0_3.eContents().get(2);
		private final RuleCall cAggregateParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//identPrimary:
		//  {identPrimary} identifier ("." identifier|"." ELEMENTS|"." OBJECT)* ("(" e=exprList ")")
		//  ?|aggregate; 
		//
		//// identifier, followed by member refs (dot ident), or method calls.
		//// NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
		//// the method looks a head to find keywords after '.' and turns them into identifiers.
		//
		//	                           
		//		         
		//	 	 
		//	
		//
		////## aggregate:
		////##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
		//
		////## aggregateFunction:
		////##     COUNT | 'sum' | 'avg' | 'max' | 'min';
		public ParserRule getRule() { return rule; }

		//{identPrimary} identifier ("." identifier|"." ELEMENTS|"." OBJECT)* ("(" e=exprList ")")
		//?|aggregate 
		//
		//// identifier, followed by member refs (dot ident), or method calls.
		//// NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
		//// the method looks a head to find keywords after '.' and turns them into identifiers.
		//
		//	                           
		//		         
		//	 	 
		//	
		//
		////## aggregate:
		////##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
		//
		////## aggregateFunction:
		////##     COUNT | 'sum' | 'avg' | 'max' | 'min';
		public Alternatives getAlternatives() { return cAlternatives; }

		//{identPrimary} identifier ("." identifier|"." ELEMENTS|"." OBJECT)* ("(" e=exprList ")")
		//?
		public Group getGroup_0() { return cGroup_0; }

		//{identPrimary}
		public Action getIdentPrimaryAction_0_0() { return cIdentPrimaryAction_0_0; }

		//identifier
		public RuleCall getIdentifierParserRuleCall_0_1() { return cIdentifierParserRuleCall_0_1; }

		//("." identifier|"." ELEMENTS|"." OBJECT)*
		public Alternatives getAlternatives_0_2() { return cAlternatives_0_2; }

		//"." identifier
		public Group getGroup_0_2_0() { return cGroup_0_2_0; }

		//"."
		public Keyword getFullStopKeyword_0_2_0_0() { return cFullStopKeyword_0_2_0_0; }

		//identifier
		public RuleCall getIdentifierParserRuleCall_0_2_0_1() { return cIdentifierParserRuleCall_0_2_0_1; }

		//"." ELEMENTS
		public Group getGroup_0_2_1() { return cGroup_0_2_1; }

		//"."
		public Keyword getFullStopKeyword_0_2_1_0() { return cFullStopKeyword_0_2_1_0; }

		//ELEMENTS
		public RuleCall getELEMENTSParserRuleCall_0_2_1_1() { return cELEMENTSParserRuleCall_0_2_1_1; }

		//"." OBJECT
		public Group getGroup_0_2_2() { return cGroup_0_2_2; }

		//"."
		public Keyword getFullStopKeyword_0_2_2_0() { return cFullStopKeyword_0_2_2_0; }

		//OBJECT
		public RuleCall getOBJECTParserRuleCall_0_2_2_1() { return cOBJECTParserRuleCall_0_2_2_1; }

		//("(" e=exprList ")")?
		public Group getGroup_0_3() { return cGroup_0_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_3_0() { return cLeftParenthesisKeyword_0_3_0; }

		//e=exprList
		public Assignment getEAssignment_0_3_1() { return cEAssignment_0_3_1; }

		//exprList
		public RuleCall getEExprListParserRuleCall_0_3_1_0() { return cEExprListParserRuleCall_0_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_0_3_2() { return cRightParenthesisKeyword_0_3_2; }

		//aggregate
		public RuleCall getAggregateParserRuleCall_1() { return cAggregateParserRuleCall_1; }
	}

	public class AggregateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "aggregate");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cAggregateAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Alternatives cAlternatives_0_1 = (Alternatives)cGroup_0.eContents().get(1);
		private final RuleCall cSUMParserRuleCall_0_1_0 = (RuleCall)cAlternatives_0_1.eContents().get(0);
		private final RuleCall cAVGParserRuleCall_0_1_1 = (RuleCall)cAlternatives_0_1.eContents().get(1);
		private final RuleCall cMAXParserRuleCall_0_1_2 = (RuleCall)cAlternatives_0_1.eContents().get(2);
		private final RuleCall cMINParserRuleCall_0_1_3 = (RuleCall)cAlternatives_0_1.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cAAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cAAdditiveExpressionParserRuleCall_0_3_0 = (RuleCall)cAAssignment_0_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cCOUNTParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Alternatives cAlternatives_1_2 = (Alternatives)cGroup_1.eContents().get(2);
		private final Keyword cAsteriskKeyword_1_2_0 = (Keyword)cAlternatives_1_2.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cAlternatives_1_2.eContents().get(1);
		private final Alternatives cAlternatives_1_2_1_0 = (Alternatives)cGroup_1_2_1.eContents().get(0);
		private final RuleCall cDISTINCTParserRuleCall_1_2_1_0_0 = (RuleCall)cAlternatives_1_2_1_0.eContents().get(0);
		private final RuleCall cALLParserRuleCall_1_2_1_0_1 = (RuleCall)cAlternatives_1_2_1_0.eContents().get(1);
		private final Alternatives cAlternatives_1_2_1_1 = (Alternatives)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cPathParserRuleCall_1_2_1_1_0 = (RuleCall)cAlternatives_1_2_1_1.eContents().get(0);
		private final RuleCall cCollectionExprParserRuleCall_1_2_1_1_1 = (RuleCall)cAlternatives_1_2_1_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final RuleCall cCollectionExprParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//aggregate:
		//  {aggregate} (SUM|AVG|MAX|MIN) "(" a=additiveExpression ")"|COUNT "(" ("*"|(DISTINCT|
		//  ALL)? (path|collectionExpr)) ")"|collectionExpr; 
		//
		////## aggregate:
		////##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
		//
		////## aggregateFunction:
		////##     COUNT | 'sum' | 'avg' | 'max' | 'min';
		//
		//
		//	                           
		//	// Special case for count - It's 'parameters' can be keywords.
		//	                                         
		//	   
		//	
		//
		////## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN path CLOSE );
		public ParserRule getRule() { return rule; }

		//{aggregate} (SUM|AVG|MAX|MIN) "(" a=additiveExpression ")"|COUNT "(" ("*"|(DISTINCT|
		//ALL)? (path|collectionExpr)) ")"|collectionExpr 
		//
		////## aggregate:
		////##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
		//
		////## aggregateFunction:
		////##     COUNT | 'sum' | 'avg' | 'max' | 'min';
		//
		//
		//	                           
		//	// Special case for count - It's 'parameters' can be keywords.
		//	                                         
		//	   
		//	
		//
		////## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN path CLOSE );
		public Alternatives getAlternatives() { return cAlternatives; }

		//{aggregate} (SUM|AVG|MAX|MIN) "(" a=additiveExpression ")"                            
		//	// Special case for count - It's 'parameters' can be keywords.
		public Group getGroup_0() { return cGroup_0; }

		//{aggregate}
		public Action getAggregateAction_0_0() { return cAggregateAction_0_0; }

		//SUM|AVG|MAX|MIN
		public Alternatives getAlternatives_0_1() { return cAlternatives_0_1; }

		//SUM
		public RuleCall getSUMParserRuleCall_0_1_0() { return cSUMParserRuleCall_0_1_0; }

		//AVG
		public RuleCall getAVGParserRuleCall_0_1_1() { return cAVGParserRuleCall_0_1_1; }

		//MAX
		public RuleCall getMAXParserRuleCall_0_1_2() { return cMAXParserRuleCall_0_1_2; }

		//MIN
		public RuleCall getMINParserRuleCall_0_1_3() { return cMINParserRuleCall_0_1_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_2() { return cLeftParenthesisKeyword_0_2; }

		//a=additiveExpression
		public Assignment getAAssignment_0_3() { return cAAssignment_0_3; }

		//additiveExpression
		public RuleCall getAAdditiveExpressionParserRuleCall_0_3_0() { return cAAdditiveExpressionParserRuleCall_0_3_0; }

		//")"    
		//	// Special case for count - It's 'parameters' can be keywords.
		public Keyword getRightParenthesisKeyword_0_4() { return cRightParenthesisKeyword_0_4; }

		//COUNT "(" ("*"|(DISTINCT|ALL)? (path|collectionExpr)) ")"
		public Group getGroup_1() { return cGroup_1; }

		//COUNT
		public RuleCall getCOUNTParserRuleCall_1_0() { return cCOUNTParserRuleCall_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//"*"|(DISTINCT|ALL)? (path|collectionExpr)
		public Alternatives getAlternatives_1_2() { return cAlternatives_1_2; }

		//"*"
		public Keyword getAsteriskKeyword_1_2_0() { return cAsteriskKeyword_1_2_0; }

		//(DISTINCT|ALL)? (path|collectionExpr)
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//(DISTINCT|ALL)?
		public Alternatives getAlternatives_1_2_1_0() { return cAlternatives_1_2_1_0; }

		//DISTINCT
		public RuleCall getDISTINCTParserRuleCall_1_2_1_0_0() { return cDISTINCTParserRuleCall_1_2_1_0_0; }

		//ALL
		public RuleCall getALLParserRuleCall_1_2_1_0_1() { return cALLParserRuleCall_1_2_1_0_1; }

		//path|collectionExpr
		public Alternatives getAlternatives_1_2_1_1() { return cAlternatives_1_2_1_1; }

		//path
		public RuleCall getPathParserRuleCall_1_2_1_1_0() { return cPathParserRuleCall_1_2_1_1_0; }

		//collectionExpr
		public RuleCall getCollectionExprParserRuleCall_1_2_1_1_1() { return cCollectionExprParserRuleCall_1_2_1_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }

		//collectionExpr
		public RuleCall getCollectionExprParserRuleCall_2() { return cCollectionExprParserRuleCall_2; }
	}

	public class CollectionExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "collectionExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cELEMENTSParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cINDICESParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cPathParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//collectionExpr returns ecore::EString:
		//  (ELEMENTS|INDICES) "(" path ")"; 
		//
		////## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN path CLOSE );
		//
		//
		//	            
		//	
		//                                           
		//// NOTE: compoundExpr can be a 'path' where the last token in the path is '.elements' or '.indicies'
		public ParserRule getRule() { return rule; }

		//(ELEMENTS|INDICES) "(" path ")"
		public Group getGroup() { return cGroup; }

		//ELEMENTS|INDICES
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//ELEMENTS
		public RuleCall getELEMENTSParserRuleCall_0_0() { return cELEMENTSParserRuleCall_0_0; }

		//INDICES
		public RuleCall getINDICESParserRuleCall_0_1() { return cINDICESParserRuleCall_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//path
		public RuleCall getPathParserRuleCall_2() { return cPathParserRuleCall_2; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class CompoundExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "compoundExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCollectionExprParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPathParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Group cGroup_2_1_0 = (Group)cAlternatives_2_1.eContents().get(0);
		private final Assignment cEAssignment_2_1_0_0 = (Assignment)cGroup_2_1_0.eContents().get(0);
		private final RuleCall cEExpressionParserRuleCall_2_1_0_0_0 = (RuleCall)cEAssignment_2_1_0_0.eContents().get(0);
		private final Group cGroup_2_1_0_1 = (Group)cGroup_2_1_0.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0_1_0 = (Keyword)cGroup_2_1_0_1.eContents().get(0);
		private final Assignment cEAssignment_2_1_0_1_1 = (Assignment)cGroup_2_1_0_1.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_2_1_0_1_1_0 = (RuleCall)cEAssignment_2_1_0_1_1.eContents().get(0);
		private final Assignment cSAssignment_2_1_1 = (Assignment)cAlternatives_2_1.eContents().get(1);
		private final RuleCall cSUnionRuleParserRuleCall_2_1_1_0 = (RuleCall)cSAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//compoundExpr:
		//  collectionExpr|path|"(" (e+=expression ("," e+=expression)*|s=unionRule) ")"; 
		//                                           
		//// NOTE: compoundExpr can be a 'path' where the last token in the path is '.elements' or '.indicies'
		public ParserRule getRule() { return rule; }

		//collectionExpr|path|"(" (e+=expression ("," e+=expression)*|s=unionRule) ")" 
		//                                           
		//// NOTE: compoundExpr can be a 'path' where the last token in the path is '.elements' or '.indicies'
		public Alternatives getAlternatives() { return cAlternatives; }

		//collectionExpr
		public RuleCall getCollectionExprParserRuleCall_0() { return cCollectionExprParserRuleCall_0; }

		//path
		public RuleCall getPathParserRuleCall_1() { return cPathParserRuleCall_1; }

		//"(" (e+=expression ("," e+=expression)*|s=unionRule) ")"
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//e+=expression ("," e+=expression)*|s=unionRule
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//e+=expression ("," e+=expression)*
		public Group getGroup_2_1_0() { return cGroup_2_1_0; }

		//e+=expression
		public Assignment getEAssignment_2_1_0_0() { return cEAssignment_2_1_0_0; }

		//expression
		public RuleCall getEExpressionParserRuleCall_2_1_0_0_0() { return cEExpressionParserRuleCall_2_1_0_0_0; }

		//("," e+=expression)*
		public Group getGroup_2_1_0_1() { return cGroup_2_1_0_1; }

		//","
		public Keyword getCommaKeyword_2_1_0_1_0() { return cCommaKeyword_2_1_0_1_0; }

		//e+=expression
		public Assignment getEAssignment_2_1_0_1_1() { return cEAssignment_2_1_0_1_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_2_1_0_1_1_0() { return cEExpressionParserRuleCall_2_1_0_1_1_0; }

		//s=unionRule
		public Assignment getSAssignment_2_1_1() { return cSAssignment_2_1_1; }

		//unionRule
		public RuleCall getSUnionRuleParserRuleCall_2_1_1_0() { return cSUnionRuleParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class ExprListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "exprList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cTRAILINGParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cLEADINGParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cBOTHParserRuleCall_0_2 = (RuleCall)cAlternatives_0.eContents().get(2);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Assignment cEAssignment_1_0_0 = (Assignment)cGroup_1_0.eContents().get(0);
		private final RuleCall cEExpressionParserRuleCall_1_0_0_0 = (RuleCall)cEAssignment_1_0_0.eContents().get(0);
		private final Alternatives cAlternatives_1_0_1 = (Alternatives)cGroup_1_0.eContents().get(1);
		private final Group cGroup_1_0_1_0 = (Group)cAlternatives_1_0_1.eContents().get(0);
		private final Keyword cCommaKeyword_1_0_1_0_0 = (Keyword)cGroup_1_0_1_0.eContents().get(0);
		private final Assignment cEAssignment_1_0_1_0_1 = (Assignment)cGroup_1_0_1_0.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0_1_0_1_0 = (RuleCall)cEAssignment_1_0_1_0_1.eContents().get(0);
		private final Group cGroup_1_0_1_1 = (Group)cAlternatives_1_0_1.eContents().get(1);
		private final RuleCall cFROMParserRuleCall_1_0_1_1_0 = (RuleCall)cGroup_1_0_1_1.eContents().get(0);
		private final Assignment cEAssignment_1_0_1_1_1 = (Assignment)cGroup_1_0_1_1.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_0_1_1_1_0 = (RuleCall)cEAssignment_1_0_1_1_1.eContents().get(0);
		private final Group cGroup_1_0_1_2 = (Group)cAlternatives_1_0_1.eContents().get(2);
		private final RuleCall cASParserRuleCall_1_0_1_2_0 = (RuleCall)cGroup_1_0_1_2.eContents().get(0);
		private final Assignment cIdAssignment_1_0_1_2_1 = (Assignment)cGroup_1_0_1_2.eContents().get(1);
		private final RuleCall cIdIdentifierParserRuleCall_1_0_1_2_1_0 = (RuleCall)cIdAssignment_1_0_1_2_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final RuleCall cFROMParserRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Assignment cEAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cEExpressionParserRuleCall_1_1_1_0 = (RuleCall)cEAssignment_1_1_1.eContents().get(0);
		
		//exprList:
		//  (TRAILING|LEADING|BOTH)? (e+=expression (("," e+=expression)+|FROM e+=expression|AS
		//  id=identifier)?|FROM e+=expression)?;
		public ParserRule getRule() { return rule; }

		//(TRAILING|LEADING|BOTH)? (e+=expression (("," e+=expression)+|FROM e+=expression|AS
		//id=identifier)?|FROM e+=expression)?
		public Group getGroup() { return cGroup; }

		//(TRAILING|LEADING|BOTH)?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//TRAILING
		public RuleCall getTRAILINGParserRuleCall_0_0() { return cTRAILINGParserRuleCall_0_0; }

		//LEADING
		public RuleCall getLEADINGParserRuleCall_0_1() { return cLEADINGParserRuleCall_0_1; }

		//BOTH
		public RuleCall getBOTHParserRuleCall_0_2() { return cBOTHParserRuleCall_0_2; }

		//(e+=expression (("," e+=expression)+|FROM e+=expression|AS id=identifier)?|FROM e+=
		//expression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//e+=expression (("," e+=expression)+|FROM e+=expression|AS id=identifier)?
		public Group getGroup_1_0() { return cGroup_1_0; }

		//e+=expression
		public Assignment getEAssignment_1_0_0() { return cEAssignment_1_0_0; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_0_0_0() { return cEExpressionParserRuleCall_1_0_0_0; }

		//(("," e+=expression)+|FROM e+=expression|AS id=identifier)?
		public Alternatives getAlternatives_1_0_1() { return cAlternatives_1_0_1; }

		//("," e+=expression)+
		public Group getGroup_1_0_1_0() { return cGroup_1_0_1_0; }

		//","
		public Keyword getCommaKeyword_1_0_1_0_0() { return cCommaKeyword_1_0_1_0_0; }

		//e+=expression
		public Assignment getEAssignment_1_0_1_0_1() { return cEAssignment_1_0_1_0_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_0_1_0_1_0() { return cEExpressionParserRuleCall_1_0_1_0_1_0; }

		//FROM e+=expression
		public Group getGroup_1_0_1_1() { return cGroup_1_0_1_1; }

		//FROM
		public RuleCall getFROMParserRuleCall_1_0_1_1_0() { return cFROMParserRuleCall_1_0_1_1_0; }

		//e+=expression
		public Assignment getEAssignment_1_0_1_1_1() { return cEAssignment_1_0_1_1_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_0_1_1_1_0() { return cEExpressionParserRuleCall_1_0_1_1_1_0; }

		//AS id=identifier
		public Group getGroup_1_0_1_2() { return cGroup_1_0_1_2; }

		//AS
		public RuleCall getASParserRuleCall_1_0_1_2_0() { return cASParserRuleCall_1_0_1_2_0; }

		//id=identifier
		public Assignment getIdAssignment_1_0_1_2_1() { return cIdAssignment_1_0_1_2_1; }

		//identifier
		public RuleCall getIdIdentifierParserRuleCall_1_0_1_2_1_0() { return cIdIdentifierParserRuleCall_1_0_1_2_1_0; }

		//FROM e+=expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//FROM
		public RuleCall getFROMParserRuleCall_1_1_0() { return cFROMParserRuleCall_1_1_0; }

		//e+=expression
		public Assignment getEAssignment_1_1_1() { return cEAssignment_1_1_1; }

		//expression
		public RuleCall getEExpressionParserRuleCall_1_1_1_0() { return cEExpressionParserRuleCall_1_1_1_0; }
	}

	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "constant");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSTRINGTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNULLParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cTRUEParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cFALSEParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cEMPTYParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//constant returns ecore::EString:
		//  number|STRING|NULL|TRUE|FALSE|EMPTY; 
		//
		//
		//	   
		//	  
		//	  
		//	  
		//	  
		//	  
		//	
		//
		////## quantifiedExpression: 'exists' | ( expression 'in' ) | ( expression OP 'any' | 'some' ) collection;
		//
		////## compoundPath: path ( OPEN_BRACKET expression CLOSE_BRACKET ( '.' path )? )*;
		//
		////## path: identifier ( '.' identifier )*;
		public ParserRule getRule() { return rule; }

		//number|STRING|NULL|TRUE|FALSE|EMPTY 
		//
		//
		//	   
		//	  
		//	  
		//	  
		//	  
		//	  
		//	
		//
		////## quantifiedExpression: 'exists' | ( expression 'in' ) | ( expression OP 'any' | 'some' ) collection;
		//
		////## compoundPath: path ( OPEN_BRACKET expression CLOSE_BRACKET ( '.' path )? )*;
		//
		////## path: identifier ( '.' identifier )*;
		public Alternatives getAlternatives() { return cAlternatives; }

		//number
		public RuleCall getNumberParserRuleCall_0() { return cNumberParserRuleCall_0; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1() { return cSTRINGTerminalRuleCall_1; }

		//NULL
		public RuleCall getNULLParserRuleCall_2() { return cNULLParserRuleCall_2; }

		//TRUE
		public RuleCall getTRUEParserRuleCall_3() { return cTRUEParserRuleCall_3; }

		//FALSE
		public RuleCall getFALSEParserRuleCall_4() { return cFALSEParserRuleCall_4; }

		//EMPTY
		public RuleCall getEMPTYParserRuleCall_5() { return cEMPTYParserRuleCall_5; }
	}

	public class PathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "path");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//path returns ecore::EString:
		//  identifier ("." identifier)*; 
		//
		////## quantifiedExpression: 'exists' | ( expression 'in' ) | ( expression OP 'any' | 'some' ) collection;
		//
		////## compoundPath: path ( OPEN_BRACKET expression CLOSE_BRACKET ( '.' path )? )*;
		//
		////## path: identifier ( '.' identifier )*;
		public ParserRule getRule() { return rule; }

		//identifier ("." identifier)*
		public Group getGroup() { return cGroup; }

		//identifier
		public RuleCall getIdentifierParserRuleCall_0() { return cIdentifierParserRuleCall_0; }

		//("." identifier)*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//identifier
		public RuleCall getIdentifierParserRuleCall_1_1() { return cIdentifierParserRuleCall_1_1; }
	}

	public class IdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "identifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cDollarSignKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cEKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cUpperKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLowerKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cNowKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cTodayKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cDateKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cTitleKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cTypeKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cIncludeKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cLengthKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final RuleCall cENDParserRuleCall_13 = (RuleCall)cAlternatives.eContents().get(13);
		private final RuleCall cWHENParserRuleCall_14 = (RuleCall)cAlternatives.eContents().get(14);
		private final RuleCall cFROMParserRuleCall_15 = (RuleCall)cAlternatives.eContents().get(15);
		private final RuleCall cMEMBERParserRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		
		//identifier returns ecore::EString:
		//  "$"? ID|"e"|"f"|"d"|"upper"|"lower"|"$now"|"$today"|"date"|"title"|"type"|
		//  "include"|"length"|END|WHEN|FROM|MEMBER; 
		//
		//
		//	     
		//	            // To allow number terminals as function arguments
		//	                                     //MDD keywords that can appear in Query Functions
		public ParserRule getRule() { return rule; }

		//"$"? ID|"e"|"f"|"d"|"upper"|"lower"|"$now"|"$today"|"date"|"title"|"type"|
		//"include"|"length"|END|WHEN|FROM|MEMBER 
		//
		//
		//	     
		//	            // To allow number terminals as function arguments
		//	                                     //MDD keywords that can appear in Query Functions
		public Alternatives getAlternatives() { return cAlternatives; }

		//"$"? ID
		public Group getGroup_0() { return cGroup_0; }

		//"$"?
		public Keyword getDollarSignKeyword_0_0() { return cDollarSignKeyword_0_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_0_1() { return cIDTerminalRuleCall_0_1; }

		//"e"
		public Keyword getEKeyword_1() { return cEKeyword_1; }

		//"f"
		public Keyword getFKeyword_2() { return cFKeyword_2; }

		//"d"     // To allow number terminals as function arguments
		public Keyword getDKeyword_3() { return cDKeyword_3; }

		//"upper"
		public Keyword getUpperKeyword_4() { return cUpperKeyword_4; }

		//"lower"
		public Keyword getLowerKeyword_5() { return cLowerKeyword_5; }

		//"$now"
		public Keyword getNowKeyword_6() { return cNowKeyword_6; }

		//"$today"
		public Keyword getTodayKeyword_7() { return cTodayKeyword_7; }

		//"date"
		public Keyword getDateKeyword_8() { return cDateKeyword_8; }

		//"title"
		public Keyword getTitleKeyword_9() { return cTitleKeyword_9; }

		//"type"
		public Keyword getTypeKeyword_10() { return cTypeKeyword_10; }

		//"include"
		public Keyword getIncludeKeyword_11() { return cIncludeKeyword_11; }

		//"length"     //MDD keywords that can appear in Query Functions
		public Keyword getLengthKeyword_12() { return cLengthKeyword_12; }

		//END
		public RuleCall getENDParserRuleCall_13() { return cENDParserRuleCall_13; }

		//WHEN
		public RuleCall getWHENParserRuleCall_14() { return cWHENParserRuleCall_14; }

		//FROM
		public RuleCall getFROMParserRuleCall_15() { return cFROMParserRuleCall_15; }

		//MEMBER
		public RuleCall getMEMBERParserRuleCall_16() { return cMEMBERParserRuleCall_16; }
	}

	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "number");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cFullStopKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0_1_0 = (RuleCall)cGroup_0_1.eContents().get(0);
		private final Group cGroup_0_1_1 = (Group)cGroup_0_1.eContents().get(1);
		private final Keyword cEKeyword_0_1_1_0 = (Keyword)cGroup_0_1_1.eContents().get(0);
		private final Alternatives cAlternatives_0_1_1_1 = (Alternatives)cGroup_0_1_1.eContents().get(1);
		private final Keyword cPlusSignKeyword_0_1_1_1_0 = (Keyword)cAlternatives_0_1_1_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_1_1_1_1 = (Keyword)cAlternatives_0_1_1_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0_1_1_2 = (RuleCall)cGroup_0_1_1.eContents().get(2);
		private final Alternatives cAlternatives_0_1_2 = (Alternatives)cGroup_0_1.eContents().get(2);
		private final Keyword cFKeyword_0_1_2_0 = (Keyword)cAlternatives_0_1_2.eContents().get(0);
		private final Keyword cDKeyword_0_1_2_1 = (Keyword)cAlternatives_0_1_2.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final RuleCall cHEXTerminalRuleCall_1_0_0 = (RuleCall)cAlternatives_1_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_0_1 = (RuleCall)cAlternatives_1_0.eContents().get(1);
		private final RuleCall cSIGNED_INTTerminalRuleCall_1_0_2 = (RuleCall)cAlternatives_1_0.eContents().get(2);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cLKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1_1 = (Alternatives)cAlternatives_1_1.eContents().get(1);
		private final Group cGroup_1_1_1_0 = (Group)cAlternatives_1_1_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1_1_0_0 = (Keyword)cGroup_1_1_1_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1_1_0_1 = (RuleCall)cGroup_1_1_1_0.eContents().get(1);
		private final Group cGroup_1_1_1_0_2 = (Group)cGroup_1_1_1_0.eContents().get(2);
		private final Keyword cEKeyword_1_1_1_0_2_0 = (Keyword)cGroup_1_1_1_0_2.eContents().get(0);
		private final Alternatives cAlternatives_1_1_1_0_2_1 = (Alternatives)cGroup_1_1_1_0_2.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_1_1_0_2_1_0 = (Keyword)cAlternatives_1_1_1_0_2_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1_1_0_2_1_1 = (Keyword)cAlternatives_1_1_1_0_2_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_1_1_0_2_2 = (RuleCall)cGroup_1_1_1_0_2.eContents().get(2);
		private final Alternatives cAlternatives_1_1_1_0_3 = (Alternatives)cGroup_1_1_1_0.eContents().get(3);
		private final Keyword cFKeyword_1_1_1_0_3_0 = (Keyword)cAlternatives_1_1_1_0_3.eContents().get(0);
		private final Keyword cDKeyword_1_1_1_0_3_1 = (Keyword)cAlternatives_1_1_1_0_3.eContents().get(1);
		private final Group cGroup_1_1_1_1 = (Group)cAlternatives_1_1_1.eContents().get(1);
		private final Keyword cEKeyword_1_1_1_1_0 = (Keyword)cGroup_1_1_1_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1_1_1_1 = (Alternatives)cGroup_1_1_1_1.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_1_1_1_1_0 = (Keyword)cAlternatives_1_1_1_1_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1_1_1_1_1 = (Keyword)cAlternatives_1_1_1_1_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1_1_1_1_2 = (RuleCall)cGroup_1_1_1_1.eContents().get(2);
		private final Alternatives cAlternatives_1_1_1_1_3 = (Alternatives)cGroup_1_1_1_1.eContents().get(3);
		private final Keyword cFKeyword_1_1_1_1_3_0 = (Keyword)cAlternatives_1_1_1_1_3.eContents().get(0);
		private final Keyword cDKeyword_1_1_1_1_3_1 = (Keyword)cAlternatives_1_1_1_1_3.eContents().get(1);
		private final Keyword cFKeyword_1_1_1_2 = (Keyword)cAlternatives_1_1_1.eContents().get(2);
		private final Keyword cDKeyword_1_1_1_3 = (Keyword)cAlternatives_1_1_1.eContents().get(3);
		
		//number returns ecore::EFloat:
		//  "." (INT ("e" ("+"|"-")? INT)? ("f"|"d")?)?|(HEX|INT|SIGNED_INT) ("l"|("." INT? ("e" ("+"
		//  |"-")? INT)? ("f"|"d")?|"e" ("+"|"-")? INT ("f"|"d")?|"f"|"d"))?;
		public ParserRule getRule() { return rule; }

		//"." (INT ("e" ("+"|"-")? INT)? ("f"|"d")?)?|(HEX|INT|SIGNED_INT) ("l"|("." INT? ("e" ("+"
		//|"-")? INT)? ("f"|"d")?|"e" ("+"|"-")? INT ("f"|"d")?|"f"|"d"))?
		public Alternatives getAlternatives() { return cAlternatives; }

		//"." (INT ("e" ("+"|"-")? INT)? ("f"|"d")?)?
		public Group getGroup_0() { return cGroup_0; }

		//"."
		public Keyword getFullStopKeyword_0_0() { return cFullStopKeyword_0_0; }

		//(INT ("e" ("+"|"-")? INT)? ("f"|"d")?)?
		public Group getGroup_0_1() { return cGroup_0_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1_0() { return cINTTerminalRuleCall_0_1_0; }

		//("e" ("+"|"-")? INT)?
		public Group getGroup_0_1_1() { return cGroup_0_1_1; }

		//"e"
		public Keyword getEKeyword_0_1_1_0() { return cEKeyword_0_1_1_0; }

		//("+"|"-")?
		public Alternatives getAlternatives_0_1_1_1() { return cAlternatives_0_1_1_1; }

		//"+"
		public Keyword getPlusSignKeyword_0_1_1_1_0() { return cPlusSignKeyword_0_1_1_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_0_1_1_1_1() { return cHyphenMinusKeyword_0_1_1_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_0_1_1_2() { return cINTTerminalRuleCall_0_1_1_2; }

		//("f"|"d")?
		public Alternatives getAlternatives_0_1_2() { return cAlternatives_0_1_2; }

		//"f"
		public Keyword getFKeyword_0_1_2_0() { return cFKeyword_0_1_2_0; }

		//"d"
		public Keyword getDKeyword_0_1_2_1() { return cDKeyword_0_1_2_1; }

		//(HEX|INT|SIGNED_INT) ("l"|("." INT? ("e" ("+"|"-")? INT)? ("f"|"d")?|"e" ("+"|"-")? INT (
		//"f"|"d")?|"f"|"d"))?
		public Group getGroup_1() { return cGroup_1; }

		//HEX|INT|SIGNED_INT
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//HEX
		public RuleCall getHEXTerminalRuleCall_1_0_0() { return cHEXTerminalRuleCall_1_0_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_0_1() { return cINTTerminalRuleCall_1_0_1; }

		//SIGNED_INT
		public RuleCall getSIGNED_INTTerminalRuleCall_1_0_2() { return cSIGNED_INTTerminalRuleCall_1_0_2; }

		//("l"|("." INT? ("e" ("+"|"-")? INT)? ("f"|"d")?|"e" ("+"|"-")? INT ("f"|"d")?|"f"|"d"))?
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"l"
		public Keyword getLKeyword_1_1_0() { return cLKeyword_1_1_0; }

		//"." INT? ("e" ("+"|"-")? INT)? ("f"|"d")?|"e" ("+"|"-")? INT ("f"|"d")?|"f"|"d"
		public Alternatives getAlternatives_1_1_1() { return cAlternatives_1_1_1; }

		//"." INT? ("e" ("+"|"-")? INT)? ("f"|"d")?
		public Group getGroup_1_1_1_0() { return cGroup_1_1_1_0; }

		//"."
		public Keyword getFullStopKeyword_1_1_1_0_0() { return cFullStopKeyword_1_1_1_0_0; }

		//INT?
		public RuleCall getINTTerminalRuleCall_1_1_1_0_1() { return cINTTerminalRuleCall_1_1_1_0_1; }

		//("e" ("+"|"-")? INT)?
		public Group getGroup_1_1_1_0_2() { return cGroup_1_1_1_0_2; }

		//"e"
		public Keyword getEKeyword_1_1_1_0_2_0() { return cEKeyword_1_1_1_0_2_0; }

		//("+"|"-")?
		public Alternatives getAlternatives_1_1_1_0_2_1() { return cAlternatives_1_1_1_0_2_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_1_1_0_2_1_0() { return cPlusSignKeyword_1_1_1_0_2_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1_1_0_2_1_1() { return cHyphenMinusKeyword_1_1_1_0_2_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1_1_0_2_2() { return cINTTerminalRuleCall_1_1_1_0_2_2; }

		//("f"|"d")?
		public Alternatives getAlternatives_1_1_1_0_3() { return cAlternatives_1_1_1_0_3; }

		//"f"
		public Keyword getFKeyword_1_1_1_0_3_0() { return cFKeyword_1_1_1_0_3_0; }

		//"d"
		public Keyword getDKeyword_1_1_1_0_3_1() { return cDKeyword_1_1_1_0_3_1; }

		//"e" ("+"|"-")? INT ("f"|"d")?
		public Group getGroup_1_1_1_1() { return cGroup_1_1_1_1; }

		//"e"
		public Keyword getEKeyword_1_1_1_1_0() { return cEKeyword_1_1_1_1_0; }

		//("+"|"-")?
		public Alternatives getAlternatives_1_1_1_1_1() { return cAlternatives_1_1_1_1_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_1_1_1_1_0() { return cPlusSignKeyword_1_1_1_1_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1_1_1_1_1() { return cHyphenMinusKeyword_1_1_1_1_1_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_1_1_1_1_2() { return cINTTerminalRuleCall_1_1_1_1_2; }

		//("f"|"d")?
		public Alternatives getAlternatives_1_1_1_1_3() { return cAlternatives_1_1_1_1_3; }

		//"f"
		public Keyword getFKeyword_1_1_1_1_3_0() { return cFKeyword_1_1_1_1_3_0; }

		//"d"
		public Keyword getDKeyword_1_1_1_1_3_1() { return cDKeyword_1_1_1_1_3_1; }

		//"f"
		public Keyword getFKeyword_1_1_1_2() { return cFKeyword_1_1_1_2; }

		//"d"
		public Keyword getDKeyword_1_1_1_3() { return cDKeyword_1_1_1_3; }
	}

	public class SELECTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SELECT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSELECTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSelectKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSelectKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//SELECT returns ecore::EString:
		//  "SELECT"|"Select"|"select";
		public ParserRule getRule() { return rule; }

		//"SELECT"|"Select"|"select"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"SELECT"
		public Keyword getSELECTKeyword_0() { return cSELECTKeyword_0; }

		//"Select"
		public Keyword getSelectKeyword_1() { return cSelectKeyword_1; }

		//"select"
		public Keyword getSelectKeyword_2() { return cSelectKeyword_2; }
	}

	public class DISTINCTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DISTINCT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDISTINCTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cDistinctKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDistinctKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//DISTINCT returns ecore::EString:
		//  "DISTINCT"|"Distinct"|"distinct";
		public ParserRule getRule() { return rule; }

		//"DISTINCT"|"Distinct"|"distinct"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"DISTINCT"
		public Keyword getDISTINCTKeyword_0() { return cDISTINCTKeyword_0; }

		//"Distinct"
		public Keyword getDistinctKeyword_1() { return cDistinctKeyword_1; }

		//"distinct"
		public Keyword getDistinctKeyword_2() { return cDistinctKeyword_2; }
	}

	public class NEWElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NEW");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cNEWKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNewKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cNewKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//NEW returns ecore::EString:
		//  "NEW"|"New"|"new";
		public ParserRule getRule() { return rule; }

		//"NEW"|"New"|"new"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"NEW"
		public Keyword getNEWKeyword_0() { return cNEWKeyword_0; }

		//"New"
		public Keyword getNewKeyword_1() { return cNewKeyword_1; }

		//"new"
		public Keyword getNewKeyword_2() { return cNewKeyword_2; }
	}

	public class OBJECTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OBJECT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cOBJECTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cObjectKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cObjectKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//OBJECT returns ecore::EString:
		//  "OBJECT"|"Object"|"object";
		public ParserRule getRule() { return rule; }

		//"OBJECT"|"Object"|"object"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"OBJECT"
		public Keyword getOBJECTKeyword_0() { return cOBJECTKeyword_0; }

		//"Object"
		public Keyword getObjectKeyword_1() { return cObjectKeyword_1; }

		//"object"
		public Keyword getObjectKeyword_2() { return cObjectKeyword_2; }
	}

	public class FROMElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FROM");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFROMKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFromKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFromKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//FROM returns ecore::EString:
		//  "FROM"|"From"|"from";
		public ParserRule getRule() { return rule; }

		//"FROM"|"From"|"from"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"FROM"
		public Keyword getFROMKeyword_0() { return cFROMKeyword_0; }

		//"From"
		public Keyword getFromKeyword_1() { return cFromKeyword_1; }

		//"from"
		public Keyword getFromKeyword_2() { return cFromKeyword_2; }
	}

	public class LEFTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LEFT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLEFTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLeftKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLeftKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//LEFT returns ecore::EString:
		//  "LEFT"|"Left"|"left";
		public ParserRule getRule() { return rule; }

		//"LEFT"|"Left"|"left"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"LEFT"
		public Keyword getLEFTKeyword_0() { return cLEFTKeyword_0; }

		//"Left"
		public Keyword getLeftKeyword_1() { return cLeftKeyword_1; }

		//"left"
		public Keyword getLeftKeyword_2() { return cLeftKeyword_2; }
	}

	public class RIGHTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RIGHT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cRIGHTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cRightKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cRightKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//RIGHT returns ecore::EString:
		//  "RIGHT"|"Right"|"right";
		public ParserRule getRule() { return rule; }

		//"RIGHT"|"Right"|"right"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"RIGHT"
		public Keyword getRIGHTKeyword_0() { return cRIGHTKeyword_0; }

		//"Right"
		public Keyword getRightKeyword_1() { return cRightKeyword_1; }

		//"right"
		public Keyword getRightKeyword_2() { return cRightKeyword_2; }
	}

	public class OUTERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OUTER");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cOUTERKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cOuterKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cOuterKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//OUTER returns ecore::EString:
		//  "OUTER"|"Outer"|"outer";
		public ParserRule getRule() { return rule; }

		//"OUTER"|"Outer"|"outer"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"OUTER"
		public Keyword getOUTERKeyword_0() { return cOUTERKeyword_0; }

		//"Outer"
		public Keyword getOuterKeyword_1() { return cOuterKeyword_1; }

		//"outer"
		public Keyword getOuterKeyword_2() { return cOuterKeyword_2; }
	}

	public class FULLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FULL");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFULLKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFullKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFullKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//FULL returns ecore::EString:
		//  "FULL"|"Full"|"full";
		public ParserRule getRule() { return rule; }

		//"FULL"|"Full"|"full"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"FULL"
		public Keyword getFULLKeyword_0() { return cFULLKeyword_0; }

		//"Full"
		public Keyword getFullKeyword_1() { return cFullKeyword_1; }

		//"full"
		public Keyword getFullKeyword_2() { return cFullKeyword_2; }
	}

	public class INNERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "INNER");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cINNERKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cInnerKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cInnerKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//INNER returns ecore::EString:
		//  "INNER"|"Inner"|"inner";
		public ParserRule getRule() { return rule; }

		//"INNER"|"Inner"|"inner"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"INNER"
		public Keyword getINNERKeyword_0() { return cINNERKeyword_0; }

		//"Inner"
		public Keyword getInnerKeyword_1() { return cInnerKeyword_1; }

		//"inner"
		public Keyword getInnerKeyword_2() { return cInnerKeyword_2; }
	}

	public class JOINElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "JOIN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cJOINKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cJoinKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cJoinKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//JOIN returns ecore::EString:
		//  "JOIN"|"Join"|"join";
		public ParserRule getRule() { return rule; }

		//"JOIN"|"Join"|"join"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"JOIN"
		public Keyword getJOINKeyword_0() { return cJOINKeyword_0; }

		//"Join"
		public Keyword getJoinKeyword_1() { return cJoinKeyword_1; }

		//"join"
		public Keyword getJoinKeyword_2() { return cJoinKeyword_2; }
	}

	public class FETCHElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FETCH");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFETCHKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFetchKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFetchKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//FETCH returns ecore::EString:
		//  "FETCH"|"Fetch"|"fetch";
		public ParserRule getRule() { return rule; }

		//"FETCH"|"Fetch"|"fetch"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"FETCH"
		public Keyword getFETCHKeyword_0() { return cFETCHKeyword_0; }

		//"Fetch"
		public Keyword getFetchKeyword_1() { return cFetchKeyword_1; }

		//"fetch"
		public Keyword getFetchKeyword_2() { return cFetchKeyword_2; }
	}

	public class WITHElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WITH");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cWITHKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cWithKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cWithKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//WITH returns ecore::EString:
		//  "WITH"|"With"|"with";
		public ParserRule getRule() { return rule; }

		//"WITH"|"With"|"with"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"WITH"
		public Keyword getWITHKeyword_0() { return cWITHKeyword_0; }

		//"With"
		public Keyword getWithKeyword_1() { return cWithKeyword_1; }

		//"with"
		public Keyword getWithKeyword_2() { return cWithKeyword_2; }
	}

	public class INElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cINKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cInKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cInKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//IN returns ecore::EString:
		//  "IN"|"In"|"in";
		public ParserRule getRule() { return rule; }

		//"IN"|"In"|"in"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"IN"
		public Keyword getINKeyword_0() { return cINKeyword_0; }

		//"In"
		public Keyword getInKeyword_1() { return cInKeyword_1; }

		//"in"
		public Keyword getInKeyword_2() { return cInKeyword_2; }
	}

	public class CLASSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CLASS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cCLASSKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cClassKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cClassKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//CLASS returns ecore::EString:
		//  "CLASS"|"Class"|"class";
		public ParserRule getRule() { return rule; }

		//"CLASS"|"Class"|"class"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"CLASS"
		public Keyword getCLASSKeyword_0() { return cCLASSKeyword_0; }

		//"Class"
		public Keyword getClassKeyword_1() { return cClassKeyword_1; }

		//"class"
		public Keyword getClassKeyword_2() { return cClassKeyword_2; }
	}

	public class IN_CLASSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IN_CLASS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cCLASSParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//IN_CLASS returns ecore::EString:
		//  IN CLASS;
		public ParserRule getRule() { return rule; }

		//IN CLASS
		public Group getGroup() { return cGroup; }

		//IN
		public RuleCall getINParserRuleCall_0() { return cINParserRuleCall_0; }

		//CLASS
		public RuleCall getCLASSParserRuleCall_1() { return cCLASSParserRuleCall_1; }
	}

	public class ELEMENTSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ELEMENTS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cELEMENTSKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cElementsKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cElementsKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//ELEMENTS returns ecore::EString:
		//  "ELEMENTS"|"Elements"|"elements";
		public ParserRule getRule() { return rule; }

		//"ELEMENTS"|"Elements"|"elements"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ELEMENTS"
		public Keyword getELEMENTSKeyword_0() { return cELEMENTSKeyword_0; }

		//"Elements"
		public Keyword getElementsKeyword_1() { return cElementsKeyword_1; }

		//"elements"
		public Keyword getElementsKeyword_2() { return cElementsKeyword_2; }
	}

	public class IN_ELEMENTSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IN_ELEMENTS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cELEMENTSParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//IN_ELEMENTS returns ecore::EString:
		//  IN ELEMENTS;
		public ParserRule getRule() { return rule; }

		//IN ELEMENTS
		public Group getGroup() { return cGroup; }

		//IN
		public RuleCall getINParserRuleCall_0() { return cINParserRuleCall_0; }

		//ELEMENTS
		public RuleCall getELEMENTSParserRuleCall_1() { return cELEMENTSParserRuleCall_1; }
	}

	public class ASElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cASKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAsKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAsKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//AS returns ecore::EString:
		//  "AS"|"As"|"as";
		public ParserRule getRule() { return rule; }

		//"AS"|"As"|"as"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"AS"
		public Keyword getASKeyword_0() { return cASKeyword_0; }

		//"As"
		public Keyword getAsKeyword_1() { return cAsKeyword_1; }

		//"as"
		public Keyword getAsKeyword_2() { return cAsKeyword_2; }
	}

	public class PROPERTIESElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PROPERTIES");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPROPERTIESKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPropertiesKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cPropertiesKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//PROPERTIES returns ecore::EString:
		//  "PROPERTIES"|"Properties"|"properties";
		public ParserRule getRule() { return rule; }

		//"PROPERTIES"|"Properties"|"properties"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"PROPERTIES"
		public Keyword getPROPERTIESKeyword_0() { return cPROPERTIESKeyword_0; }

		//"Properties"
		public Keyword getPropertiesKeyword_1() { return cPropertiesKeyword_1; }

		//"properties"
		public Keyword getPropertiesKeyword_2() { return cPropertiesKeyword_2; }
	}

	public class GROUP_BYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GROUP_BY");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cGROUPKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cGroupKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cGroupKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final RuleCall cBYParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//GROUP_BY returns ecore::EString:
		//  ("GROUP"|"Group"|"group") BY;
		public ParserRule getRule() { return rule; }

		//("GROUP"|"Group"|"group") BY
		public Group getGroup() { return cGroup; }

		//"GROUP"|"Group"|"group"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"GROUP"
		public Keyword getGROUPKeyword_0_0() { return cGROUPKeyword_0_0; }

		//"Group"
		public Keyword getGroupKeyword_0_1() { return cGroupKeyword_0_1; }

		//"group"
		public Keyword getGroupKeyword_0_2() { return cGroupKeyword_0_2; }

		//BY
		public RuleCall getBYParserRuleCall_1() { return cBYParserRuleCall_1; }
	}

	public class ORDER_BYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ORDER_BY");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cORDERKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cOrderKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cOrderKeyword_0_2 = (Keyword)cAlternatives_0.eContents().get(2);
		private final RuleCall cBYParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//ORDER_BY returns ecore::EString:
		//  ("ORDER"|"Order"|"order") BY;
		public ParserRule getRule() { return rule; }

		//("ORDER"|"Order"|"order") BY
		public Group getGroup() { return cGroup; }

		//"ORDER"|"Order"|"order"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"ORDER"
		public Keyword getORDERKeyword_0_0() { return cORDERKeyword_0_0; }

		//"Order"
		public Keyword getOrderKeyword_0_1() { return cOrderKeyword_0_1; }

		//"order"
		public Keyword getOrderKeyword_0_2() { return cOrderKeyword_0_2; }

		//BY
		public RuleCall getBYParserRuleCall_1() { return cBYParserRuleCall_1; }
	}

	public class BYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BY");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBYKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cByKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cByKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//BY returns ecore::EString:
		//  "BY"|"By"|"by";
		public ParserRule getRule() { return rule; }

		//"BY"|"By"|"by"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"BY"
		public Keyword getBYKeyword_0() { return cBYKeyword_0; }

		//"By"
		public Keyword getByKeyword_1() { return cByKeyword_1; }

		//"by"
		public Keyword getByKeyword_2() { return cByKeyword_2; }
	}

	public class ASCElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASC");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cASCKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAscKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAscKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cASCENDINGKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cAscendingKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cAscendingKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//ASC returns ecore::EString:
		//  "ASC"|"Asc"|"asc"|"ASCENDING"|"Ascending"|"ascending";
		public ParserRule getRule() { return rule; }

		//"ASC"|"Asc"|"asc"|"ASCENDING"|"Ascending"|"ascending"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ASC"
		public Keyword getASCKeyword_0() { return cASCKeyword_0; }

		//"Asc"
		public Keyword getAscKeyword_1() { return cAscKeyword_1; }

		//"asc"
		public Keyword getAscKeyword_2() { return cAscKeyword_2; }

		//"ASCENDING"
		public Keyword getASCENDINGKeyword_3() { return cASCENDINGKeyword_3; }

		//"Ascending"
		public Keyword getAscendingKeyword_4() { return cAscendingKeyword_4; }

		//"ascending"
		public Keyword getAscendingKeyword_5() { return cAscendingKeyword_5; }
	}

	public class DESCElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DESC");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDESCKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cDescKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDescKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDESCENDINGKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cDescendingKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cDescendingKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//DESC returns ecore::EString:
		//  "DESC"|"Desc"|"desc"|"DESCENDING"|"Descending"|"descending";
		public ParserRule getRule() { return rule; }

		//"DESC"|"Desc"|"desc"|"DESCENDING"|"Descending"|"descending"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"DESC"
		public Keyword getDESCKeyword_0() { return cDESCKeyword_0; }

		//"Desc"
		public Keyword getDescKeyword_1() { return cDescKeyword_1; }

		//"desc"
		public Keyword getDescKeyword_2() { return cDescKeyword_2; }

		//"DESCENDING"
		public Keyword getDESCENDINGKeyword_3() { return cDESCENDINGKeyword_3; }

		//"Descending"
		public Keyword getDescendingKeyword_4() { return cDescendingKeyword_4; }

		//"descending"
		public Keyword getDescendingKeyword_5() { return cDescendingKeyword_5; }
	}

	public class HAVINGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "HAVING");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHAVINGKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHavingKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cHavingKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//HAVING returns ecore::EString:
		//  "HAVING"|"Having"|"having";
		public ParserRule getRule() { return rule; }

		//"HAVING"|"Having"|"having"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"HAVING"
		public Keyword getHAVINGKeyword_0() { return cHAVINGKeyword_0; }

		//"Having"
		public Keyword getHavingKeyword_1() { return cHavingKeyword_1; }

		//"having"
		public Keyword getHavingKeyword_2() { return cHavingKeyword_2; }
	}

	public class WHEREElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WHERE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cWHEREKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cWhereKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cWhereKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//WHERE returns ecore::EString:
		//  "WHERE"|"Where"|"where";
		public ParserRule getRule() { return rule; }

		//"WHERE"|"Where"|"where"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"WHERE"
		public Keyword getWHEREKeyword_0() { return cWHEREKeyword_0; }

		//"Where"
		public Keyword getWhereKeyword_1() { return cWhereKeyword_1; }

		//"where"
		public Keyword getWhereKeyword_2() { return cWhereKeyword_2; }
	}

	public class ORElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OR");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cORKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cOrKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cOrKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//OR returns ecore::EString:
		//  "OR"|"Or"|"or";
		public ParserRule getRule() { return rule; }

		//"OR"|"Or"|"or"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"OR"
		public Keyword getORKeyword_0() { return cORKeyword_0; }

		//"Or"
		public Keyword getOrKeyword_1() { return cOrKeyword_1; }

		//"or"
		public Keyword getOrKeyword_2() { return cOrKeyword_2; }
	}

	public class ANDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AND");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cANDKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAndKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAndKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//AND returns ecore::EString:
		//  "AND"|"And"|"and";
		public ParserRule getRule() { return rule; }

		//"AND"|"And"|"and"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"AND"
		public Keyword getANDKeyword_0() { return cANDKeyword_0; }

		//"And"
		public Keyword getAndKeyword_1() { return cAndKeyword_1; }

		//"and"
		public Keyword getAndKeyword_2() { return cAndKeyword_2; }
	}

	public class NOTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NOT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cNOTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cNotKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//NOT returns ecore::EString:
		//  "NOT"|"Not"|"not";
		public ParserRule getRule() { return rule; }

		//"NOT"|"Not"|"not"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"NOT"
		public Keyword getNOTKeyword_0() { return cNOTKeyword_0; }

		//"Not"
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }

		//"not"
		public Keyword getNotKeyword_2() { return cNotKeyword_2; }
	}

	public class ISElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cISKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cIsKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cIsKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//IS returns ecore::EString:
		//  "IS"|"Is"|"is";
		public ParserRule getRule() { return rule; }

		//"IS"|"Is"|"is"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"IS"
		public Keyword getISKeyword_0() { return cISKeyword_0; }

		//"Is"
		public Keyword getIsKeyword_1() { return cIsKeyword_1; }

		//"is"
		public Keyword getIsKeyword_2() { return cIsKeyword_2; }
	}

	public class BETWEENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BETWEEN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBETWEENKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cBetweenKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cBetweenKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//BETWEEN returns ecore::EString:
		//  "BETWEEN"|"Between"|"between";
		public ParserRule getRule() { return rule; }

		//"BETWEEN"|"Between"|"between"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"BETWEEN"
		public Keyword getBETWEENKeyword_0() { return cBETWEENKeyword_0; }

		//"Between"
		public Keyword getBetweenKeyword_1() { return cBetweenKeyword_1; }

		//"between"
		public Keyword getBetweenKeyword_2() { return cBetweenKeyword_2; }
	}

	public class LIKEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LIKE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLIKEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLikeKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLikeKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//LIKE returns ecore::EString:
		//  "LIKE"|"Like"|"like";
		public ParserRule getRule() { return rule; }

		//"LIKE"|"Like"|"like"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"LIKE"
		public Keyword getLIKEKeyword_0() { return cLIKEKeyword_0; }

		//"Like"
		public Keyword getLikeKeyword_1() { return cLikeKeyword_1; }

		//"like"
		public Keyword getLikeKeyword_2() { return cLikeKeyword_2; }
	}

	public class MEMBERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MEMBER");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cMEMBERKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMemberKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cMemberKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//MEMBER returns ecore::EString:
		//  "MEMBER"|"Member"|"member";
		public ParserRule getRule() { return rule; }

		//"MEMBER"|"Member"|"member"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"MEMBER"
		public Keyword getMEMBERKeyword_0() { return cMEMBERKeyword_0; }

		//"Member"
		public Keyword getMemberKeyword_1() { return cMemberKeyword_1; }

		//"member"
		public Keyword getMemberKeyword_2() { return cMemberKeyword_2; }
	}

	public class OFElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OF");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cOFKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cOfKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cOfKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//OF returns ecore::EString:
		//  "OF"|"Of"|"of";
		public ParserRule getRule() { return rule; }

		//"OF"|"Of"|"of"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"OF"
		public Keyword getOFKeyword_0() { return cOFKeyword_0; }

		//"Of"
		public Keyword getOfKeyword_1() { return cOfKeyword_1; }

		//"of"
		public Keyword getOfKeyword_2() { return cOfKeyword_2; }
	}

	public class ESCAPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ESCAPE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cESCAPEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEscapeKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEscapeKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//ESCAPE returns ecore::EString:
		//  "ESCAPE"|"Escape"|"escape";
		public ParserRule getRule() { return rule; }

		//"ESCAPE"|"Escape"|"escape"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ESCAPE"
		public Keyword getESCAPEKeyword_0() { return cESCAPEKeyword_0; }

		//"Escape"
		public Keyword getEscapeKeyword_1() { return cEscapeKeyword_1; }

		//"escape"
		public Keyword getEscapeKeyword_2() { return cEscapeKeyword_2; }
	}

	public class CASEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CASE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cCASEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cCaseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cCaseKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//CASE returns ecore::EString:
		//  "CASE"|"Case"|"case";
		public ParserRule getRule() { return rule; }

		//"CASE"|"Case"|"case"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"CASE"
		public Keyword getCASEKeyword_0() { return cCASEKeyword_0; }

		//"Case"
		public Keyword getCaseKeyword_1() { return cCaseKeyword_1; }

		//"case"
		public Keyword getCaseKeyword_2() { return cCaseKeyword_2; }
	}

	public class ENDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "END");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cENDKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEndKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEndKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//END returns ecore::EString:
		//  "END"|"End"|"end";
		public ParserRule getRule() { return rule; }

		//"END"|"End"|"end"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"END"
		public Keyword getENDKeyword_0() { return cENDKeyword_0; }

		//"End"
		public Keyword getEndKeyword_1() { return cEndKeyword_1; }

		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }
	}

	public class WHENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WHEN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cWHENKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cWhenKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cWhenKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//WHEN returns ecore::EString:
		//  "WHEN"|"When"|"when";
		public ParserRule getRule() { return rule; }

		//"WHEN"|"When"|"when"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"WHEN"
		public Keyword getWHENKeyword_0() { return cWHENKeyword_0; }

		//"When"
		public Keyword getWhenKeyword_1() { return cWhenKeyword_1; }

		//"when"
		public Keyword getWhenKeyword_2() { return cWhenKeyword_2; }
	}

	public class THENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "THEN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTHENKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cThenKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cThenKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//THEN returns ecore::EString:
		//  "THEN"|"Then"|"then";
		public ParserRule getRule() { return rule; }

		//"THEN"|"Then"|"then"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"THEN"
		public Keyword getTHENKeyword_0() { return cTHENKeyword_0; }

		//"Then"
		public Keyword getThenKeyword_1() { return cThenKeyword_1; }

		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }
	}

	public class ELSEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ELSE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cELSEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cElseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cElseKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//ELSE returns ecore::EString:
		//  "ELSE"|"Else"|"else";
		public ParserRule getRule() { return rule; }

		//"ELSE"|"Else"|"else"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ELSE"
		public Keyword getELSEKeyword_0() { return cELSEKeyword_0; }

		//"Else"
		public Keyword getElseKeyword_1() { return cElseKeyword_1; }

		//"else"
		public Keyword getElseKeyword_2() { return cElseKeyword_2; }
	}

	public class SOMEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SOME");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSOMEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSomeKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSomeKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//SOME returns ecore::EString:
		//  "SOME"|"Some"|"some";
		public ParserRule getRule() { return rule; }

		//"SOME"|"Some"|"some"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"SOME"
		public Keyword getSOMEKeyword_0() { return cSOMEKeyword_0; }

		//"Some"
		public Keyword getSomeKeyword_1() { return cSomeKeyword_1; }

		//"some"
		public Keyword getSomeKeyword_2() { return cSomeKeyword_2; }
	}

	public class EXISTSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EXISTS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEXISTSKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cExistsKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cExistsKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//EXISTS returns ecore::EString:
		//  "EXISTS"|"Exists"|"exists";
		public ParserRule getRule() { return rule; }

		//"EXISTS"|"Exists"|"exists"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"EXISTS"
		public Keyword getEXISTSKeyword_0() { return cEXISTSKeyword_0; }

		//"Exists"
		public Keyword getExistsKeyword_1() { return cExistsKeyword_1; }

		//"exists"
		public Keyword getExistsKeyword_2() { return cExistsKeyword_2; }
	}

	public class ALLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ALL");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cALLKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAllKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAllKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//ALL returns ecore::EString:
		//  "ALL"|"All"|"all";
		public ParserRule getRule() { return rule; }

		//"ALL"|"All"|"all"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ALL"
		public Keyword getALLKeyword_0() { return cALLKeyword_0; }

		//"All"
		public Keyword getAllKeyword_1() { return cAllKeyword_1; }

		//"all"
		public Keyword getAllKeyword_2() { return cAllKeyword_2; }
	}

	public class ANYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ANY");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cANYKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAnyKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAnyKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//ANY returns ecore::EString:
		//  "ANY"|"Any"|"any";
		public ParserRule getRule() { return rule; }

		//"ANY"|"Any"|"any"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"ANY"
		public Keyword getANYKeyword_0() { return cANYKeyword_0; }

		//"Any"
		public Keyword getAnyKeyword_1() { return cAnyKeyword_1; }

		//"any"
		public Keyword getAnyKeyword_2() { return cAnyKeyword_2; }
	}

	public class SUMElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SUM");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cSUMKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSumKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSumKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//SUM returns ecore::EString:
		//  "SUM"|"Sum"|"sum";
		public ParserRule getRule() { return rule; }

		//"SUM"|"Sum"|"sum"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"SUM"
		public Keyword getSUMKeyword_0() { return cSUMKeyword_0; }

		//"Sum"
		public Keyword getSumKeyword_1() { return cSumKeyword_1; }

		//"sum"
		public Keyword getSumKeyword_2() { return cSumKeyword_2; }
	}

	public class AVGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AVG");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAVGKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAvgKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAvgKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//AVG returns ecore::EString:
		//  "AVG"|"Avg"|"avg";
		public ParserRule getRule() { return rule; }

		//"AVG"|"Avg"|"avg"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"AVG"
		public Keyword getAVGKeyword_0() { return cAVGKeyword_0; }

		//"Avg"
		public Keyword getAvgKeyword_1() { return cAvgKeyword_1; }

		//"avg"
		public Keyword getAvgKeyword_2() { return cAvgKeyword_2; }
	}

	public class MAXElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MAX");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cMAXKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMaxKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cMaxKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//MAX returns ecore::EString:
		//  "MAX"|"Max"|"max";
		public ParserRule getRule() { return rule; }

		//"MAX"|"Max"|"max"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"MAX"
		public Keyword getMAXKeyword_0() { return cMAXKeyword_0; }

		//"Max"
		public Keyword getMaxKeyword_1() { return cMaxKeyword_1; }

		//"max"
		public Keyword getMaxKeyword_2() { return cMaxKeyword_2; }
	}

	public class MINElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MIN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cMINKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMinKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cMinKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//MIN returns ecore::EString:
		//  "MIN"|"Min"|"min";
		public ParserRule getRule() { return rule; }

		//"MIN"|"Min"|"min"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"MIN"
		public Keyword getMINKeyword_0() { return cMINKeyword_0; }

		//"Min"
		public Keyword getMinKeyword_1() { return cMinKeyword_1; }

		//"min"
		public Keyword getMinKeyword_2() { return cMinKeyword_2; }
	}

	public class COUNTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "COUNT");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cCOUNTKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cCountKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cCountKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//COUNT returns ecore::EString:
		//  "COUNT"|"Count"|"count";
		public ParserRule getRule() { return rule; }

		//"COUNT"|"Count"|"count"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"COUNT"
		public Keyword getCOUNTKeyword_0() { return cCOUNTKeyword_0; }

		//"Count"
		public Keyword getCountKeyword_1() { return cCountKeyword_1; }

		//"count"
		public Keyword getCountKeyword_2() { return cCountKeyword_2; }
	}

	public class INDICESElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "INDICES");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cINDICESKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cIndicesKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cIndicesKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//INDICES returns ecore::EString:
		//  "INDICES"|"Indices"|"indices";
		public ParserRule getRule() { return rule; }

		//"INDICES"|"Indices"|"indices"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"INDICES"
		public Keyword getINDICESKeyword_0() { return cINDICESKeyword_0; }

		//"Indices"
		public Keyword getIndicesKeyword_1() { return cIndicesKeyword_1; }

		//"indices"
		public Keyword getIndicesKeyword_2() { return cIndicesKeyword_2; }
	}

	public class TRAILINGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TRAILING");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTRAILINGKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cTrailingKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTrailingKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//TRAILING returns ecore::EString:
		//  "TRAILING"|"Trailing"|"trailing";
		public ParserRule getRule() { return rule; }

		//"TRAILING"|"Trailing"|"trailing"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"TRAILING"
		public Keyword getTRAILINGKeyword_0() { return cTRAILINGKeyword_0; }

		//"Trailing"
		public Keyword getTrailingKeyword_1() { return cTrailingKeyword_1; }

		//"trailing"
		public Keyword getTrailingKeyword_2() { return cTrailingKeyword_2; }
	}

	public class LEADINGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LEADING");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cLEADINGKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLeadingKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cLeadingKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//LEADING returns ecore::EString:
		//  "LEADING"|"Leading"|"leading";
		public ParserRule getRule() { return rule; }

		//"LEADING"|"Leading"|"leading"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"LEADING"
		public Keyword getLEADINGKeyword_0() { return cLEADINGKeyword_0; }

		//"Leading"
		public Keyword getLeadingKeyword_1() { return cLeadingKeyword_1; }

		//"leading"
		public Keyword getLeadingKeyword_2() { return cLeadingKeyword_2; }
	}

	public class BOTHElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BOTH");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBOTHKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cBothKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cBothKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//BOTH returns ecore::EString:
		//  "BOTH"|"Both"|"both";
		public ParserRule getRule() { return rule; }

		//"BOTH"|"Both"|"both"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"BOTH"
		public Keyword getBOTHKeyword_0() { return cBOTHKeyword_0; }

		//"Both"
		public Keyword getBothKeyword_1() { return cBothKeyword_1; }

		//"both"
		public Keyword getBothKeyword_2() { return cBothKeyword_2; }
	}

	public class NULLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NULL");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cNULLKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNullKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cNullKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//NULL returns ecore::EString:
		//  "NULL"|"Null"|"null";
		public ParserRule getRule() { return rule; }

		//"NULL"|"Null"|"null"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"NULL"
		public Keyword getNULLKeyword_0() { return cNULLKeyword_0; }

		//"Null"
		public Keyword getNullKeyword_1() { return cNullKeyword_1; }

		//"null"
		public Keyword getNullKeyword_2() { return cNullKeyword_2; }
	}

	public class TRUEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TRUE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTRUEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cTrueKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTrueKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//TRUE returns ecore::EString:
		//  "TRUE"|"True"|"true";
		public ParserRule getRule() { return rule; }

		//"TRUE"|"True"|"true"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"TRUE"
		public Keyword getTRUEKeyword_0() { return cTRUEKeyword_0; }

		//"True"
		public Keyword getTrueKeyword_1() { return cTrueKeyword_1; }

		//"true"
		public Keyword getTrueKeyword_2() { return cTrueKeyword_2; }
	}

	public class FALSEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FALSE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cFALSEKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cFalseKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//FALSE returns ecore::EString:
		//  "FALSE"|"False"|"false";
		public ParserRule getRule() { return rule; }

		//"FALSE"|"False"|"false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"FALSE"
		public Keyword getFALSEKeyword_0() { return cFALSEKeyword_0; }

		//"False"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }

		//"false"
		public Keyword getFalseKeyword_2() { return cFalseKeyword_2; }
	}

	public class EMPTYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EMPTY");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEMPTYKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cEmptyKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEmptyKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//EMPTY returns ecore::EString:
		//  "EMPTY"|"Empty"|"empty"; 
		//          	
		//
		//	
		//
		//// END HQL stuff
		//
		////keywords that can be used as names of fields or functions
		public ParserRule getRule() { return rule; }

		//"EMPTY"|"Empty"|"empty" 
		//          	
		//
		//	
		//
		//// END HQL stuff
		//
		////keywords that can be used as names of fields or functions
		public Alternatives getAlternatives() { return cAlternatives; }

		//"EMPTY"
		public Keyword getEMPTYKeyword_0() { return cEMPTYKeyword_0; }

		//"Empty"
		public Keyword getEmptyKeyword_1() { return cEmptyKeyword_1; }

		//"empty"
		public Keyword getEmptyKeyword_2() { return cEmptyKeyword_2; }
	}

	public class KeywordElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "keyword");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAllKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLengthKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cCharKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cTypeKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cFileKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cTextKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cTitleKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cMaxKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cWhenKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cMemberKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cEndKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cObjectKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		private final Keyword cDateKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		
		//keyword returns ecore::EString:
		//  "all"|"length"|"char"|"type"|"file"|"text"|"title"|"max"|"when"|"member"|"end"|
		//  "object"|"date"; 	
		//
		//	
		//
		//// END HQL stuff
		//
		////keywords that can be used as names of fields or functions	
		//
		//	                            //MDD keywords
		//	                       //HQL keywords
		public ParserRule getRule() { return rule; }

		//"all"|"length"|"char"|"type"|"file"|"text"|"title"|"max"|"when"|"member"|"end"|
		//"object"|"date" 	
		//
		//	
		//
		//// END HQL stuff
		//
		////keywords that can be used as names of fields or functions	
		//
		//	                            //MDD keywords
		//	                       //HQL keywords
		public Alternatives getAlternatives() { return cAlternatives; }

		//"all"
		public Keyword getAllKeyword_0() { return cAllKeyword_0; }

		//"length"
		public Keyword getLengthKeyword_1() { return cLengthKeyword_1; }

		//"char"
		public Keyword getCharKeyword_2() { return cCharKeyword_2; }

		//"type"
		public Keyword getTypeKeyword_3() { return cTypeKeyword_3; }

		//"file"
		public Keyword getFileKeyword_4() { return cFileKeyword_4; }

		//"text"
		public Keyword getTextKeyword_5() { return cTextKeyword_5; }

		//"title"     //MDD keywords
		public Keyword getTitleKeyword_6() { return cTitleKeyword_6; }

		//"max"
		public Keyword getMaxKeyword_7() { return cMaxKeyword_7; }

		//"when"
		public Keyword getWhenKeyword_8() { return cWhenKeyword_8; }

		//"member"
		public Keyword getMemberKeyword_9() { return cMemberKeyword_9; }

		//"end"
		public Keyword getEndKeyword_10() { return cEndKeyword_10; }

		//"object"
		public Keyword getObjectKeyword_11() { return cObjectKeyword_11; }

		//"date"     //HQL keywords
		public Keyword getDateKeyword_12() { return cDateKeyword_12; }
	}
	
	
	private DataDefinitionElements pDataDefinition;
	private DeclarationElements pDeclaration;
	private FieldDeclarationElements pFieldDeclaration;
	private ModifiersElements pModifiers;
	private FieldTypeElements pFieldType;
	private IntEnumElements pIntEnum;
	private CharEnumElements pCharEnum;
	private EnumValueElements pEnumValue;
	private CharTypeElements pCharType;
	private PointerElements pPointer;
	private SetTypeElements pSetType;
	private SubFieldDeclarationElements pSubFieldDeclaration;
	private TypeElements pType;
	private TitleDeclarationElements pTitleDeclaration;
	private TitleElements pTitle;
	private IncludeDeclarationElements pIncludeDeclaration;
	private TypeDeclarationElements pTypeDeclaration;
	private ValidationRuleDeclarationElements pValidationRuleDeclaration;
	private ComparisonValidationRuleDeclarationElements pComparisonValidationRuleDeclaration;
	private ComparisonExpressionElements pComparisonExpression;
	private ComparisonPartElements pComparisonPart;
	private UpperFunctionElements pUpperFunction;
	private LowerFunctionElements pLowerFunction;
	private OperatorElements pOperator;
	private DateConstantElements pDateConstant;
	private DateFunctionElements pDateFunction;
	private DateFunctionArgumentElements pDateFunctionArgument;
	private DateFunctionArgumentMemberElements pDateFunctionArgumentMember;
	private RangeValidationRuleDeclarationElements pRangeValidationRuleDeclaration;
	private RegexValidationRuleDeclarationElements pRegexValidationRuleDeclaration;
	private RangeElements pRange;
	private RangeBoundElements pRangeBound;
	private UniquenessValidationRuleDeclarationElements pUniquenessValidationRuleDeclaration;
	private ErrorMessageElements pErrorMessage;
	private NativeValidationRuleDeclarationElements pNativeValidationRuleDeclaration;
	private FunctionDeclarationElements pFunctionDeclaration;
	private FunctionArgumentDeclarationElements pFunctionArgumentDeclaration;
	private FunctionArgumentBodyElements pFunctionArgumentBody;
	private FunctionCallElements pFunctionCall;
	private FunctionArgumentsElements pFunctionArguments;
	private FunctionBodyElements pFunctionBody;
	private StatementElements pStatement;
	private UnionRuleElements pUnionRule;
	private QueryRuleElements pQueryRule;
	private SelectFromElements pSelectFrom;
	private SelectClauseElements pSelectClause;
	private NewExpressionElements pNewExpression;
	private SelectObjectElements pSelectObject;
	private FromClauseElements pFromClause;
	private FromJoinElements pFromJoin;
	private WithClauseElements pWithClause;
	private FromRangeElements pFromRange;
	private FromClassOrOuterQueryPathElements pFromClassOrOuterQueryPath;
	private InCollectionElementsDeclarationElements pInCollectionElementsDeclaration;
	private AsAliasElements pAsAlias;
	private PropertyFetchElements pPropertyFetch;
	private GroupByClauseElements pGroupByClause;
	private OrderByClauseElements pOrderByClause;
	private OrderElementElements pOrderElement;
	private AscendingOrDescendingElements pAscendingOrDescending;
	private HavingClauseElements pHavingClause;
	private WhereClauseElements pWhereClause;
	private SelectedPropertiesListElements pSelectedPropertiesList;
	private AliasedExpressionElements pAliasedExpression;
	private ExpressionElements pExpression;
	private LogicalOrExpressionElements pLogicalOrExpression;
	private LogicalAndExpressionElements pLogicalAndExpression;
	private NegatedExpressionElements pNegatedExpression;
	private EqualityExpressionElements pEqualityExpression;
	private RelationalExpressionElements pRelationalExpression;
	private LikeEscapeElements pLikeEscape;
	private BetweenListElements pBetweenList;
	private ConcatenationElements pConcatenation;
	private AdditiveExpressionElements pAdditiveExpression;
	private MultiplyExpressionElements pMultiplyExpression;
	private UnaryExpressionElements pUnaryExpression;
	private CaseExpressionElements pCaseExpression;
	private WhenClauseElements pWhenClause;
	private AltWhenClauseElements pAltWhenClause;
	private ElseClauseElements pElseClause;
	private QuantifiedExpressionElements pQuantifiedExpression;
	private AtomElements pAtom;
	private PrimaryExpressionElements pPrimaryExpression;
	private ExpressionOrVectorElements pExpressionOrVector;
	private VectorExprElements pVectorExpr;
	private IdentPrimaryElements pIdentPrimary;
	private AggregateElements pAggregate;
	private CollectionExprElements pCollectionExpr;
	private CompoundExprElements pCompoundExpr;
	private ExprListElements pExprList;
	private ConstantElements pConstant;
	private PathElements pPath;
	private IdentifierElements pIdentifier;
	private NumberElements pNumber;
	private SELECTElements pSELECT;
	private DISTINCTElements pDISTINCT;
	private NEWElements pNEW;
	private OBJECTElements pOBJECT;
	private FROMElements pFROM;
	private LEFTElements pLEFT;
	private RIGHTElements pRIGHT;
	private OUTERElements pOUTER;
	private FULLElements pFULL;
	private INNERElements pINNER;
	private JOINElements pJOIN;
	private FETCHElements pFETCH;
	private WITHElements pWITH;
	private INElements pIN;
	private CLASSElements pCLASS;
	private IN_CLASSElements pIN_CLASS;
	private ELEMENTSElements pELEMENTS;
	private IN_ELEMENTSElements pIN_ELEMENTS;
	private ASElements pAS;
	private PROPERTIESElements pPROPERTIES;
	private GROUP_BYElements pGROUP_BY;
	private ORDER_BYElements pORDER_BY;
	private BYElements pBY;
	private ASCElements pASC;
	private DESCElements pDESC;
	private HAVINGElements pHAVING;
	private WHEREElements pWHERE;
	private ORElements pOR;
	private ANDElements pAND;
	private NOTElements pNOT;
	private ISElements pIS;
	private BETWEENElements pBETWEEN;
	private LIKEElements pLIKE;
	private MEMBERElements pMEMBER;
	private OFElements pOF;
	private ESCAPEElements pESCAPE;
	private CASEElements pCASE;
	private ENDElements pEND;
	private WHENElements pWHEN;
	private THENElements pTHEN;
	private ELSEElements pELSE;
	private SOMEElements pSOME;
	private EXISTSElements pEXISTS;
	private ALLElements pALL;
	private ANYElements pANY;
	private SUMElements pSUM;
	private AVGElements pAVG;
	private MAXElements pMAX;
	private MINElements pMIN;
	private COUNTElements pCOUNT;
	private INDICESElements pINDICES;
	private TRAILINGElements pTRAILING;
	private LEADINGElements pLEADING;
	private BOTHElements pBOTH;
	private NULLElements pNULL;
	private TRUEElements pTRUE;
	private FALSEElements pFALSE;
	private EMPTYElements pEMPTY;
	private KeywordElements pKeyword;
	private TerminalRule tLINEBREAK;
	private TerminalRule tID;
	private TerminalRule tSIGNED_INT;
	private TerminalRule tHEX;
	private TerminalRule tINT;
	private TerminalRule tFIELDCOMMENT;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tWS;
	private TerminalRule tSTRING;
	
	private final GrammarProvider grammarProvider;

	@Inject
	public MDDGrammarAccess(GrammarProvider grammarProvider) {
		this.grammarProvider = grammarProvider;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	
	//dataDefinition:
	//  LINEBREAK* (d+=declaration FIELDCOMMENT? LINEBREAK*)+;
	public DataDefinitionElements getDataDefinitionAccess() {
		return (pDataDefinition != null) ? pDataDefinition : (pDataDefinition = new DataDefinitionElements());
	}
	
	public ParserRule getDataDefinitionRule() {
		return getDataDefinitionAccess().getRule();
	}

	//declaration:
	//  fieldDeclaration|titleDeclaration|typeDeclaration|includeDeclaration|
	//  validationRuleDeclaration|functionDeclaration|nativeValidationRuleDeclaration|
	//  subFieldDeclaration; 
	//
	//
	//    
	//    
	//    
	//     
	//    
	//    
	//    
	//  
	//   
	//
	/// *extendedDeclaration:
	//	declaration |
	//	 FIELDCOMMENT? LINEBREAK*;* /
	//
	//		
	///////// Field Declaration
	public DeclarationElements getDeclarationAccess() {
		return (pDeclaration != null) ? pDeclaration : (pDeclaration = new DeclarationElements());
	}
	
	public ParserRule getDeclarationRule() {
		return getDeclarationAccess().getRule();
	}

	//fieldDeclaration:
	//  name=( ID | keyword ) "=" (modifiers=modifiers typedef=fieldType)?; 
	//
	/// *extendedDeclaration:
	//	declaration |
	//	 FIELDCOMMENT? LINEBREAK*;* /
	//
	//		
	///////// Field Declaration
	public FieldDeclarationElements getFieldDeclarationAccess() {
		return (pFieldDeclaration != null) ? pFieldDeclaration : (pFieldDeclaration = new FieldDeclarationElements());
	}
	
	public ParserRule getFieldDeclarationRule() {
		return getFieldDeclarationAccess().getRule();
	}

	//modifiers:
	//  unique?="unique"? & fixed?="fixed"? & (notNull?="not" "null")? & (notEmpty?="not"
	//  "empty")?;
	public ModifiersElements getModifiersAccess() {
		return (pModifiers != null) ? pModifiers : (pModifiers = new ModifiersElements());
	}
	
	public ParserRule getModifiersRule() {
		return getModifiersAccess().getRule();
	}

	//fieldType:
	//  charType|charEnum|"set" charEnum|intEnum|"set" intEnum|{fieldType} type=( "int" |
	//  "real" | "boolean" | "text" | "binary" | "file" | "date" )|pointer|setType|typeDec=[
	//  typeDeclaration];
	public FieldTypeElements getFieldTypeAccess() {
		return (pFieldType != null) ? pFieldType : (pFieldType = new FieldTypeElements());
	}
	
	public ParserRule getFieldTypeRule() {
		return getFieldTypeAccess().getRule();
	}

	//intEnum:
	//  name="int" "{" values+=enumValue ("," values+=enumValue)* "}";
	public IntEnumElements getIntEnumAccess() {
		return (pIntEnum != null) ? pIntEnum : (pIntEnum = new IntEnumElements());
	}
	
	public ParserRule getIntEnumRule() {
		return getIntEnumAccess().getRule();
	}

	//charEnum:
	//  name="char" "{" values+=STRING ("," values+=STRING)* "}"; 
	//
	//
	//	           
	//		
	//
	//   
	/// * New syntax to be introduced in mak 0.9
	//enumType:
	//  'enum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}'); 
	//
	//setEnumType:
	//  'setEnum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}');* /
	public CharEnumElements getCharEnumAccess() {
		return (pCharEnum != null) ? pCharEnum : (pCharEnum = new CharEnumElements());
	}
	
	public ParserRule getCharEnumRule() {
		return getCharEnumAccess().getRule();
	}

	//enumValue:
	//  name=STRING "=" value=( INT | SIGNED_INT ) "deprecated"?; 	
	//
	//   
	/// * New syntax to be introduced in mak 0.9
	//enumType:
	//  'enum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}'); 
	//
	//setEnumType:
	//  'setEnum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}');* /
	public EnumValueElements getEnumValueAccess() {
		return (pEnumValue != null) ? pEnumValue : (pEnumValue = new EnumValueElements());
	}
	
	public ParserRule getEnumValueRule() {
		return getEnumValueAccess().getRule();
	}

	//charType:
	//  {charType} "char" ("[" length=INT? "]")?;
	public CharTypeElements getCharTypeAccess() {
		return (pCharType != null) ? pCharType : (pCharType = new CharTypeElements());
	}
	
	public ParserRule getCharTypeRule() {
		return getCharTypeAccess().getRule();
	}

	//pointer:
	//  {pointer} "ptr" type=type?;
	public PointerElements getPointerAccess() {
		return (pPointer != null) ? pPointer : (pPointer = new PointerElements());
	}
	
	public ParserRule getPointerRule() {
		return getPointerAccess().getRule();
	}

	//setType:
	//  {setType} "set" type=type?;
	public SetTypeElements getSetTypeAccess() {
		return (pSetType != null) ? pSetType : (pSetType = new SetTypeElements());
	}
	
	public ParserRule getSetTypeRule() {
		return getSetTypeAccess().getRule();
	}

	//subFieldDeclaration:
	//  subFieldOf=[fieldDeclaration] "->" d=declaration; 
	//
	//
	//	        
	//
	//
	////TODO: add keyword
	public SubFieldDeclarationElements getSubFieldDeclarationAccess() {
		return (pSubFieldDeclaration != null) ? pSubFieldDeclaration : (pSubFieldDeclaration = new SubFieldDeclarationElements());
	}
	
	public ParserRule getSubFieldDeclarationRule() {
		return getSubFieldDeclarationAccess().getRule();
	}

	//type returns ecore::EString:
	//  (ID|keyword) (("."|"->") (ID|keyword))*; 
	//
	//
	////TODO: add keyword
	//      
	//
	//
	//
	//// !title = name
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//titleDeclaration:
	//  "!" "title" "=" title=title; 
	//
	//
	//
	//// !title = name
	public TitleDeclarationElements getTitleDeclarationAccess() {
		return (pTitleDeclaration != null) ? pTitleDeclaration : (pTitleDeclaration = new TitleDeclarationElements());
	}
	
	public ParserRule getTitleDeclarationRule() {
		return getTitleDeclarationAccess().getRule();
	}

	//title:
	//  name=type|functionCall; 
	//
	//       
	//
	//
	//// !include = general.Address
	public TitleElements getTitleAccess() {
		return (pTitle != null) ? pTitle : (pTitle = new TitleElements());
	}
	
	public ParserRule getTitleRule() {
		return getTitleAccess().getRule();
	}

	//includeDeclaration:
	//  "!" "include" "=" importedNamespace=type; 
	//
	//
	//// !include = general.Address
	//
	//          
	//
	//// !type.genDef = ...
	public IncludeDeclarationElements getIncludeDeclarationAccess() {
		return (pIncludeDeclaration != null) ? pIncludeDeclaration : (pIncludeDeclaration = new IncludeDeclarationElements());
	}
	
	public ParserRule getIncludeDeclarationRule() {
		return getIncludeDeclarationAccess().getRule();
	}

	//typeDeclaration:
	//  "!" "type" "." name=ID "=" fieldType=fieldType;   
	//
	//// !type.genDef = ...
	//
	//                     
	//
	/////// Validation Rules
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return (pTypeDeclaration != null) ? pTypeDeclaration : (pTypeDeclaration = new TypeDeclarationElements());
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}

	//validationRuleDeclaration:
	//  (rangeValidationRuleDeclaration|uniquenessValidationRuleDeclaration|
	//  comparisonValidationRuleDeclaration|regexValidationRuleDeclaration) errorMessage=
	//  errorMessage; 
	//
	/////// Validation Rules
	public ValidationRuleDeclarationElements getValidationRuleDeclarationAccess() {
		return (pValidationRuleDeclaration != null) ? pValidationRuleDeclaration : (pValidationRuleDeclaration = new ValidationRuleDeclarationElements());
	}
	
	public ParserRule getValidationRuleDeclarationRule() {
		return getValidationRuleDeclarationAccess().getRule();
	}

	//comparisonValidationRuleDeclaration:
	//  name="compare" args=functionArguments "{" comparisonExp=comparisonExpression "}"; 
	//
	//
	//	          
	//	
	//
	////////// COMPARISON EXPRESSION
	public ComparisonValidationRuleDeclarationElements getComparisonValidationRuleDeclarationAccess() {
		return (pComparisonValidationRuleDeclaration != null) ? pComparisonValidationRuleDeclaration : (pComparisonValidationRuleDeclaration = new ComparisonValidationRuleDeclarationElements());
	}
	
	public ParserRule getComparisonValidationRuleDeclarationRule() {
		return getComparisonValidationRuleDeclarationAccess().getRule();
	}

	//comparisonExpression:
	//  lhs=comparisonPart o=operator rhs=comparisonPart; 
	//
	////////// COMPARISON EXPRESSION
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return (pComparisonExpression != null) ? pComparisonExpression : (pComparisonExpression = new ComparisonExpressionElements());
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}

	//comparisonPart:
	//  t=type|n=INT|df=dateFunction|u=upperFunction|l=lowerFunction|d=dateConstant; 
	//	
	//
	//	  
	//	    //number
	//	   
	//	  
	//	  
	//	  
	//	
	//
	//// here we pass only the type name of the argument, with the function as type
	public ComparisonPartElements getComparisonPartAccess() {
		return (pComparisonPart != null) ? pComparisonPart : (pComparisonPart = new ComparisonPartElements());
	}
	
	public ParserRule getComparisonPartRule() {
		return getComparisonPartAccess().getRule();
	}

	//upperFunction:
	//  "upper" "(" t=type ")"; 
	//
	//// here we pass only the type name of the argument, with the function as type
	//
	//	        
	//	
	//
	//// here we pass only the type name of the argument, with the function as type
	public UpperFunctionElements getUpperFunctionAccess() {
		return (pUpperFunction != null) ? pUpperFunction : (pUpperFunction = new UpperFunctionElements());
	}
	
	public ParserRule getUpperFunctionRule() {
		return getUpperFunctionAccess().getRule();
	}

	//lowerFunction:
	//  "lower" "(" t=type ")"; 
	//
	//// here we pass only the type name of the argument, with the function as type
	public LowerFunctionElements getLowerFunctionAccess() {
		return (pLowerFunction != null) ? pLowerFunction : (pLowerFunction = new LowerFunctionElements());
	}
	
	public ParserRule getLowerFunctionRule() {
		return getLowerFunctionAccess().getRule();
	}

	//operator returns ecore::EString:
	//  "="|"<"|">"|"<="|">="|"!="|"^="|"<>"|"like";
	public OperatorElements getOperatorAccess() {
		return (pOperator != null) ? pOperator : (pOperator = new OperatorElements());
	}
	
	public ParserRule getOperatorRule() {
		return getOperatorAccess().getRule();
	}

	//dateConstant returns ecore::EString:
	//  "$now"|"$today";
	public DateConstantElements getDateConstantAccess() {
		return (pDateConstant != null) ? pDateConstant : (pDateConstant = new DateConstantElements());
	}
	
	public ParserRule getDateConstantRule() {
		return getDateConstantAccess().getRule();
	}

	//dateFunction returns ecore::EString:
	//  "date" "(" dateFunctionArgument ("," dateFunctionArgument)* ")";
	public DateFunctionElements getDateFunctionAccess() {
		return (pDateFunction != null) ? pDateFunction : (pDateFunction = new DateFunctionElements());
	}
	
	public ParserRule getDateFunctionRule() {
		return getDateFunctionAccess().getRule();
	}

	//dateFunctionArgument returns ecore::EString:
	//  dateFunctionArgumentMember (("+"|"-") dateFunctionArgumentMember)?;
	public DateFunctionArgumentElements getDateFunctionArgumentAccess() {
		return (pDateFunctionArgument != null) ? pDateFunctionArgument : (pDateFunctionArgument = new DateFunctionArgumentElements());
	}
	
	public ParserRule getDateFunctionArgumentRule() {
		return getDateFunctionArgumentAccess().getRule();
	}

	//dateFunctionArgumentMember returns ecore::EString:
	//  INT|dateConstant; 
	//	
	//
	//	    //number
	//	   
	//	
	//
	//
	////////// RANGE DEFINITION
	public DateFunctionArgumentMemberElements getDateFunctionArgumentMemberAccess() {
		return (pDateFunctionArgumentMember != null) ? pDateFunctionArgumentMember : (pDateFunctionArgumentMember = new DateFunctionArgumentMemberElements());
	}
	
	public ParserRule getDateFunctionArgumentMemberRule() {
		return getDateFunctionArgumentMemberAccess().getRule();
	}

	//rangeValidationRuleDeclaration:
	//  name=( "range" | "length" ) args=functionArguments "{" range=range "}"; 
	//
	//
	////////// RANGE DEFINITION
	public RangeValidationRuleDeclarationElements getRangeValidationRuleDeclarationAccess() {
		return (pRangeValidationRuleDeclaration != null) ? pRangeValidationRuleDeclaration : (pRangeValidationRuleDeclaration = new RangeValidationRuleDeclarationElements());
	}
	
	public ParserRule getRangeValidationRuleDeclarationRule() {
		return getRangeValidationRuleDeclarationAccess().getRule();
	}

	//regexValidationRuleDeclaration:
	//  name="matches" args=functionArguments "{" exp=STRING "}"; 
	//	
	//
	//	          
	//	
	//
	//// name%length = [1..?]
	//// age%range = [18..99]
	public RegexValidationRuleDeclarationElements getRegexValidationRuleDeclarationAccess() {
		return (pRegexValidationRuleDeclaration != null) ? pRegexValidationRuleDeclaration : (pRegexValidationRuleDeclaration = new RegexValidationRuleDeclarationElements());
	}
	
	public ParserRule getRegexValidationRuleDeclarationRule() {
		return getRegexValidationRuleDeclarationAccess().getRule();
	}

	//range:
	//  f=rangeBound ".." t=rangeBound; 
	//
	//// name%length = [1..?]
	//// age%range = [18..99]
	//
	//     
	//            
	//    
	//
	//// [1..?] [?..5]
	public RangeElements getRangeAccess() {
		return (pRange != null) ? pRange : (pRange = new RangeElements());
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}

	//rangeBound returns ecore::EString:
	//  INT|"?"; 
	//
	//// [1..?] [?..5]
	//
	//          
	//    
	//
	//// unique(field1, field2) : "These need to be unique"
	public RangeBoundElements getRangeBoundAccess() {
		return (pRangeBound != null) ? pRangeBound : (pRangeBound = new RangeBoundElements());
	}
	
	public ParserRule getRangeBoundRule() {
		return getRangeBoundAccess().getRule();
	}

	//uniquenessValidationRuleDeclaration:
	//  name="unique" args=functionArguments; 
	//
	//// unique(field1, field2) : "These need to be unique"
	public UniquenessValidationRuleDeclarationElements getUniquenessValidationRuleDeclarationAccess() {
		return (pUniquenessValidationRuleDeclaration != null) ? pUniquenessValidationRuleDeclaration : (pUniquenessValidationRuleDeclaration = new UniquenessValidationRuleDeclarationElements());
	}
	
	public ParserRule getUniquenessValidationRuleDeclarationRule() {
		return getUniquenessValidationRuleDeclarationAccess().getRule();
	}

	//errorMessage:
	//  ":" message=STRING;
	public ErrorMessageElements getErrorMessageAccess() {
		return (pErrorMessage != null) ? pErrorMessage : (pErrorMessage = new ErrorMessageElements());
	}
	
	public ParserRule getErrorMessageRule() {
		return getErrorMessageAccess().getRule();
	}

	//nativeValidationRuleDeclaration:
	//  field=[fieldDeclaration] "." type=( "unique" | "notNull" | "NaN" | "notEmpty" | "notInt" |
	//  "notReal" | "notBoolean" ) "=" message=STRING; 
	//
	//
	//        
	//      
	//        
	//        
	//        
	//        
	//        
	//        
	//        
	//      
	//      
	//      
	//    
	//
	//
	/////// Functions
	public NativeValidationRuleDeclarationElements getNativeValidationRuleDeclarationAccess() {
		return (pNativeValidationRuleDeclaration != null) ? pNativeValidationRuleDeclaration : (pNativeValidationRuleDeclaration = new NativeValidationRuleDeclarationElements());
	}
	
	public ParserRule getNativeValidationRuleDeclarationRule() {
		return getNativeValidationRuleDeclarationAccess().getRule();
	}

	//functionDeclaration:
	//  (b=ID "%")? name=ID arg=functionArgumentDeclaration body=functionBody m=errorMessage?
	//; 
	//
	//
	/////// Functions
	public FunctionDeclarationElements getFunctionDeclarationAccess() {
		return (pFunctionDeclaration != null) ? pFunctionDeclaration : (pFunctionDeclaration = new FunctionDeclarationElements());
	}
	
	public ParserRule getFunctionDeclarationRule() {
		return getFunctionDeclarationAccess().getRule();
	}

	//functionArgumentDeclaration:
	//  {functionArgumentDeclaration} "(" f+=functionArgumentBody? ("," f+=
	//  functionArgumentBody)* ")"; 
	//  
	//
	//          
	//
	//// TODO: fix this so that function label can show param type instead of the name
	//// ugly fix until the syntax change
	public FunctionArgumentDeclarationElements getFunctionArgumentDeclarationAccess() {
		return (pFunctionArgumentDeclaration != null) ? pFunctionArgumentDeclaration : (pFunctionArgumentDeclaration = new FunctionArgumentDeclarationElements());
	}
	
	public ParserRule getFunctionArgumentDeclarationRule() {
		return getFunctionArgumentDeclarationAccess().getRule();
	}

	//functionArgumentBody:
	//  (charType|intEnum|"set" intEnum|charEnum|"set" charEnum|"int"|"real"|"boolean"|
	//  "text"|"binary"|"file"|"date"|"ptr" type|"set" type) name=( ID | keyword ); 
	//
	//// TODO: fix this so that function label can show param type instead of the name
	//// ugly fix until the syntax change
	public FunctionArgumentBodyElements getFunctionArgumentBodyAccess() {
		return (pFunctionArgumentBody != null) ? pFunctionArgumentBody : (pFunctionArgumentBody = new FunctionArgumentBodyElements());
	}
	
	public ParserRule getFunctionArgumentBodyRule() {
		return getFunctionArgumentBodyAccess().getRule();
	}

	//functionCall:
	//  name=ID f=functionArguments;
	public FunctionCallElements getFunctionCallAccess() {
		return (pFunctionCall != null) ? pFunctionCall : (pFunctionCall = new FunctionCallElements());
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}

	//functionArguments:
	//  {functionArguments} "(" (a+=type ("," a+=type)*)? ")";
	public FunctionArgumentsElements getFunctionArgumentsAccess() {
		return (pFunctionArguments != null) ? pFunctionArguments : (pFunctionArguments = new FunctionArgumentsElements());
	}
	
	public ParserRule getFunctionArgumentsRule() {
		return getFunctionArgumentsAccess().getRule();
	}

	//functionBody:
	//  "{" (s=statement|e=expression) "}"; 
	//  
	//
	//           
	//  
	//
	//
	/////// HQL stuff
	public FunctionBodyElements getFunctionBodyAccess() {
		return (pFunctionBody != null) ? pFunctionBody : (pFunctionBody = new FunctionBodyElements());
	}
	
	public ParserRule getFunctionBodyRule() {
		return getFunctionBodyAccess().getRule();
	}

	//statement:
	//  queryRule; 
	//
	//
	/////// HQL stuff
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//unionRule:
	//  q+=queryRule ("union" q+=queryRule)*; 
	//
	//
	//
	//	      
	//	
	//
	////## query:
	////##     [selectClause] fromClause [whereClause] [groupByClause] [havingClause] [orderByClause];
	public UnionRuleElements getUnionRuleAccess() {
		return (pUnionRule != null) ? pUnionRule : (pUnionRule = new UnionRuleElements());
	}
	
	public ParserRule getUnionRuleRule() {
		return getUnionRuleAccess().getRule();
	}

	//queryRule:
	//  selectFrom where=whereClause? groupBy=groupByClause? orderBy=orderByClause?; 
	//
	////## query:
	////##     [selectClause] fromClause [whereClause] [groupByClause] [havingClause] [orderByClause];
	public QueryRuleElements getQueryRuleAccess() {
		return (pQueryRule != null) ? pQueryRule : (pQueryRule = new QueryRuleElements());
	}
	
	public ParserRule getQueryRuleRule() {
		return getQueryRuleAccess().getRule();
	}

	//selectFrom:
	//  {selectFrom} s=selectClause? from=fromClause?; 
	//
	//
	//	        
	//	
	//
	////## selectClause:
	////##     SELECT DISTINCT? selectedPropertiesList | ( NEW className OPEN selectedPropertiesList CLOSE );
	public SelectFromElements getSelectFromAccess() {
		return (pSelectFrom != null) ? pSelectFrom : (pSelectFrom = new SelectFromElements());
	}
	
	public ParserRule getSelectFromRule() {
		return getSelectFromAccess().getRule();
	}

	//selectClause:
	//  {selectCause} SELECT DISTINCT? (s=selectedPropertiesList|n=newExpression|
	//  selectObject); 
	//
	////## selectClause:
	////##     SELECT DISTINCT? selectedPropertiesList | ( NEW className OPEN selectedPropertiesList CLOSE );
	public SelectClauseElements getSelectClauseAccess() {
		return (pSelectClause != null) ? pSelectClause : (pSelectClause = new SelectClauseElements());
	}
	
	public ParserRule getSelectClauseRule() {
		return getSelectClauseAccess().getRule();
	}

	//newExpression:
	//  NEW p=path "(" s=selectedPropertiesList ")";
	public NewExpressionElements getNewExpressionAccess() {
		return (pNewExpression != null) ? pNewExpression : (pNewExpression = new NewExpressionElements());
	}
	
	public ParserRule getNewExpressionRule() {
		return getNewExpressionAccess().getRule();
	}

	//selectObject returns ecore::EString:
	//  OBJECT "(" identifier ")"; 
	//
	//
	//           
	//   
	//
	////## fromClause:
	////##    FROM className AS? identifier (  ( ',' className AS? identifier ) | ( joinType path AS? identifier ) )*;
	//
	//// NOTE: This *must* begin with the "FROM" token, otherwise the sub-query rule will be ambiguous
	//// with the expression rule.
	//// Also note: after a comma weak keywords are allowed and should be treated as identifiers.
	public SelectObjectElements getSelectObjectAccess() {
		return (pSelectObject != null) ? pSelectObject : (pSelectObject = new SelectObjectElements());
	}
	
	public ParserRule getSelectObjectRule() {
		return getSelectObjectAccess().getRule();
	}

	//fromClause:
	//  FROM fromRange+=fromRange (fromJoin+=fromJoin|"," fromRange+=fromRange)*; 
	//
	////## fromClause:
	////##    FROM className AS? identifier (  ( ',' className AS? identifier ) | ( joinType path AS? identifier ) )*;
	//
	//// NOTE: This *must* begin with the "FROM" token, otherwise the sub-query rule will be ambiguous
	//// with the expression rule.
	//// Also note: after a comma weak keywords are allowed and should be treated as identifiers.
	//
	//
	//	                
	//	
	//
	//
	////## joinType:
	////##     ( ( 'left'|'right' 'outer'? ) | 'full' | 'inner' )? JOIN FETCH?;
	public FromClauseElements getFromClauseAccess() {
		return (pFromClause != null) ? pFromClause : (pFromClause = new FromClauseElements());
	}
	
	public ParserRule getFromClauseRule() {
		return getFromClauseAccess().getRule();
	}

	//fromJoin:
	//  ((LEFT|RIGHT) OUTER?|FULL|INNER)? JOIN FETCH? fromClassOrOuterQueryPath w=withClause?
	//; 
	//
	//
	////## joinType:
	////##     ( ( 'left'|'right' 'outer'? ) | 'full' | 'inner' )? JOIN FETCH?;
	public FromJoinElements getFromJoinAccess() {
		return (pFromJoin != null) ? pFromJoin : (pFromJoin = new FromJoinElements());
	}
	
	public ParserRule getFromJoinRule() {
		return getFromJoinAccess().getRule();
	}

	//withClause:
	//  WITH e=expression;
	public WithClauseElements getWithClauseAccess() {
		return (pWithClause != null) ? pWithClause : (pWithClause = new WithClauseElements());
	}
	
	public ParserRule getWithClauseRule() {
		return getWithClauseAccess().getRule();
	}

	//fromRange:
	//  fromClassOrOuterQueryPath|alias=identifier IN_CLASS p=path|IN "(" p=path ")" alias=
	//  identifier|inCollectionElementsDeclaration;
	public FromRangeElements getFromRangeAccess() {
		return (pFromRange != null) ? pFromRange : (pFromRange = new FromRangeElements());
	}
	
	public ParserRule getFromRangeRule() {
		return getFromRangeAccess().getRule();
	}

	//fromClassOrOuterQueryPath:
	//  {fromClassOrOuterQueryPath} path asAlias=asAlias? propertyFetch=propertyFetch?;
	public FromClassOrOuterQueryPathElements getFromClassOrOuterQueryPathAccess() {
		return (pFromClassOrOuterQueryPath != null) ? pFromClassOrOuterQueryPath : (pFromClassOrOuterQueryPath = new FromClassOrOuterQueryPathElements());
	}
	
	public ParserRule getFromClassOrOuterQueryPathRule() {
		return getFromClassOrOuterQueryPathAccess().getRule();
	}

	//inCollectionElementsDeclaration:
	//  alias=identifier IN_ELEMENTS "(" p=path ")"; 
	//
	//
	//	           
	//    
	//
	//// Alias rule - Parses the optional 'as' token and forces an AST identifier node.
	public InCollectionElementsDeclarationElements getInCollectionElementsDeclarationAccess() {
		return (pInCollectionElementsDeclaration != null) ? pInCollectionElementsDeclaration : (pInCollectionElementsDeclaration = new InCollectionElementsDeclarationElements());
	}
	
	public ParserRule getInCollectionElementsDeclarationRule() {
		return getInCollectionElementsDeclarationAccess().getRule();
	}

	//asAlias:
	//  AS? alias=identifier; 
	//
	//// Alias rule - Parses the optional 'as' token and forces an AST identifier node.
	public AsAliasElements getAsAliasAccess() {
		return (pAsAlias != null) ? pAsAlias : (pAsAlias = new AsAliasElements());
	}
	
	public ParserRule getAsAliasRule() {
		return getAsAliasAccess().getRule();
	}

	//propertyFetch returns ecore::EString:
	//  FETCH ALL PROPERTIES; 
	//    
	//
	//	      
	//	
	//
	////## groupByClause:
	////##     GROUP_BY path ( ',' path )*;
	public PropertyFetchElements getPropertyFetchAccess() {
		return (pPropertyFetch != null) ? pPropertyFetch : (pPropertyFetch = new PropertyFetchElements());
	}
	
	public ParserRule getPropertyFetchRule() {
		return getPropertyFetchAccess().getRule();
	}

	//groupByClause:
	//  GROUP_BY e+=expression ("," e+=expression)* h=havingClause?; 
	//
	////## groupByClause:
	////##     GROUP_BY path ( ',' path )*;
	//
	//
	//	            
	//		
	//	
	//
	////## orderByClause:
	////##     ORDER_BY selectedPropertiesList;
	public GroupByClauseElements getGroupByClauseAccess() {
		return (pGroupByClause != null) ? pGroupByClause : (pGroupByClause = new GroupByClauseElements());
	}
	
	public ParserRule getGroupByClauseRule() {
		return getGroupByClauseAccess().getRule();
	}

	//orderByClause:
	//  ORDER_BY o+=orderElement ("," o+=orderElement)*; 
	//
	////## orderByClause:
	////##     ORDER_BY selectedPropertiesList;
	public OrderByClauseElements getOrderByClauseAccess() {
		return (pOrderByClause != null) ? pOrderByClause : (pOrderByClause = new OrderByClauseElements());
	}
	
	public ParserRule getOrderByClauseRule() {
		return getOrderByClauseAccess().getRule();
	}

	//orderElement:
	//  expression ascendingOrDescending?;
	public OrderElementElements getOrderElementAccess() {
		return (pOrderElement != null) ? pOrderElement : (pOrderElement = new OrderElementElements());
	}
	
	public ParserRule getOrderElementRule() {
		return getOrderElementAccess().getRule();
	}

	//ascendingOrDescending returns ecore::EString:
	//  ASC|DESC; 
	//
	//
	//	  	
	//	  	
	//	
	//
	////## havingClause:
	////##     HAVING logicalExpression;
	public AscendingOrDescendingElements getAscendingOrDescendingAccess() {
		return (pAscendingOrDescending != null) ? pAscendingOrDescending : (pAscendingOrDescending = new AscendingOrDescendingElements());
	}
	
	public ParserRule getAscendingOrDescendingRule() {
		return getAscendingOrDescendingAccess().getRule();
	}

	//havingClause:
	//  HAVING e=expression; 
	//
	////## havingClause:
	////##     HAVING logicalExpression;
	//
	//
	//	    
	//	
	//
	////## whereClause:
	////##     WHERE logicalExpression;
	public HavingClauseElements getHavingClauseAccess() {
		return (pHavingClause != null) ? pHavingClause : (pHavingClause = new HavingClauseElements());
	}
	
	public ParserRule getHavingClauseRule() {
		return getHavingClauseAccess().getRule();
	}

	//whereClause:
	//  WHERE e=expression; 
	//
	////## whereClause:
	////##     WHERE logicalExpression;
	//
	//
	//	    
	//	
	//
	////## selectedPropertiesList:
	////##     ( path | aggregate ) ( ',' path | aggregate )*;
	public WhereClauseElements getWhereClauseAccess() {
		return (pWhereClause != null) ? pWhereClause : (pWhereClause = new WhereClauseElements());
	}
	
	public ParserRule getWhereClauseRule() {
		return getWhereClauseAccess().getRule();
	}

	//selectedPropertiesList:
	//  a+=aliasedExpression ("," a+=aliasedExpression)*; 
	//
	////## selectedPropertiesList:
	////##     ( path | aggregate ) ( ',' path | aggregate )*;
	public SelectedPropertiesListElements getSelectedPropertiesListAccess() {
		return (pSelectedPropertiesList != null) ? pSelectedPropertiesList : (pSelectedPropertiesList = new SelectedPropertiesListElements());
	}
	
	public ParserRule getSelectedPropertiesListRule() {
		return getSelectedPropertiesListAccess().getRule();
	}

	//aliasedExpression:
	//  expression (AS id=identifier)?; 
	//	
	//
	//	          
	//	
	//
	//// expressions
	//// Note that most of these expressions follow the pattern
	////   thisLevelExpression :
	////       nextHigherPrecedenceExpression
	////           (OPERATOR nextHigherPrecedenceExpression)*
	//// which is a standard recursive definition for a parsing an expression.
	////
	//// Operator precedence in HQL
	//// lowest  --> ( 7)  OR
	////             ( 6)  AND, NOT
	////             ( 5)  equality: ==, <>, =, is
	////             ( 4)  relational: <, <=, >, >=,
	////                   LIKE, NOT LIKE, BETWEEN, NOT BETWEEN, IN, NOT IN
	////             ( 3)  addition and subtraction: +(binary) -(binary)
	////             ( 2)  multiplication: * / %, concatenate: ||
	//// highest --> ( 1)  +(unary) -(unary)
	////                   []   () (method call)  . (dot -- identifier qualification)
	////                   aggregate function
	////                   ()  (explicit parenthesis)
	////
	//// Note that the above precedence levels map to the rules below...
	//// Once you have a precedence chart, writing the appropriate rules as below
	//// is usually very straightfoward
	//
	//// Main expression rule
	public AliasedExpressionElements getAliasedExpressionAccess() {
		return (pAliasedExpression != null) ? pAliasedExpression : (pAliasedExpression = new AliasedExpressionElements());
	}
	
	public ParserRule getAliasedExpressionRule() {
		return getAliasedExpressionAccess().getRule();
	}

	//expression:
	//  logicalOrExpression; 
	//
	//// expressions
	//// Note that most of these expressions follow the pattern
	////   thisLevelExpression :
	////       nextHigherPrecedenceExpression
	////           (OPERATOR nextHigherPrecedenceExpression)*
	//// which is a standard recursive definition for a parsing an expression.
	////
	//// Operator precedence in HQL
	//// lowest  --> ( 7)  OR
	////             ( 6)  AND, NOT
	////             ( 5)  equality: ==, <>, =, is
	////             ( 4)  relational: <, <=, >, >=,
	////                   LIKE, NOT LIKE, BETWEEN, NOT BETWEEN, IN, NOT IN
	////             ( 3)  addition and subtraction: +(binary) -(binary)
	////             ( 2)  multiplication: * / %, concatenate: ||
	//// highest --> ( 1)  +(unary) -(unary)
	////                   []   () (method call)  . (dot -- identifier qualification)
	////                   aggregate function
	////                   ()  (explicit parenthesis)
	////
	//// Note that the above precedence levels map to the rules below...
	//// Once you have a precedence chart, writing the appropriate rules as below
	//// is usually very straightfoward
	//
	//// Main expression rule
	//
	//	  
	//	
	//
	//// level 7 - OR
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//logicalOrExpression:
	//  l+=logicalAndExpression (OR l+=logicalAndExpression)*; 
	//
	//// level 7 - OR
	//
	//	          
	//	
	//
	//// level 6 - AND, NOT
	public LogicalOrExpressionElements getLogicalOrExpressionAccess() {
		return (pLogicalOrExpression != null) ? pLogicalOrExpression : (pLogicalOrExpression = new LogicalOrExpressionElements());
	}
	
	public ParserRule getLogicalOrExpressionRule() {
		return getLogicalOrExpressionAccess().getRule();
	}

	//logicalAndExpression:
	//  n+=negatedExpression (AND n+=negatedExpression)*; 
	//
	//// level 6 - AND, NOT
	//
	//	          
	//	
	//
	//// NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
	//// negated, if possible.   Expressions without a NOT parent are passed through.
	public LogicalAndExpressionElements getLogicalAndExpressionAccess() {
		return (pLogicalAndExpression != null) ? pLogicalAndExpression : (pLogicalAndExpression = new LogicalAndExpressionElements());
	}
	
	public ParserRule getLogicalAndExpressionRule() {
		return getLogicalAndExpressionAccess().getRule();
	}

	//negatedExpression:
	//  NOT n=negatedExpression|equalityExpression; 
	//
	//// NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
	//// negated, if possible.   Expressions without a NOT parent are passed through.
	//
	// // Weak keywords can appear in an expression, so look ahead.
	//	      
	//	   
	//	
	//
	////## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
	//
	//// level 5 - EQ, NE
	public NegatedExpressionElements getNegatedExpressionAccess() {
		return (pNegatedExpression != null) ? pNegatedExpression : (pNegatedExpression = new NegatedExpressionElements());
	}
	
	public ParserRule getNegatedExpressionRule() {
		return getNegatedExpressionAccess().getRule();
	}

	//equalityExpression:
	//  r+=relationalExpression (("="|IS NOT?|"!="|"<>") r+=relationalExpression)*; 
	//
	////## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
	//
	//// level 5 - EQ, NE
	//
	//	    
	//		  
	//		  	     
	//		  
	//		  	
	//		   
	//	
	//
	//// level 4 - LT, GT, LE, GE, LIKE, NOT LIKE, BETWEEN, NOT BETWEEN
	//// NOTE: The NOT prefix for LIKE and BETWEEN will be represented in the
	//// token type.  When traversing the AST, use the token type, and not the
	//// token text to interpret the semantics of these nodes.
	public EqualityExpressionElements getEqualityExpressionAccess() {
		return (pEqualityExpression != null) ? pEqualityExpression : (pEqualityExpression = new EqualityExpressionElements());
	}
	
	public ParserRule getEqualityExpressionRule() {
		return getEqualityExpressionAccess().getRule();
	}

	//relationalExpression:
	//  concatenation ((("<"|">"|"<="|">=") a+=additiveExpression)*|NOT? (IN i=compoundExpr|
	//  BETWEEN b=betweenList|LIKE c=concatenation l=likeEscape|MEMBER OF? p=path)); 
	//
	//// level 4 - LT, GT, LE, GE, LIKE, NOT LIKE, BETWEEN, NOT BETWEEN
	//// NOTE: The NOT prefix for LIKE and BETWEEN will be represented in the
	//// token type.  When traversing the AST, use the token type, and not the
	//// token text to interpret the semantics of these nodes.
	//
	//	    
	//		                          
	//		// Disable node production for the optional 'not'.
	//		     
	//			// Represent the optional NOT prefix using the token type by
	//			 // testing 'n' and setting the token type accordingly.
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return (pRelationalExpression != null) ? pRelationalExpression : (pRelationalExpression = new RelationalExpressionElements());
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}

	//likeEscape:
	//  {likeEscape} (ESCAPE c=concatenation)?;
	public LikeEscapeElements getLikeEscapeAccess() {
		return (pLikeEscape != null) ? pLikeEscape : (pLikeEscape = new LikeEscapeElements());
	}
	
	public ParserRule getLikeEscapeRule() {
		return getLikeEscapeAccess().getRule();
	}

	//betweenList:
	//  c+=concatenation AND c+=concatenation; 
	//
	//
	//	      
	//	
	//
	////level 4 - string concatenation
	public BetweenListElements getBetweenListAccess() {
		return (pBetweenList != null) ? pBetweenList : (pBetweenList = new BetweenListElements());
	}
	
	public ParserRule getBetweenListRule() {
		return getBetweenListAccess().getRule();
	}

	//concatenation:
	//  additiveExpression ("||" a+=additiveExpression ("||" a+=additiveExpression)*)?; 
	//
	////level 4 - string concatenation
	//
	//	   
	//	    
	//	  
	//	         
	//	  
	//	
	//
	//// level 3 - binary plus and minus
	public ConcatenationElements getConcatenationAccess() {
		return (pConcatenation != null) ? pConcatenation : (pConcatenation = new ConcatenationElements());
	}
	
	public ParserRule getConcatenationRule() {
		return getConcatenationAccess().getRule();
	}

	//additiveExpression:
	//  m+=multiplyExpression (("+"|"-") m+=multiplyExpression)*; 
	//
	//// level 3 - binary plus and minus
	//
	//	                  
	//	
	//
	//// level 2 - binary multiply and divide
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return (pAdditiveExpression != null) ? pAdditiveExpression : (pAdditiveExpression = new AdditiveExpressionElements());
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}

	//multiplyExpression:
	//  u+=unaryExpression (("*"|"/") u+=unaryExpression)*; 
	//
	//// level 2 - binary multiply and divide
	//
	//	                  
	//	
	//	
	//// level 1 - unary minus, unary plus, not
	public MultiplyExpressionElements getMultiplyExpressionAccess() {
		return (pMultiplyExpression != null) ? pMultiplyExpression : (pMultiplyExpression = new MultiplyExpressionElements());
	}
	
	public ParserRule getMultiplyExpressionRule() {
		return getMultiplyExpressionAccess().getRule();
	}

	//unaryExpression:
	//  "-" u=unaryExpression|"+" u=unaryExpression|caseExpression|quantifiedExpression|
	//  atom; 
	//	
	//// level 1 - unary minus, unary plus, not
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return (pUnaryExpression != null) ? pUnaryExpression : (pUnaryExpression = new UnaryExpressionElements());
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	//caseExpression:
	//  CASE w+=whenClause+ e=elseClause? END|CASE u=unaryExpression a+=altWhenClause+ e=
	//  elseClause? END;
	public CaseExpressionElements getCaseExpressionAccess() {
		return (pCaseExpression != null) ? pCaseExpression : (pCaseExpression = new CaseExpressionElements());
	}
	
	public ParserRule getCaseExpressionRule() {
		return getCaseExpressionAccess().getRule();
	}

	//whenClause:
	//  WHEN whenExpr=expression THEN thenExpr=unaryExpression;
	public WhenClauseElements getWhenClauseAccess() {
		return (pWhenClause != null) ? pWhenClause : (pWhenClause = new WhenClauseElements());
	}
	
	public ParserRule getWhenClauseRule() {
		return getWhenClauseAccess().getRule();
	}

	//altWhenClause:
	//  WHEN w=unaryExpression THEN t=unaryExpression;
	public AltWhenClauseElements getAltWhenClauseAccess() {
		return (pAltWhenClause != null) ? pAltWhenClause : (pAltWhenClause = new AltWhenClauseElements());
	}
	
	public ParserRule getAltWhenClauseRule() {
		return getAltWhenClauseAccess().getRule();
	}

	//elseClause:
	//  ELSE u=unaryExpression;
	public ElseClauseElements getElseClauseAccess() {
		return (pElseClause != null) ? pElseClause : (pElseClause = new ElseClauseElements());
	}
	
	public ParserRule getElseClauseRule() {
		return getElseClauseAccess().getRule();
	}

	//quantifiedExpression:
	//  {quantifiedExpression} (SOME|EXISTS|ALL|ANY) (identifier|collectionExpr|"(" s=
	//  unionRule ")"); 
	//	
	//
	//	                   
	//	                    
	//	
	//
	//// level 0 - expression atom
	//// ident qualifier ('.' ident ), array index ( [ expr ] ),
	//// method call ( '.' ident '(' exprList ') )
	public QuantifiedExpressionElements getQuantifiedExpressionAccess() {
		return (pQuantifiedExpression != null) ? pQuantifiedExpression : (pQuantifiedExpression = new QuantifiedExpressionElements());
	}
	
	public ParserRule getQuantifiedExpressionRule() {
		return getQuantifiedExpressionAccess().getRule();
	}

	//atom:
	//  primaryExpression ("." identifier ("(" e+=exprList ")")?|"[" exp+=expression "]")*; 
	//
	//// level 0 - expression atom
	//// ident qualifier ('.' ident ), array index ( [ expr ] ),
	//// method call ( '.' ident '(' exprList ') )
	//
	//	   
	//			                
	//			     
	//		
	//	
	//
	//// level 0 - the basic element of an expression
	public AtomElements getAtomAccess() {
		return (pAtom != null) ? pAtom : (pAtom = new AtomElements());
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}

	//primaryExpression:
	//  {primaryExpression} ident=identPrimary ("." CLASS)?|constant|":" identifier|"(" (
	//  expressionOrVector|s=unionRule) ")"|"?" INT?; 
	//
	//// level 0 - the basic element of an expression
	//
	//	            
	//	    
	//	      
	//	            
	//	      
	//	
	//
	//// This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
	//// a parent VECTOR_EXPR node will be created for the list.
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//expressionOrVector:
	//  expression v=vectorExpr?; 
	//
	//// This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
	//// a parent VECTOR_EXPR node will be created for the list.
	public ExpressionOrVectorElements getExpressionOrVectorAccess() {
		return (pExpressionOrVector != null) ? pExpressionOrVector : (pExpressionOrVector = new ExpressionOrVectorElements());
	}
	
	public ParserRule getExpressionOrVectorRule() {
		return getExpressionOrVectorAccess().getRule();
	}

	//vectorExpr:
	//  "," e+=expression ("," e+=expression)*; 
	//
	//
	//	        
	//	
	//
	//// identifier, followed by member refs (dot ident), or method calls.
	//// NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
	//// the method looks a head to find keywords after '.' and turns them into identifiers.
	public VectorExprElements getVectorExprAccess() {
		return (pVectorExpr != null) ? pVectorExpr : (pVectorExpr = new VectorExprElements());
	}
	
	public ParserRule getVectorExprRule() {
		return getVectorExprAccess().getRule();
	}

	//identPrimary:
	//  {identPrimary} identifier ("." identifier|"." ELEMENTS|"." OBJECT)* ("(" e=exprList ")")
	//  ?|aggregate; 
	//
	//// identifier, followed by member refs (dot ident), or method calls.
	//// NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
	//// the method looks a head to find keywords after '.' and turns them into identifiers.
	//
	//	                           
	//		         
	//	 	 
	//	
	//
	////## aggregate:
	////##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
	//
	////## aggregateFunction:
	////##     COUNT | 'sum' | 'avg' | 'max' | 'min';
	public IdentPrimaryElements getIdentPrimaryAccess() {
		return (pIdentPrimary != null) ? pIdentPrimary : (pIdentPrimary = new IdentPrimaryElements());
	}
	
	public ParserRule getIdentPrimaryRule() {
		return getIdentPrimaryAccess().getRule();
	}

	//aggregate:
	//  {aggregate} (SUM|AVG|MAX|MIN) "(" a=additiveExpression ")"|COUNT "(" ("*"|(DISTINCT|
	//  ALL)? (path|collectionExpr)) ")"|collectionExpr; 
	//
	////## aggregate:
	////##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
	//
	////## aggregateFunction:
	////##     COUNT | 'sum' | 'avg' | 'max' | 'min';
	//
	//
	//	                           
	//	// Special case for count - It's 'parameters' can be keywords.
	//	                                         
	//	   
	//	
	//
	////## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN path CLOSE );
	public AggregateElements getAggregateAccess() {
		return (pAggregate != null) ? pAggregate : (pAggregate = new AggregateElements());
	}
	
	public ParserRule getAggregateRule() {
		return getAggregateAccess().getRule();
	}

	//collectionExpr returns ecore::EString:
	//  (ELEMENTS|INDICES) "(" path ")"; 
	//
	////## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN path CLOSE );
	//
	//
	//	            
	//	
	//                                           
	//// NOTE: compoundExpr can be a 'path' where the last token in the path is '.elements' or '.indicies'
	public CollectionExprElements getCollectionExprAccess() {
		return (pCollectionExpr != null) ? pCollectionExpr : (pCollectionExpr = new CollectionExprElements());
	}
	
	public ParserRule getCollectionExprRule() {
		return getCollectionExprAccess().getRule();
	}

	//compoundExpr:
	//  collectionExpr|path|"(" (e+=expression ("," e+=expression)*|s=unionRule) ")"; 
	//                                           
	//// NOTE: compoundExpr can be a 'path' where the last token in the path is '.elements' or '.indicies'
	public CompoundExprElements getCompoundExprAccess() {
		return (pCompoundExpr != null) ? pCompoundExpr : (pCompoundExpr = new CompoundExprElements());
	}
	
	public ParserRule getCompoundExprRule() {
		return getCompoundExprAccess().getRule();
	}

	//exprList:
	//  (TRAILING|LEADING|BOTH)? (e+=expression (("," e+=expression)+|FROM e+=expression|AS
	//  id=identifier)?|FROM e+=expression)?;
	public ExprListElements getExprListAccess() {
		return (pExprList != null) ? pExprList : (pExprList = new ExprListElements());
	}
	
	public ParserRule getExprListRule() {
		return getExprListAccess().getRule();
	}

	//constant returns ecore::EString:
	//  number|STRING|NULL|TRUE|FALSE|EMPTY; 
	//
	//
	//	   
	//	  
	//	  
	//	  
	//	  
	//	  
	//	
	//
	////## quantifiedExpression: 'exists' | ( expression 'in' ) | ( expression OP 'any' | 'some' ) collection;
	//
	////## compoundPath: path ( OPEN_BRACKET expression CLOSE_BRACKET ( '.' path )? )*;
	//
	////## path: identifier ( '.' identifier )*;
	public ConstantElements getConstantAccess() {
		return (pConstant != null) ? pConstant : (pConstant = new ConstantElements());
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}

	//path returns ecore::EString:
	//  identifier ("." identifier)*; 
	//
	////## quantifiedExpression: 'exists' | ( expression 'in' ) | ( expression OP 'any' | 'some' ) collection;
	//
	////## compoundPath: path ( OPEN_BRACKET expression CLOSE_BRACKET ( '.' path )? )*;
	//
	////## path: identifier ( '.' identifier )*;
	public PathElements getPathAccess() {
		return (pPath != null) ? pPath : (pPath = new PathElements());
	}
	
	public ParserRule getPathRule() {
		return getPathAccess().getRule();
	}

	//identifier returns ecore::EString:
	//  "$"? ID|"e"|"f"|"d"|"upper"|"lower"|"$now"|"$today"|"date"|"title"|"type"|
	//  "include"|"length"|END|WHEN|FROM|MEMBER; 
	//
	//
	//	     
	//	            // To allow number terminals as function arguments
	//	                                     //MDD keywords that can appear in Query Functions
	public IdentifierElements getIdentifierAccess() {
		return (pIdentifier != null) ? pIdentifier : (pIdentifier = new IdentifierElements());
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}

	//number returns ecore::EFloat:
	//  "." (INT ("e" ("+"|"-")? INT)? ("f"|"d")?)?|(HEX|INT|SIGNED_INT) ("l"|("." INT? ("e" ("+"
	//  |"-")? INT)? ("f"|"d")?|"e" ("+"|"-")? INT ("f"|"d")?|"f"|"d"))?;
	public NumberElements getNumberAccess() {
		return (pNumber != null) ? pNumber : (pNumber = new NumberElements());
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}

	//SELECT returns ecore::EString:
	//  "SELECT"|"Select"|"select";
	public SELECTElements getSELECTAccess() {
		return (pSELECT != null) ? pSELECT : (pSELECT = new SELECTElements());
	}
	
	public ParserRule getSELECTRule() {
		return getSELECTAccess().getRule();
	}

	//DISTINCT returns ecore::EString:
	//  "DISTINCT"|"Distinct"|"distinct";
	public DISTINCTElements getDISTINCTAccess() {
		return (pDISTINCT != null) ? pDISTINCT : (pDISTINCT = new DISTINCTElements());
	}
	
	public ParserRule getDISTINCTRule() {
		return getDISTINCTAccess().getRule();
	}

	//NEW returns ecore::EString:
	//  "NEW"|"New"|"new";
	public NEWElements getNEWAccess() {
		return (pNEW != null) ? pNEW : (pNEW = new NEWElements());
	}
	
	public ParserRule getNEWRule() {
		return getNEWAccess().getRule();
	}

	//OBJECT returns ecore::EString:
	//  "OBJECT"|"Object"|"object";
	public OBJECTElements getOBJECTAccess() {
		return (pOBJECT != null) ? pOBJECT : (pOBJECT = new OBJECTElements());
	}
	
	public ParserRule getOBJECTRule() {
		return getOBJECTAccess().getRule();
	}

	//FROM returns ecore::EString:
	//  "FROM"|"From"|"from";
	public FROMElements getFROMAccess() {
		return (pFROM != null) ? pFROM : (pFROM = new FROMElements());
	}
	
	public ParserRule getFROMRule() {
		return getFROMAccess().getRule();
	}

	//LEFT returns ecore::EString:
	//  "LEFT"|"Left"|"left";
	public LEFTElements getLEFTAccess() {
		return (pLEFT != null) ? pLEFT : (pLEFT = new LEFTElements());
	}
	
	public ParserRule getLEFTRule() {
		return getLEFTAccess().getRule();
	}

	//RIGHT returns ecore::EString:
	//  "RIGHT"|"Right"|"right";
	public RIGHTElements getRIGHTAccess() {
		return (pRIGHT != null) ? pRIGHT : (pRIGHT = new RIGHTElements());
	}
	
	public ParserRule getRIGHTRule() {
		return getRIGHTAccess().getRule();
	}

	//OUTER returns ecore::EString:
	//  "OUTER"|"Outer"|"outer";
	public OUTERElements getOUTERAccess() {
		return (pOUTER != null) ? pOUTER : (pOUTER = new OUTERElements());
	}
	
	public ParserRule getOUTERRule() {
		return getOUTERAccess().getRule();
	}

	//FULL returns ecore::EString:
	//  "FULL"|"Full"|"full";
	public FULLElements getFULLAccess() {
		return (pFULL != null) ? pFULL : (pFULL = new FULLElements());
	}
	
	public ParserRule getFULLRule() {
		return getFULLAccess().getRule();
	}

	//INNER returns ecore::EString:
	//  "INNER"|"Inner"|"inner";
	public INNERElements getINNERAccess() {
		return (pINNER != null) ? pINNER : (pINNER = new INNERElements());
	}
	
	public ParserRule getINNERRule() {
		return getINNERAccess().getRule();
	}

	//JOIN returns ecore::EString:
	//  "JOIN"|"Join"|"join";
	public JOINElements getJOINAccess() {
		return (pJOIN != null) ? pJOIN : (pJOIN = new JOINElements());
	}
	
	public ParserRule getJOINRule() {
		return getJOINAccess().getRule();
	}

	//FETCH returns ecore::EString:
	//  "FETCH"|"Fetch"|"fetch";
	public FETCHElements getFETCHAccess() {
		return (pFETCH != null) ? pFETCH : (pFETCH = new FETCHElements());
	}
	
	public ParserRule getFETCHRule() {
		return getFETCHAccess().getRule();
	}

	//WITH returns ecore::EString:
	//  "WITH"|"With"|"with";
	public WITHElements getWITHAccess() {
		return (pWITH != null) ? pWITH : (pWITH = new WITHElements());
	}
	
	public ParserRule getWITHRule() {
		return getWITHAccess().getRule();
	}

	//IN returns ecore::EString:
	//  "IN"|"In"|"in";
	public INElements getINAccess() {
		return (pIN != null) ? pIN : (pIN = new INElements());
	}
	
	public ParserRule getINRule() {
		return getINAccess().getRule();
	}

	//CLASS returns ecore::EString:
	//  "CLASS"|"Class"|"class";
	public CLASSElements getCLASSAccess() {
		return (pCLASS != null) ? pCLASS : (pCLASS = new CLASSElements());
	}
	
	public ParserRule getCLASSRule() {
		return getCLASSAccess().getRule();
	}

	//IN_CLASS returns ecore::EString:
	//  IN CLASS;
	public IN_CLASSElements getIN_CLASSAccess() {
		return (pIN_CLASS != null) ? pIN_CLASS : (pIN_CLASS = new IN_CLASSElements());
	}
	
	public ParserRule getIN_CLASSRule() {
		return getIN_CLASSAccess().getRule();
	}

	//ELEMENTS returns ecore::EString:
	//  "ELEMENTS"|"Elements"|"elements";
	public ELEMENTSElements getELEMENTSAccess() {
		return (pELEMENTS != null) ? pELEMENTS : (pELEMENTS = new ELEMENTSElements());
	}
	
	public ParserRule getELEMENTSRule() {
		return getELEMENTSAccess().getRule();
	}

	//IN_ELEMENTS returns ecore::EString:
	//  IN ELEMENTS;
	public IN_ELEMENTSElements getIN_ELEMENTSAccess() {
		return (pIN_ELEMENTS != null) ? pIN_ELEMENTS : (pIN_ELEMENTS = new IN_ELEMENTSElements());
	}
	
	public ParserRule getIN_ELEMENTSRule() {
		return getIN_ELEMENTSAccess().getRule();
	}

	//AS returns ecore::EString:
	//  "AS"|"As"|"as";
	public ASElements getASAccess() {
		return (pAS != null) ? pAS : (pAS = new ASElements());
	}
	
	public ParserRule getASRule() {
		return getASAccess().getRule();
	}

	//PROPERTIES returns ecore::EString:
	//  "PROPERTIES"|"Properties"|"properties";
	public PROPERTIESElements getPROPERTIESAccess() {
		return (pPROPERTIES != null) ? pPROPERTIES : (pPROPERTIES = new PROPERTIESElements());
	}
	
	public ParserRule getPROPERTIESRule() {
		return getPROPERTIESAccess().getRule();
	}

	//GROUP_BY returns ecore::EString:
	//  ("GROUP"|"Group"|"group") BY;
	public GROUP_BYElements getGROUP_BYAccess() {
		return (pGROUP_BY != null) ? pGROUP_BY : (pGROUP_BY = new GROUP_BYElements());
	}
	
	public ParserRule getGROUP_BYRule() {
		return getGROUP_BYAccess().getRule();
	}

	//ORDER_BY returns ecore::EString:
	//  ("ORDER"|"Order"|"order") BY;
	public ORDER_BYElements getORDER_BYAccess() {
		return (pORDER_BY != null) ? pORDER_BY : (pORDER_BY = new ORDER_BYElements());
	}
	
	public ParserRule getORDER_BYRule() {
		return getORDER_BYAccess().getRule();
	}

	//BY returns ecore::EString:
	//  "BY"|"By"|"by";
	public BYElements getBYAccess() {
		return (pBY != null) ? pBY : (pBY = new BYElements());
	}
	
	public ParserRule getBYRule() {
		return getBYAccess().getRule();
	}

	//ASC returns ecore::EString:
	//  "ASC"|"Asc"|"asc"|"ASCENDING"|"Ascending"|"ascending";
	public ASCElements getASCAccess() {
		return (pASC != null) ? pASC : (pASC = new ASCElements());
	}
	
	public ParserRule getASCRule() {
		return getASCAccess().getRule();
	}

	//DESC returns ecore::EString:
	//  "DESC"|"Desc"|"desc"|"DESCENDING"|"Descending"|"descending";
	public DESCElements getDESCAccess() {
		return (pDESC != null) ? pDESC : (pDESC = new DESCElements());
	}
	
	public ParserRule getDESCRule() {
		return getDESCAccess().getRule();
	}

	//HAVING returns ecore::EString:
	//  "HAVING"|"Having"|"having";
	public HAVINGElements getHAVINGAccess() {
		return (pHAVING != null) ? pHAVING : (pHAVING = new HAVINGElements());
	}
	
	public ParserRule getHAVINGRule() {
		return getHAVINGAccess().getRule();
	}

	//WHERE returns ecore::EString:
	//  "WHERE"|"Where"|"where";
	public WHEREElements getWHEREAccess() {
		return (pWHERE != null) ? pWHERE : (pWHERE = new WHEREElements());
	}
	
	public ParserRule getWHERERule() {
		return getWHEREAccess().getRule();
	}

	//OR returns ecore::EString:
	//  "OR"|"Or"|"or";
	public ORElements getORAccess() {
		return (pOR != null) ? pOR : (pOR = new ORElements());
	}
	
	public ParserRule getORRule() {
		return getORAccess().getRule();
	}

	//AND returns ecore::EString:
	//  "AND"|"And"|"and";
	public ANDElements getANDAccess() {
		return (pAND != null) ? pAND : (pAND = new ANDElements());
	}
	
	public ParserRule getANDRule() {
		return getANDAccess().getRule();
	}

	//NOT returns ecore::EString:
	//  "NOT"|"Not"|"not";
	public NOTElements getNOTAccess() {
		return (pNOT != null) ? pNOT : (pNOT = new NOTElements());
	}
	
	public ParserRule getNOTRule() {
		return getNOTAccess().getRule();
	}

	//IS returns ecore::EString:
	//  "IS"|"Is"|"is";
	public ISElements getISAccess() {
		return (pIS != null) ? pIS : (pIS = new ISElements());
	}
	
	public ParserRule getISRule() {
		return getISAccess().getRule();
	}

	//BETWEEN returns ecore::EString:
	//  "BETWEEN"|"Between"|"between";
	public BETWEENElements getBETWEENAccess() {
		return (pBETWEEN != null) ? pBETWEEN : (pBETWEEN = new BETWEENElements());
	}
	
	public ParserRule getBETWEENRule() {
		return getBETWEENAccess().getRule();
	}

	//LIKE returns ecore::EString:
	//  "LIKE"|"Like"|"like";
	public LIKEElements getLIKEAccess() {
		return (pLIKE != null) ? pLIKE : (pLIKE = new LIKEElements());
	}
	
	public ParserRule getLIKERule() {
		return getLIKEAccess().getRule();
	}

	//MEMBER returns ecore::EString:
	//  "MEMBER"|"Member"|"member";
	public MEMBERElements getMEMBERAccess() {
		return (pMEMBER != null) ? pMEMBER : (pMEMBER = new MEMBERElements());
	}
	
	public ParserRule getMEMBERRule() {
		return getMEMBERAccess().getRule();
	}

	//OF returns ecore::EString:
	//  "OF"|"Of"|"of";
	public OFElements getOFAccess() {
		return (pOF != null) ? pOF : (pOF = new OFElements());
	}
	
	public ParserRule getOFRule() {
		return getOFAccess().getRule();
	}

	//ESCAPE returns ecore::EString:
	//  "ESCAPE"|"Escape"|"escape";
	public ESCAPEElements getESCAPEAccess() {
		return (pESCAPE != null) ? pESCAPE : (pESCAPE = new ESCAPEElements());
	}
	
	public ParserRule getESCAPERule() {
		return getESCAPEAccess().getRule();
	}

	//CASE returns ecore::EString:
	//  "CASE"|"Case"|"case";
	public CASEElements getCASEAccess() {
		return (pCASE != null) ? pCASE : (pCASE = new CASEElements());
	}
	
	public ParserRule getCASERule() {
		return getCASEAccess().getRule();
	}

	//END returns ecore::EString:
	//  "END"|"End"|"end";
	public ENDElements getENDAccess() {
		return (pEND != null) ? pEND : (pEND = new ENDElements());
	}
	
	public ParserRule getENDRule() {
		return getENDAccess().getRule();
	}

	//WHEN returns ecore::EString:
	//  "WHEN"|"When"|"when";
	public WHENElements getWHENAccess() {
		return (pWHEN != null) ? pWHEN : (pWHEN = new WHENElements());
	}
	
	public ParserRule getWHENRule() {
		return getWHENAccess().getRule();
	}

	//THEN returns ecore::EString:
	//  "THEN"|"Then"|"then";
	public THENElements getTHENAccess() {
		return (pTHEN != null) ? pTHEN : (pTHEN = new THENElements());
	}
	
	public ParserRule getTHENRule() {
		return getTHENAccess().getRule();
	}

	//ELSE returns ecore::EString:
	//  "ELSE"|"Else"|"else";
	public ELSEElements getELSEAccess() {
		return (pELSE != null) ? pELSE : (pELSE = new ELSEElements());
	}
	
	public ParserRule getELSERule() {
		return getELSEAccess().getRule();
	}

	//SOME returns ecore::EString:
	//  "SOME"|"Some"|"some";
	public SOMEElements getSOMEAccess() {
		return (pSOME != null) ? pSOME : (pSOME = new SOMEElements());
	}
	
	public ParserRule getSOMERule() {
		return getSOMEAccess().getRule();
	}

	//EXISTS returns ecore::EString:
	//  "EXISTS"|"Exists"|"exists";
	public EXISTSElements getEXISTSAccess() {
		return (pEXISTS != null) ? pEXISTS : (pEXISTS = new EXISTSElements());
	}
	
	public ParserRule getEXISTSRule() {
		return getEXISTSAccess().getRule();
	}

	//ALL returns ecore::EString:
	//  "ALL"|"All"|"all";
	public ALLElements getALLAccess() {
		return (pALL != null) ? pALL : (pALL = new ALLElements());
	}
	
	public ParserRule getALLRule() {
		return getALLAccess().getRule();
	}

	//ANY returns ecore::EString:
	//  "ANY"|"Any"|"any";
	public ANYElements getANYAccess() {
		return (pANY != null) ? pANY : (pANY = new ANYElements());
	}
	
	public ParserRule getANYRule() {
		return getANYAccess().getRule();
	}

	//SUM returns ecore::EString:
	//  "SUM"|"Sum"|"sum";
	public SUMElements getSUMAccess() {
		return (pSUM != null) ? pSUM : (pSUM = new SUMElements());
	}
	
	public ParserRule getSUMRule() {
		return getSUMAccess().getRule();
	}

	//AVG returns ecore::EString:
	//  "AVG"|"Avg"|"avg";
	public AVGElements getAVGAccess() {
		return (pAVG != null) ? pAVG : (pAVG = new AVGElements());
	}
	
	public ParserRule getAVGRule() {
		return getAVGAccess().getRule();
	}

	//MAX returns ecore::EString:
	//  "MAX"|"Max"|"max";
	public MAXElements getMAXAccess() {
		return (pMAX != null) ? pMAX : (pMAX = new MAXElements());
	}
	
	public ParserRule getMAXRule() {
		return getMAXAccess().getRule();
	}

	//MIN returns ecore::EString:
	//  "MIN"|"Min"|"min";
	public MINElements getMINAccess() {
		return (pMIN != null) ? pMIN : (pMIN = new MINElements());
	}
	
	public ParserRule getMINRule() {
		return getMINAccess().getRule();
	}

	//COUNT returns ecore::EString:
	//  "COUNT"|"Count"|"count";
	public COUNTElements getCOUNTAccess() {
		return (pCOUNT != null) ? pCOUNT : (pCOUNT = new COUNTElements());
	}
	
	public ParserRule getCOUNTRule() {
		return getCOUNTAccess().getRule();
	}

	//INDICES returns ecore::EString:
	//  "INDICES"|"Indices"|"indices";
	public INDICESElements getINDICESAccess() {
		return (pINDICES != null) ? pINDICES : (pINDICES = new INDICESElements());
	}
	
	public ParserRule getINDICESRule() {
		return getINDICESAccess().getRule();
	}

	//TRAILING returns ecore::EString:
	//  "TRAILING"|"Trailing"|"trailing";
	public TRAILINGElements getTRAILINGAccess() {
		return (pTRAILING != null) ? pTRAILING : (pTRAILING = new TRAILINGElements());
	}
	
	public ParserRule getTRAILINGRule() {
		return getTRAILINGAccess().getRule();
	}

	//LEADING returns ecore::EString:
	//  "LEADING"|"Leading"|"leading";
	public LEADINGElements getLEADINGAccess() {
		return (pLEADING != null) ? pLEADING : (pLEADING = new LEADINGElements());
	}
	
	public ParserRule getLEADINGRule() {
		return getLEADINGAccess().getRule();
	}

	//BOTH returns ecore::EString:
	//  "BOTH"|"Both"|"both";
	public BOTHElements getBOTHAccess() {
		return (pBOTH != null) ? pBOTH : (pBOTH = new BOTHElements());
	}
	
	public ParserRule getBOTHRule() {
		return getBOTHAccess().getRule();
	}

	//NULL returns ecore::EString:
	//  "NULL"|"Null"|"null";
	public NULLElements getNULLAccess() {
		return (pNULL != null) ? pNULL : (pNULL = new NULLElements());
	}
	
	public ParserRule getNULLRule() {
		return getNULLAccess().getRule();
	}

	//TRUE returns ecore::EString:
	//  "TRUE"|"True"|"true";
	public TRUEElements getTRUEAccess() {
		return (pTRUE != null) ? pTRUE : (pTRUE = new TRUEElements());
	}
	
	public ParserRule getTRUERule() {
		return getTRUEAccess().getRule();
	}

	//FALSE returns ecore::EString:
	//  "FALSE"|"False"|"false";
	public FALSEElements getFALSEAccess() {
		return (pFALSE != null) ? pFALSE : (pFALSE = new FALSEElements());
	}
	
	public ParserRule getFALSERule() {
		return getFALSEAccess().getRule();
	}

	//EMPTY returns ecore::EString:
	//  "EMPTY"|"Empty"|"empty"; 
	//          	
	//
	//	
	//
	//// END HQL stuff
	//
	////keywords that can be used as names of fields or functions
	public EMPTYElements getEMPTYAccess() {
		return (pEMPTY != null) ? pEMPTY : (pEMPTY = new EMPTYElements());
	}
	
	public ParserRule getEMPTYRule() {
		return getEMPTYAccess().getRule();
	}

	//keyword returns ecore::EString:
	//  "all"|"length"|"char"|"type"|"file"|"text"|"title"|"max"|"when"|"member"|"end"|
	//  "object"|"date"; 	
	//
	//	
	//
	//// END HQL stuff
	//
	////keywords that can be used as names of fields or functions	
	//
	//	                            //MDD keywords
	//	                       //HQL keywords
	public KeywordElements getKeywordAccess() {
		return (pKeyword != null) ? pKeyword : (pKeyword = new KeywordElements());
	}
	
	public ParserRule getKeywordRule() {
		return getKeywordAccess().getRule();
	}

	//terminal LINEBREAK:
	//  "\n" | "\r" "\n" | "\r";
	public TerminalRule getLINEBREAKRule() {
		return (tLINEBREAK != null) ? tLINEBREAK : (tLINEBREAK = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LINEBREAK"));
	} 

	//terminal ID:
	//  "^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//terminal SIGNED_INT returns ecore::EInt:
	//  ("-" | "+") INT;
	public TerminalRule getSIGNED_INTRule() {
		return (tSIGNED_INT != null) ? tSIGNED_INT : (tSIGNED_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SIGNED_INT"));
	} 

	//terminal HEX returns ecore::EInt:
	//  "0x" ("0".."9" | "a".."f")+;
	public TerminalRule getHEXRule() {
		return (tHEX != null) ? tHEX : (tHEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HEX"));
	} 

	//terminal INT returns ecore::EInt:
	//  "0".."9"+;
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//terminal FIELDCOMMENT:
	//  ";" !("\n" | "\r")*;
	public TerminalRule getFIELDCOMMENTRule() {
		return (tFIELDCOMMENT != null) ? tFIELDCOMMENT : (tFIELDCOMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FIELDCOMMENT"));
	} 

	//terminal SL_COMMENT:
	//  "#" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//terminal WS:
	//  " " | "\t" | "\r" "\n" | "\n" | "\r";
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//terminal STRING:
	//  "\"" ("\\" "\"" | !"\"")* "\"" | "\'" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" |
	//  "\'"))* "\'"; 
	//
	//  	 
	////		:'"'(	('\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '"' | '\'' | '\\'
	////	        		|   ('u')+ ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') 
	////	        			('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F')
	////	        		//|   '0'..'3'('0'..'7')*
	////	        		//|   '4'..'7' ('0'..'7')? 
	////	        		)
	////	        	)
	////	        |!('"'|'\\'|'\n'|'\r'))* '"'
	//				
	//			               
	//			              
	//		
	//		
	////terminal STRING
	////	: '"'->'"'; 
	////	
	////terminal HQL_STRING
	////	: "'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
	////	;
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 
}
