/*
* generated by Xtext
*/
package org.makumba.devel.plugin.eclipse.mdd.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.makumba.devel.plugin.eclipse.mdd.services.MDDGrammarAccess;

import com.google.inject.Inject;

public class MDDParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private MDDGrammarAccess grammarAccess;
	
	@Override	
	public MDDGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DataDefinition_Group(this, this, 0, inst);
			case 1: return new Declaration_Alternatives(this, this, 1, inst);
			case 2: return new FieldDeclaration_Group(this, this, 2, inst);
			case 3: return new Modifiers_UnorderedGroup(this, this, 3, inst);
			case 4: return new FieldType_Alternatives(this, this, 4, inst);
			case 5: return new IntEnum_Group(this, this, 5, inst);
			case 6: return new CharEnum_Group(this, this, 6, inst);
			case 7: return new EnumValue_Group(this, this, 7, inst);
			case 8: return new CharType_Group(this, this, 8, inst);
			case 9: return new Pointer_Group(this, this, 9, inst);
			case 10: return new SetType_Group(this, this, 10, inst);
			case 11: return new SubFieldDeclaration_Group(this, this, 11, inst);
			case 12: return new TitleDeclaration_Group(this, this, 12, inst);
			case 13: return new Title_Alternatives(this, this, 13, inst);
			case 14: return new IncludeDeclaration_Group(this, this, 14, inst);
			case 15: return new TypeDeclaration_Group(this, this, 15, inst);
			case 16: return new ValidationRuleDeclaration_Group(this, this, 16, inst);
			case 17: return new ComparisonValidationRuleDeclaration_Group(this, this, 17, inst);
			case 18: return new ComparisonExpression_Group(this, this, 18, inst);
			case 19: return new ComparisonPart_Alternatives(this, this, 19, inst);
			case 20: return new UpperFunction_Group(this, this, 20, inst);
			case 21: return new LowerFunction_Group(this, this, 21, inst);
			case 22: return new RangeValidationRuleDeclaration_Group(this, this, 22, inst);
			case 23: return new RegexValidationRuleDeclaration_Group(this, this, 23, inst);
			case 24: return new Range_Group(this, this, 24, inst);
			case 25: return new UniquenessValidationRuleDeclaration_Group(this, this, 25, inst);
			case 26: return new ErrorMessage_Group(this, this, 26, inst);
			case 27: return new NativeValidationRuleDeclaration_Group(this, this, 27, inst);
			case 28: return new FunctionDeclaration_Group(this, this, 28, inst);
			case 29: return new FunctionArgumentDeclaration_Group(this, this, 29, inst);
			case 30: return new FunctionArgumentBody_Group(this, this, 30, inst);
			case 31: return new FunctionCall_Group(this, this, 31, inst);
			case 32: return new FunctionArguments_Group(this, this, 32, inst);
			case 33: return new FunctionBody_Group(this, this, 33, inst);
			case 34: return new Statement_QueryRuleParserRuleCall(this, this, 34, inst);
			case 35: return new UnionRule_Group(this, this, 35, inst);
			case 36: return new QueryRule_Group(this, this, 36, inst);
			case 37: return new SelectFrom_Group(this, this, 37, inst);
			case 38: return new SelectClause_Group(this, this, 38, inst);
			case 39: return new NewExpression_Group(this, this, 39, inst);
			case 40: return new FromClause_Group(this, this, 40, inst);
			case 41: return new FromJoin_Group(this, this, 41, inst);
			case 42: return new WithClause_Group(this, this, 42, inst);
			case 43: return new FromRange_Alternatives(this, this, 43, inst);
			case 44: return new FromClassOrOuterQueryPath_Group(this, this, 44, inst);
			case 45: return new InCollectionElementsDeclaration_Group(this, this, 45, inst);
			case 46: return new AsAlias_Group(this, this, 46, inst);
			case 47: return new GroupByClause_Group(this, this, 47, inst);
			case 48: return new OrderByClause_Group(this, this, 48, inst);
			case 49: return new OrderElement_Group(this, this, 49, inst);
			case 50: return new HavingClause_Group(this, this, 50, inst);
			case 51: return new WhereClause_Group(this, this, 51, inst);
			case 52: return new SelectedPropertiesList_Group(this, this, 52, inst);
			case 53: return new AliasedExpression_Group(this, this, 53, inst);
			case 54: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 54, inst);
			case 55: return new LogicalOrExpression_Group(this, this, 55, inst);
			case 56: return new LogicalAndExpression_Group(this, this, 56, inst);
			case 57: return new NegatedExpression_Alternatives(this, this, 57, inst);
			case 58: return new EqualityExpression_Group(this, this, 58, inst);
			case 59: return new RelationalExpression_Group(this, this, 59, inst);
			case 60: return new LikeEscape_Group(this, this, 60, inst);
			case 61: return new BetweenList_Group(this, this, 61, inst);
			case 62: return new Concatenation_Group(this, this, 62, inst);
			case 63: return new AdditiveExpression_Group(this, this, 63, inst);
			case 64: return new MultiplyExpression_Group(this, this, 64, inst);
			case 65: return new UnaryExpression_Alternatives(this, this, 65, inst);
			case 66: return new CaseExpression_Alternatives(this, this, 66, inst);
			case 67: return new WhenClause_Group(this, this, 67, inst);
			case 68: return new AltWhenClause_Group(this, this, 68, inst);
			case 69: return new ElseClause_Group(this, this, 69, inst);
			case 70: return new QuantifiedExpression_Group(this, this, 70, inst);
			case 71: return new Atom_Group(this, this, 71, inst);
			case 72: return new PrimaryExpression_Alternatives(this, this, 72, inst);
			case 73: return new ExpressionOrVector_Group(this, this, 73, inst);
			case 74: return new VectorExpr_Group(this, this, 74, inst);
			case 75: return new IdentPrimary_Alternatives(this, this, 75, inst);
			case 76: return new Aggregate_Alternatives(this, this, 76, inst);
			case 77: return new CompoundExpr_Alternatives(this, this, 77, inst);
			case 78: return new ExprList_Group(this, this, 78, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule dataDefinition ****************
 *
 * dataDefinition:
 *   LINEBREAK* (d+=declaration FIELDCOMMENT? LINEBREAK*)+;
 *
 **/

// LINEBREAK* (d+=declaration FIELDCOMMENT? LINEBREAK*)+
protected class DataDefinition_Group extends GroupToken {
	
	public DataDefinition_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDataDefinitionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DataDefinition_Group_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDataDefinitionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// LINEBREAK*
protected class DataDefinition_LINEBREAKTerminalRuleCall_0 extends UnassignedTextToken {

	public DataDefinition_LINEBREAKTerminalRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDataDefinitionAccess().getLINEBREAKTerminalRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DataDefinition_LINEBREAKTerminalRuleCall_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// (d+=declaration FIELDCOMMENT? LINEBREAK*)+
protected class DataDefinition_Group_1 extends GroupToken {
	
	public DataDefinition_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDataDefinitionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DataDefinition_LINEBREAKTerminalRuleCall_1_2(parent, this, 0, inst);
			case 1: return new DataDefinition_FIELDCOMMENTTerminalRuleCall_1_1(parent, this, 1, inst);
			case 2: return new DataDefinition_DAssignment_1_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// d+=declaration
protected class DataDefinition_DAssignment_1_0 extends AssignmentToken  {
	
	public DataDefinition_DAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDataDefinitionAccess().getDAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declaration_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("d",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("d");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDataDefinitionAccess().getDDeclarationParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new DataDefinition_Group_1(parent, next, actIndex, consumed);
			case 1: return new DataDefinition_LINEBREAKTerminalRuleCall_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}

// FIELDCOMMENT?
protected class DataDefinition_FIELDCOMMENTTerminalRuleCall_1_1 extends UnassignedTextToken {

	public DataDefinition_FIELDCOMMENTTerminalRuleCall_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDataDefinitionAccess().getFIELDCOMMENTTerminalRuleCall_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DataDefinition_DAssignment_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// LINEBREAK*
protected class DataDefinition_LINEBREAKTerminalRuleCall_1_2 extends UnassignedTextToken {

	public DataDefinition_LINEBREAKTerminalRuleCall_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDataDefinitionAccess().getLINEBREAKTerminalRuleCall_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DataDefinition_LINEBREAKTerminalRuleCall_1_2(parent, this, 0, inst);
			case 1: return new DataDefinition_FIELDCOMMENTTerminalRuleCall_1_1(parent, this, 1, inst);
			case 2: return new DataDefinition_DAssignment_1_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule dataDefinition ****************/


/************ begin Rule declaration ****************
 *
 * declaration:
 *   fieldDeclaration|titleDeclaration|typeDeclaration|includeDeclaration|
 *   validationRuleDeclaration|functionDeclaration|nativeValidationRuleDeclaration|
 *   subFieldDeclaration; 
 * 
 * 
 *     
 *     
 *     
 *      
 *     
 *     
 *     
 *   
 *    
 * 
 * / *extendedDeclaration:
 * 	declaration |
 * 	 FIELDCOMMENT? LINEBREAK*;* /
 * 
 * 		
 * /////// Field Declaration
 *
 **/

// fieldDeclaration|titleDeclaration|typeDeclaration|includeDeclaration|
// validationRuleDeclaration|functionDeclaration|nativeValidationRuleDeclaration|
// subFieldDeclaration 
// 
// 
//     
//     
//     
//      
//     
//     
//     
//   
//    
// 
// / *extendedDeclaration:
// 	declaration |
// 	 FIELDCOMMENT? LINEBREAK*;* /
// 
// 		
// /////// Field Declaration
protected class Declaration_Alternatives extends AlternativesToken {

	public Declaration_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declaration_FieldDeclarationParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Declaration_TitleDeclarationParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Declaration_TypeDeclarationParserRuleCall_2(parent, this, 2, inst);
			case 3: return new Declaration_IncludeDeclarationParserRuleCall_3(parent, this, 3, inst);
			case 4: return new Declaration_ValidationRuleDeclarationParserRuleCall_4(parent, this, 4, inst);
			case 5: return new Declaration_FunctionDeclarationParserRuleCall_5(parent, this, 5, inst);
			case 6: return new Declaration_NativeValidationRuleDeclarationParserRuleCall_6(parent, this, 6, inst);
			case 7: return new Declaration_SubFieldDeclarationParserRuleCall_7(parent, this, 7, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// fieldDeclaration
protected class Declaration_FieldDeclarationParserRuleCall_0 extends RuleCallToken {
	
	public Declaration_FieldDeclarationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getFieldDeclarationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FieldDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFieldDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// titleDeclaration
protected class Declaration_TitleDeclarationParserRuleCall_1 extends RuleCallToken {
	
	public Declaration_TitleDeclarationParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getTitleDeclarationParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TitleDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TitleDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTitleDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// typeDeclaration
protected class Declaration_TypeDeclarationParserRuleCall_2 extends RuleCallToken {
	
	public Declaration_TypeDeclarationParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getTypeDeclarationParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TypeDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypeDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// includeDeclaration
protected class Declaration_IncludeDeclarationParserRuleCall_3 extends RuleCallToken {
	
	public Declaration_IncludeDeclarationParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getIncludeDeclarationParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IncludeDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIncludeDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// validationRuleDeclaration
protected class Declaration_ValidationRuleDeclarationParserRuleCall_4 extends RuleCallToken {
	
	public Declaration_ValidationRuleDeclarationParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getValidationRuleDeclarationParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValidationRuleDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ValidationRuleDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// functionDeclaration
protected class Declaration_FunctionDeclarationParserRuleCall_5 extends RuleCallToken {
	
	public Declaration_FunctionDeclarationParserRuleCall_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getFunctionDeclarationParserRuleCall_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FunctionDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFunctionDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// nativeValidationRuleDeclaration
protected class Declaration_NativeValidationRuleDeclarationParserRuleCall_6 extends RuleCallToken {
	
	public Declaration_NativeValidationRuleDeclarationParserRuleCall_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getNativeValidationRuleDeclarationParserRuleCall_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NativeValidationRuleDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NativeValidationRuleDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNativeValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// subFieldDeclaration
protected class Declaration_SubFieldDeclarationParserRuleCall_7 extends RuleCallToken {
	
	public Declaration_SubFieldDeclarationParserRuleCall_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getDeclarationAccess().getSubFieldDeclarationParserRuleCall_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SubFieldDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SubFieldDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSubFieldDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule declaration ****************/


/************ begin Rule fieldDeclaration ****************
 *
 * fieldDeclaration:
 *   name=( ID | keyword ) "=" (modifiers=modifiers typedef=fieldType)?; 
 * 
 * / *extendedDeclaration:
 * 	declaration |
 * 	 FIELDCOMMENT? LINEBREAK*;* /
 * 
 * 		
 * /////// Field Declaration
 *
 **/

// name=( ID | keyword ) "=" (modifiers=modifiers typedef=fieldType)?
protected class FieldDeclaration_Group extends GroupToken {
	
	public FieldDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFieldDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldDeclaration_Group_2(parent, this, 0, inst);
			case 1: return new FieldDeclaration_EqualsSignKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFieldDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=( ID | keyword )
protected class FieldDeclaration_NameAssignment_0 extends AssignmentToken  {
	
	public FieldDeclaration_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldDeclarationAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getFieldDeclarationAccess().getNameIDTerminalRuleCall_0_0_0();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getFieldDeclarationAccess().getNameKeywordParserRuleCall_0_0_1();
			return obj;
		}
		return null;
	}

}

// "="
protected class FieldDeclaration_EqualsSignKeyword_1 extends KeywordToken  {
	
	public FieldDeclaration_EqualsSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFieldDeclarationAccess().getEqualsSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldDeclaration_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (modifiers=modifiers typedef=fieldType)?
protected class FieldDeclaration_Group_2 extends GroupToken {
	
	public FieldDeclaration_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFieldDeclarationAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldDeclaration_TypedefAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// modifiers=modifiers
protected class FieldDeclaration_ModifiersAssignment_2_0 extends AssignmentToken  {
	
	public FieldDeclaration_ModifiersAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldDeclarationAccess().getModifiersAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Modifiers_UnorderedGroup(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("modifiers",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("modifiers");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getModifiersRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFieldDeclarationAccess().getModifiersModifiersParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FieldDeclaration_EqualsSignKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// typedef=fieldType
protected class FieldDeclaration_TypedefAssignment_2_1 extends AssignmentToken  {
	
	public FieldDeclaration_TypedefAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldDeclarationAccess().getTypedefAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldType_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typedef",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typedef");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFieldTypeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFieldDeclarationAccess().getTypedefFieldTypeParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FieldDeclaration_ModifiersAssignment_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule fieldDeclaration ****************/


/************ begin Rule modifiers ****************
 *
 * modifiers:
 *   unique?="unique"? & fixed?="fixed"? & (notNull?="not" "null")? & (notEmpty?="not"
 *   "empty")?;
 *
 **/

// unique?="unique"? & fixed?="fixed"? & (notNull?="not" "null")? & (notEmpty?="not"
// "empty")?
protected class Modifiers_UnorderedGroup extends UnorderedGroupToken {
	
	public Modifiers_UnorderedGroup(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public UnorderedGroup getGrammarElement() {
		return grammarAccess.getModifiersAccess().getUnorderedGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Modifiers_Group_3(parent, this, 0, inst);
			case 1: return new Modifiers_Group_2(parent, this, 1, inst);
			case 2: return new Modifiers_FixedAssignment_1(parent, this, 2, inst);
			case 3: return new Modifiers_UniqueAssignment_0(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getModifiersRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// unique?="unique"?
protected class Modifiers_UniqueAssignment_0 extends AssignmentToken  {
	
	public Modifiers_UniqueAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getModifiersAccess().getUniqueAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("unique",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("unique");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getModifiersAccess().getUniqueUniqueKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// fixed?="fixed"?
protected class Modifiers_FixedAssignment_1 extends AssignmentToken  {
	
	public Modifiers_FixedAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getModifiersAccess().getFixedAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Modifiers_UniqueAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fixed",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fixed");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getModifiersAccess().getFixedFixedKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// (notNull?="not" "null")?
protected class Modifiers_Group_2 extends GroupToken {
	
	public Modifiers_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getModifiersAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Modifiers_NullKeyword_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// notNull?="not"
protected class Modifiers_NotNullAssignment_2_0 extends AssignmentToken  {
	
	public Modifiers_NotNullAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getModifiersAccess().getNotNullAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Modifiers_FixedAssignment_1(parent, this, 0, inst);
			case 1: return new Modifiers_UniqueAssignment_0(parent, this, 1, inst);
			default: return parent.createParentFollower(this, index, index - 2, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("notNull",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("notNull");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getModifiersAccess().getNotNullNotKeyword_2_0_0();
			return obj;
		}
		return null;
	}

}

// "null"
protected class Modifiers_NullKeyword_2_1 extends KeywordToken  {
	
	public Modifiers_NullKeyword_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getModifiersAccess().getNullKeyword_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Modifiers_NotNullAssignment_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// (notEmpty?="not" "empty")?
protected class Modifiers_Group_3 extends GroupToken {
	
	public Modifiers_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getModifiersAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Modifiers_EmptyKeyword_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// notEmpty?="not"
protected class Modifiers_NotEmptyAssignment_3_0 extends AssignmentToken  {
	
	public Modifiers_NotEmptyAssignment_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getModifiersAccess().getNotEmptyAssignment_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Modifiers_Group_2(parent, this, 0, inst);
			case 1: return new Modifiers_FixedAssignment_1(parent, this, 1, inst);
			case 2: return new Modifiers_UniqueAssignment_0(parent, this, 2, inst);
			default: return parent.createParentFollower(this, index, index - 3, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("notEmpty",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("notEmpty");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getModifiersAccess().getNotEmptyNotKeyword_3_0_0();
			return obj;
		}
		return null;
	}

}

// "empty"
protected class Modifiers_EmptyKeyword_3_1 extends KeywordToken  {
	
	public Modifiers_EmptyKeyword_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getModifiersAccess().getEmptyKeyword_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Modifiers_NotEmptyAssignment_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule modifiers ****************/


/************ begin Rule fieldType ****************
 *
 * fieldType:
 *   charType|charEnum|"set" charEnum|intEnum|"set" intEnum|{fieldType} type=( "int" |
 *   "real" | "boolean" | "text" | "binary" | "file" | "date" )|pointer|setType|typeDec=[
 *   typeDeclaration];
 *
 **/

// charType|charEnum|"set" charEnum|intEnum|"set" intEnum|{fieldType} type=( "int" |
// "real" | "boolean" | "text" | "binary" | "file" | "date" )|pointer|setType|typeDec=[
// typeDeclaration]
protected class FieldType_Alternatives extends AlternativesToken {

	public FieldType_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldType_CharTypeParserRuleCall_0(parent, this, 0, inst);
			case 1: return new FieldType_CharEnumParserRuleCall_1(parent, this, 1, inst);
			case 2: return new FieldType_Group_2(parent, this, 2, inst);
			case 3: return new FieldType_IntEnumParserRuleCall_3(parent, this, 3, inst);
			case 4: return new FieldType_Group_4(parent, this, 4, inst);
			case 5: return new FieldType_Group_5(parent, this, 5, inst);
			case 6: return new FieldType_PointerParserRuleCall_6(parent, this, 6, inst);
			case 7: return new FieldType_SetTypeParserRuleCall_7(parent, this, 7, inst);
			case 8: return new FieldType_TypeDecAssignment_8(parent, this, 8, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFieldTypeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// charType
protected class FieldType_CharTypeParserRuleCall_0 extends RuleCallToken {
	
	public FieldType_CharTypeParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getCharTypeParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharType_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CharType_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCharTypeRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// charEnum
protected class FieldType_CharEnumParserRuleCall_1 extends RuleCallToken {
	
	public FieldType_CharEnumParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getCharEnumParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharEnum_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CharEnum_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCharEnumRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// "set" charEnum
protected class FieldType_Group_2 extends GroupToken {
	
	public FieldType_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldType_CharEnumParserRuleCall_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "set"
protected class FieldType_SetKeyword_2_0 extends KeywordToken  {
	
	public FieldType_SetKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getSetKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// charEnum
protected class FieldType_CharEnumParserRuleCall_2_1 extends RuleCallToken {
	
	public FieldType_CharEnumParserRuleCall_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getCharEnumParserRuleCall_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharEnum_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CharEnum_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCharEnumRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldType_SetKeyword_2_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}


// intEnum
protected class FieldType_IntEnumParserRuleCall_3 extends RuleCallToken {
	
	public FieldType_IntEnumParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getIntEnumParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntEnum_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntEnum_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntEnumRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// "set" intEnum
protected class FieldType_Group_4 extends GroupToken {
	
	public FieldType_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldType_IntEnumParserRuleCall_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "set"
protected class FieldType_SetKeyword_4_0 extends KeywordToken  {
	
	public FieldType_SetKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getSetKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// intEnum
protected class FieldType_IntEnumParserRuleCall_4_1 extends RuleCallToken {
	
	public FieldType_IntEnumParserRuleCall_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getIntEnumParserRuleCall_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntEnum_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntEnum_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntEnumRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldType_SetKeyword_4_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}


// {fieldType} type=( "int" | "real" | "boolean" | "text" | "binary" | "file" | "date" )
protected class FieldType_Group_5 extends GroupToken {
	
	public FieldType_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldType_TypeAssignment_5_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {fieldType}
protected class FieldType_FieldTypeAction_5_0 extends ActionToken  {

	public FieldType_FieldTypeAction_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getFieldTypeAction_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getFieldTypeAccess().getFieldTypeAction_5_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// type=( "int" | "real" | "boolean" | "text" | "binary" | "file" | "date" )
protected class FieldType_TypeAssignment_5_1 extends AssignmentToken  {
	
	public FieldType_TypeAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getTypeAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldType_FieldTypeAction_5_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if("int".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFieldTypeAccess().getTypeIntKeyword_5_1_0_0();
			return obj;
		}
		if("real".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFieldTypeAccess().getTypeRealKeyword_5_1_0_1();
			return obj;
		}
		if("boolean".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFieldTypeAccess().getTypeBooleanKeyword_5_1_0_2();
			return obj;
		}
		if("text".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFieldTypeAccess().getTypeTextKeyword_5_1_0_3();
			return obj;
		}
		if("binary".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFieldTypeAccess().getTypeBinaryKeyword_5_1_0_4();
			return obj;
		}
		if("file".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFieldTypeAccess().getTypeFileKeyword_5_1_0_5();
			return obj;
		}
		if("date".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFieldTypeAccess().getTypeDateKeyword_5_1_0_6();
			return obj;
		}
		return null;
	}

}


// pointer
protected class FieldType_PointerParserRuleCall_6 extends RuleCallToken {
	
	public FieldType_PointerParserRuleCall_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getPointerParserRuleCall_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Pointer_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Pointer_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPointerRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// setType
protected class FieldType_SetTypeParserRuleCall_7 extends RuleCallToken {
	
	public FieldType_SetTypeParserRuleCall_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getSetTypeParserRuleCall_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetType_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SetType_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSetTypeRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// typeDec=[typeDeclaration]
protected class FieldType_TypeDecAssignment_8 extends AssignmentToken  {
	
	public FieldType_TypeDecAssignment_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFieldTypeAccess().getTypeDecAssignment_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeDec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeDec");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFieldTypeAccess().getTypeDecTypeDeclarationCrossReference_8_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getFieldTypeAccess().getTypeDecTypeDeclarationCrossReference_8_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule fieldType ****************/


/************ begin Rule intEnum ****************
 *
 * intEnum:
 *   name="int" "{" values+=enumValue ("," values+=enumValue)* "}";
 *
 **/

// name="int" "{" values+=enumValue ("," values+=enumValue)* "}"
protected class IntEnum_Group extends GroupToken {
	
	public IntEnum_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIntEnumAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntEnum_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIntEnumRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name="int"
protected class IntEnum_NameAssignment_0 extends AssignmentToken  {
	
	public IntEnum_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntEnumAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if("int".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getIntEnumAccess().getNameIntKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class IntEnum_LeftCurlyBracketKeyword_1 extends KeywordToken  {
	
	public IntEnum_LeftCurlyBracketKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIntEnumAccess().getLeftCurlyBracketKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntEnum_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// values+=enumValue
protected class IntEnum_ValuesAssignment_2 extends AssignmentToken  {
	
	public IntEnum_ValuesAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntEnumAccess().getValuesAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumValue_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("values",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("values");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumValueRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIntEnumAccess().getValuesEnumValueParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IntEnum_LeftCurlyBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," values+=enumValue)*
protected class IntEnum_Group_3 extends GroupToken {
	
	public IntEnum_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIntEnumAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntEnum_ValuesAssignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class IntEnum_CommaKeyword_3_0 extends KeywordToken  {
	
	public IntEnum_CommaKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIntEnumAccess().getCommaKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntEnum_Group_3(parent, this, 0, inst);
			case 1: return new IntEnum_ValuesAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// values+=enumValue
protected class IntEnum_ValuesAssignment_3_1 extends AssignmentToken  {
	
	public IntEnum_ValuesAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntEnumAccess().getValuesAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumValue_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("values",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("values");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumValueRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIntEnumAccess().getValuesEnumValueParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IntEnum_CommaKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class IntEnum_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public IntEnum_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIntEnumAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntEnum_Group_3(parent, this, 0, inst);
			case 1: return new IntEnum_ValuesAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule intEnum ****************/


/************ begin Rule charEnum ****************
 *
 * charEnum:
 *   name="char" "{" values+=STRING ("," values+=STRING)* "}"; 
 * 
 * 
 * 	           
 * 		
 * 
 *    
 * / * New syntax to be introduced in mak 0.9
 * enumType:
 *   'enum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}'); 
 * 
 * setEnumType:
 *   'setEnum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}');* /
 *
 **/

// name="char" "{" values+=STRING ("," values+=STRING)* "}"
protected class CharEnum_Group extends GroupToken {
	
	public CharEnum_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCharEnumAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharEnum_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCharEnumRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name="char"
protected class CharEnum_NameAssignment_0 extends AssignmentToken  {
	
	public CharEnum_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCharEnumAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if("char".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getCharEnumAccess().getNameCharKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class CharEnum_LeftCurlyBracketKeyword_1 extends KeywordToken  {
	
	public CharEnum_LeftCurlyBracketKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCharEnumAccess().getLeftCurlyBracketKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharEnum_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// values+=STRING
protected class CharEnum_ValuesAssignment_2 extends AssignmentToken  {
	
	public CharEnum_ValuesAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCharEnumAccess().getValuesAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharEnum_LeftCurlyBracketKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("values",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("values");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getCharEnumAccess().getValuesSTRINGTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// ("," values+=STRING)*
protected class CharEnum_Group_3 extends GroupToken {
	
	public CharEnum_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCharEnumAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharEnum_ValuesAssignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class CharEnum_CommaKeyword_3_0 extends KeywordToken  {
	
	public CharEnum_CommaKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCharEnumAccess().getCommaKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharEnum_Group_3(parent, this, 0, inst);
			case 1: return new CharEnum_ValuesAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// values+=STRING
protected class CharEnum_ValuesAssignment_3_1 extends AssignmentToken  {
	
	public CharEnum_ValuesAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCharEnumAccess().getValuesAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharEnum_CommaKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("values",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("values");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getCharEnumAccess().getValuesSTRINGTerminalRuleCall_3_1_0();
			return obj;
		}
		return null;
	}

}


// "}"
protected class CharEnum_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public CharEnum_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCharEnumAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharEnum_Group_3(parent, this, 0, inst);
			case 1: return new CharEnum_ValuesAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule charEnum ****************/


/************ begin Rule enumValue ****************
 *
 * enumValue:
 *   name=STRING "=" value=( INT | SIGNED_INT ) "deprecated"?; 	
 * 
 *    
 * / * New syntax to be introduced in mak 0.9
 * enumType:
 *   'enum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}'); 
 * 
 * setEnumType:
 *   'setEnum' ('{'  values+=EnumValue (',' values+=EnumValue)* '}');* /
 *
 **/

// name=STRING "=" value=( INT | SIGNED_INT ) "deprecated"?
protected class EnumValue_Group extends GroupToken {
	
	public EnumValue_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumValueAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumValue_ValueAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumValueRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=STRING
protected class EnumValue_NameAssignment_0 extends AssignmentToken  {
	
	public EnumValue_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumValueAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumValueAccess().getNameSTRINGTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "="
protected class EnumValue_EqualsSignKeyword_1 extends KeywordToken  {
	
	public EnumValue_EqualsSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumValueAccess().getEqualsSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumValue_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// value=( INT | SIGNED_INT )
protected class EnumValue_ValueAssignment_2 extends AssignmentToken  {
	
	public EnumValue_ValueAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumValueAccess().getValueAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumValue_EqualsSignKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumValueAccess().getValueINTTerminalRuleCall_2_0_0();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumValueAccess().getValueSIGNED_INTTerminalRuleCall_2_0_1();
			return obj;
		}
		return null;
	}

}


/************ end Rule enumValue ****************/


/************ begin Rule charType ****************
 *
 * charType:
 *   {charType} "char" ("[" length=INT? "]")?;
 *
 **/

// {charType} "char" ("[" length=INT? "]")?
protected class CharType_Group extends GroupToken {
	
	public CharType_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCharTypeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharType_Group_2(parent, this, 0, inst);
			case 1: return new CharType_CharKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCharTypeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {charType}
protected class CharType_CharTypeAction_0 extends ActionToken  {

	public CharType_CharTypeAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCharTypeAccess().getCharTypeAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCharTypeAccess().getCharTypeAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "char"
protected class CharType_CharKeyword_1 extends KeywordToken  {
	
	public CharType_CharKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCharTypeAccess().getCharKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharType_CharTypeAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("[" length=INT? "]")?
protected class CharType_Group_2 extends GroupToken {
	
	public CharType_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCharTypeAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharType_RightSquareBracketKeyword_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "["
protected class CharType_LeftSquareBracketKeyword_2_0 extends KeywordToken  {
	
	public CharType_LeftSquareBracketKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCharTypeAccess().getLeftSquareBracketKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharType_CharKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// length=INT?
protected class CharType_LengthAssignment_2_1 extends AssignmentToken  {
	
	public CharType_LengthAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCharTypeAccess().getLengthAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharType_LeftSquareBracketKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("length",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("length");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getCharTypeAccess().getLengthINTTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}

// "]"
protected class CharType_RightSquareBracketKeyword_2_2 extends KeywordToken  {
	
	public CharType_RightSquareBracketKeyword_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCharTypeAccess().getRightSquareBracketKeyword_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharType_LengthAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule charType ****************/


/************ begin Rule pointer ****************
 *
 * pointer:
 *   {pointer} "ptr" type=type?;
 *
 **/

// {pointer} "ptr" type=type?
protected class Pointer_Group extends GroupToken {
	
	public Pointer_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPointerAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Pointer_TypeAssignment_2(parent, this, 0, inst);
			case 1: return new Pointer_PtrKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPointerRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {pointer}
protected class Pointer_PointerAction_0 extends ActionToken  {

	public Pointer_PointerAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPointerAccess().getPointerAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPointerAccess().getPointerAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "ptr"
protected class Pointer_PtrKeyword_1 extends KeywordToken  {
	
	public Pointer_PtrKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPointerAccess().getPtrKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Pointer_PointerAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=type?
protected class Pointer_TypeAssignment_2 extends AssignmentToken  {
	
	public Pointer_TypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPointerAccess().getTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Pointer_PtrKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getPointerAccess().getTypeTypeParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule pointer ****************/


/************ begin Rule setType ****************
 *
 * setType:
 *   {setType} "set" type=type?;
 *
 **/

// {setType} "set" type=type?
protected class SetType_Group extends GroupToken {
	
	public SetType_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSetTypeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetType_TypeAssignment_2(parent, this, 0, inst);
			case 1: return new SetType_SetKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSetTypeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {setType}
protected class SetType_SetTypeAction_0 extends ActionToken  {

	public SetType_SetTypeAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getSetTypeAccess().getSetTypeAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getSetTypeAccess().getSetTypeAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "set"
protected class SetType_SetKeyword_1 extends KeywordToken  {
	
	public SetType_SetKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSetTypeAccess().getSetKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetType_SetTypeAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=type?
protected class SetType_TypeAssignment_2 extends AssignmentToken  {
	
	public SetType_TypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSetTypeAccess().getTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SetType_SetKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getSetTypeAccess().getTypeTypeParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule setType ****************/


/************ begin Rule subFieldDeclaration ****************
 *
 * subFieldDeclaration:
 *   subFieldOf=[fieldDeclaration] "->" d=declaration; 
 * 
 * 
 * 	        
 * 
 * 
 * //TODO: add keyword
 *
 **/

// subFieldOf=[fieldDeclaration] "->" d=declaration
protected class SubFieldDeclaration_Group extends GroupToken {
	
	public SubFieldDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSubFieldDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SubFieldDeclaration_DAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSubFieldDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// subFieldOf=[fieldDeclaration]
protected class SubFieldDeclaration_SubFieldOfAssignment_0 extends AssignmentToken  {
	
	public SubFieldDeclaration_SubFieldOfAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSubFieldDeclarationAccess().getSubFieldOfAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("subFieldOf",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("subFieldOf");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSubFieldDeclarationAccess().getSubFieldOfFieldDeclarationCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSubFieldDeclarationAccess().getSubFieldOfFieldDeclarationCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "->"
protected class SubFieldDeclaration_HyphenMinusGreaterThanSignKeyword_1 extends KeywordToken  {
	
	public SubFieldDeclaration_HyphenMinusGreaterThanSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSubFieldDeclarationAccess().getHyphenMinusGreaterThanSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SubFieldDeclaration_SubFieldOfAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// d=declaration
protected class SubFieldDeclaration_DAssignment_2 extends AssignmentToken  {
	
	public SubFieldDeclaration_DAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSubFieldDeclarationAccess().getDAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Declaration_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("d",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("d");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSubFieldDeclarationAccess().getDDeclarationParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SubFieldDeclaration_HyphenMinusGreaterThanSignKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule subFieldDeclaration ****************/



/************ begin Rule titleDeclaration ****************
 *
 * titleDeclaration:
 *   "!" "title" "=" title=title; 
 * 
 * 
 * 
 * // !title = name
 *
 **/

// "!" "title" "=" title=title
protected class TitleDeclaration_Group extends GroupToken {
	
	public TitleDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTitleDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TitleDeclaration_TitleAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTitleDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "!"
protected class TitleDeclaration_ExclamationMarkKeyword_0 extends KeywordToken  {
	
	public TitleDeclaration_ExclamationMarkKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTitleDeclarationAccess().getExclamationMarkKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "title"
protected class TitleDeclaration_TitleKeyword_1 extends KeywordToken  {
	
	public TitleDeclaration_TitleKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTitleDeclarationAccess().getTitleKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TitleDeclaration_ExclamationMarkKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class TitleDeclaration_EqualsSignKeyword_2 extends KeywordToken  {
	
	public TitleDeclaration_EqualsSignKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTitleDeclarationAccess().getEqualsSignKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TitleDeclaration_TitleKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// title=title
protected class TitleDeclaration_TitleAssignment_3 extends AssignmentToken  {
	
	public TitleDeclaration_TitleAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTitleDeclarationAccess().getTitleAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Title_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("title",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("title");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTitleRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTitleDeclarationAccess().getTitleTitleParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TitleDeclaration_EqualsSignKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule titleDeclaration ****************/


/************ begin Rule title ****************
 *
 * title:
 *   name=type|functionCall; 
 * 
 *        
 * 
 * 
 * // !include = general.Address
 *
 **/

// name=type|functionCall 
// 
//        
// 
// 
// // !include = general.Address
protected class Title_Alternatives extends AlternativesToken {

	public Title_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTitleAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Title_NameAssignment_0(parent, this, 0, inst);
			case 1: return new Title_FunctionCallParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTitleRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=type
protected class Title_NameAssignment_0 extends AssignmentToken  {
	
	public Title_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTitleAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getTitleAccess().getNameTypeParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// functionCall
protected class Title_FunctionCallParserRuleCall_1 extends RuleCallToken {
	
	public Title_FunctionCallParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTitleAccess().getFunctionCallParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FunctionCall_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFunctionCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule title ****************/


/************ begin Rule includeDeclaration ****************
 *
 * includeDeclaration:
 *   "!" "include" "=" importedNamespace=type; 
 * 
 * 
 * // !include = general.Address
 * 
 *           
 * 
 * // !type.genDef = ...
 *
 **/

// "!" "include" "=" importedNamespace=type
protected class IncludeDeclaration_Group extends GroupToken {
	
	public IncludeDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIncludeDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDeclaration_ImportedNamespaceAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIncludeDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "!"
protected class IncludeDeclaration_ExclamationMarkKeyword_0 extends KeywordToken  {
	
	public IncludeDeclaration_ExclamationMarkKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIncludeDeclarationAccess().getExclamationMarkKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "include"
protected class IncludeDeclaration_IncludeKeyword_1 extends KeywordToken  {
	
	public IncludeDeclaration_IncludeKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIncludeDeclarationAccess().getIncludeKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDeclaration_ExclamationMarkKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class IncludeDeclaration_EqualsSignKeyword_2 extends KeywordToken  {
	
	public IncludeDeclaration_EqualsSignKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIncludeDeclarationAccess().getEqualsSignKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDeclaration_IncludeKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// importedNamespace=type
protected class IncludeDeclaration_ImportedNamespaceAssignment_3 extends AssignmentToken  {
	
	public IncludeDeclaration_ImportedNamespaceAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIncludeDeclarationAccess().getImportedNamespaceAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IncludeDeclaration_EqualsSignKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("importedNamespace",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("importedNamespace");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getIncludeDeclarationAccess().getImportedNamespaceTypeParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule includeDeclaration ****************/


/************ begin Rule typeDeclaration ****************
 *
 * typeDeclaration:
 *   "!" "type" "." name=ID "=" fieldType=fieldType;   
 * 
 * // !type.genDef = ...
 * 
 *                      
 * 
 * ///// Validation Rules
 *
 **/

// "!" "type" "." name=ID "=" fieldType=fieldType
protected class TypeDeclaration_Group extends GroupToken {
	
	public TypeDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDeclaration_FieldTypeAssignment_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "!"
protected class TypeDeclaration_ExclamationMarkKeyword_0 extends KeywordToken  {
	
	public TypeDeclaration_ExclamationMarkKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeDeclarationAccess().getExclamationMarkKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "type"
protected class TypeDeclaration_TypeKeyword_1 extends KeywordToken  {
	
	public TypeDeclaration_TypeKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeDeclarationAccess().getTypeKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDeclaration_ExclamationMarkKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "."
protected class TypeDeclaration_FullStopKeyword_2 extends KeywordToken  {
	
	public TypeDeclaration_FullStopKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeDeclarationAccess().getFullStopKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDeclaration_TypeKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class TypeDeclaration_NameAssignment_3 extends AssignmentToken  {
	
	public TypeDeclaration_NameAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeDeclarationAccess().getNameAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDeclaration_FullStopKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getTypeDeclarationAccess().getNameIDTerminalRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// "="
protected class TypeDeclaration_EqualsSignKeyword_4 extends KeywordToken  {
	
	public TypeDeclaration_EqualsSignKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeDeclarationAccess().getEqualsSignKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeDeclaration_NameAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// fieldType=fieldType
protected class TypeDeclaration_FieldTypeAssignment_5 extends AssignmentToken  {
	
	public TypeDeclaration_FieldTypeAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeDeclarationAccess().getFieldTypeAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FieldType_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fieldType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fieldType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFieldTypeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypeDeclarationAccess().getFieldTypeFieldTypeParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypeDeclaration_EqualsSignKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule typeDeclaration ****************/


/************ begin Rule validationRuleDeclaration ****************
 *
 * validationRuleDeclaration:
 *   (rangeValidationRuleDeclaration|uniquenessValidationRuleDeclaration|
 *   comparisonValidationRuleDeclaration|regexValidationRuleDeclaration) errorMessage=
 *   errorMessage; 
 * 
 * ///// Validation Rules
 *
 **/

// (rangeValidationRuleDeclaration|uniquenessValidationRuleDeclaration|
// comparisonValidationRuleDeclaration|regexValidationRuleDeclaration) errorMessage=
// errorMessage
protected class ValidationRuleDeclaration_Group extends GroupToken {
	
	public ValidationRuleDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getValidationRuleDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValidationRuleDeclaration_ErrorMessageAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// rangeValidationRuleDeclaration|uniquenessValidationRuleDeclaration|
// comparisonValidationRuleDeclaration|regexValidationRuleDeclaration
protected class ValidationRuleDeclaration_Alternatives_0 extends AlternativesToken {

	public ValidationRuleDeclaration_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getValidationRuleDeclarationAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ValidationRuleDeclaration_RangeValidationRuleDeclarationParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new ValidationRuleDeclaration_UniquenessValidationRuleDeclarationParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new ValidationRuleDeclaration_ComparisonValidationRuleDeclarationParserRuleCall_0_2(parent, this, 2, inst);
			case 3: return new ValidationRuleDeclaration_RegexValidationRuleDeclarationParserRuleCall_0_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
}

// rangeValidationRuleDeclaration
protected class ValidationRuleDeclaration_RangeValidationRuleDeclarationParserRuleCall_0_0 extends RuleCallToken {
	
	public ValidationRuleDeclaration_RangeValidationRuleDeclarationParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValidationRuleDeclarationAccess().getRangeValidationRuleDeclarationParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RangeValidationRuleDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RangeValidationRuleDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRangeValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// uniquenessValidationRuleDeclaration
protected class ValidationRuleDeclaration_UniquenessValidationRuleDeclarationParserRuleCall_0_1 extends RuleCallToken {
	
	public ValidationRuleDeclaration_UniquenessValidationRuleDeclarationParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValidationRuleDeclarationAccess().getUniquenessValidationRuleDeclarationParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UniquenessValidationRuleDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UniquenessValidationRuleDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUniquenessValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// comparisonValidationRuleDeclaration
protected class ValidationRuleDeclaration_ComparisonValidationRuleDeclarationParserRuleCall_0_2 extends RuleCallToken {
	
	public ValidationRuleDeclaration_ComparisonValidationRuleDeclarationParserRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValidationRuleDeclarationAccess().getComparisonValidationRuleDeclarationParserRuleCall_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ComparisonValidationRuleDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ComparisonValidationRuleDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getComparisonValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// regexValidationRuleDeclaration
protected class ValidationRuleDeclaration_RegexValidationRuleDeclarationParserRuleCall_0_3 extends RuleCallToken {
	
	public ValidationRuleDeclaration_RegexValidationRuleDeclarationParserRuleCall_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getValidationRuleDeclarationAccess().getRegexValidationRuleDeclarationParserRuleCall_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegexValidationRuleDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RegexValidationRuleDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRegexValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


// errorMessage=errorMessage
protected class ValidationRuleDeclaration_ErrorMessageAssignment_1 extends AssignmentToken  {
	
	public ValidationRuleDeclaration_ErrorMessageAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getValidationRuleDeclarationAccess().getErrorMessageAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ErrorMessage_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("errorMessage",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("errorMessage");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getErrorMessageRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getValidationRuleDeclarationAccess().getErrorMessageErrorMessageParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ValidationRuleDeclaration_Alternatives_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule validationRuleDeclaration ****************/


/************ begin Rule comparisonValidationRuleDeclaration ****************
 *
 * comparisonValidationRuleDeclaration:
 *   name="compare" args=functionArguments "{" comparisonExp=comparisonExpression "}"; 
 * 
 * 
 * 	          
 * 	
 * 
 * //////// COMPARISON EXPRESSION
 *
 **/

// name="compare" args=functionArguments "{" comparisonExp=comparisonExpression "}"
protected class ComparisonValidationRuleDeclaration_Group extends GroupToken {
	
	public ComparisonValidationRuleDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getComparisonValidationRuleDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ComparisonValidationRuleDeclaration_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getComparisonValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name="compare"
protected class ComparisonValidationRuleDeclaration_NameAssignment_0 extends AssignmentToken  {
	
	public ComparisonValidationRuleDeclaration_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonValidationRuleDeclarationAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if("compare".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getComparisonValidationRuleDeclarationAccess().getNameCompareKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// args=functionArguments
protected class ComparisonValidationRuleDeclaration_ArgsAssignment_1 extends AssignmentToken  {
	
	public ComparisonValidationRuleDeclaration_ArgsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonValidationRuleDeclarationAccess().getArgsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("args",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("args");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionArgumentsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getComparisonValidationRuleDeclarationAccess().getArgsFunctionArgumentsParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ComparisonValidationRuleDeclaration_NameAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "{"
protected class ComparisonValidationRuleDeclaration_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public ComparisonValidationRuleDeclaration_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getComparisonValidationRuleDeclarationAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ComparisonValidationRuleDeclaration_ArgsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// comparisonExp=comparisonExpression
protected class ComparisonValidationRuleDeclaration_ComparisonExpAssignment_3 extends AssignmentToken  {
	
	public ComparisonValidationRuleDeclaration_ComparisonExpAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonValidationRuleDeclarationAccess().getComparisonExpAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ComparisonExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("comparisonExp",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("comparisonExp");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getComparisonExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getComparisonValidationRuleDeclarationAccess().getComparisonExpComparisonExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ComparisonValidationRuleDeclaration_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class ComparisonValidationRuleDeclaration_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public ComparisonValidationRuleDeclaration_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getComparisonValidationRuleDeclarationAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ComparisonValidationRuleDeclaration_ComparisonExpAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule comparisonValidationRuleDeclaration ****************/


/************ begin Rule comparisonExpression ****************
 *
 * comparisonExpression:
 *   lhs=comparisonPart o=operator rhs=comparisonPart; 
 * 
 * //////// COMPARISON EXPRESSION
 *
 **/

// lhs=comparisonPart o=operator rhs=comparisonPart
protected class ComparisonExpression_Group extends GroupToken {
	
	public ComparisonExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ComparisonExpression_RhsAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getComparisonExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// lhs=comparisonPart
protected class ComparisonExpression_LhsAssignment_0 extends AssignmentToken  {
	
	public ComparisonExpression_LhsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getLhsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ComparisonPart_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("lhs",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("lhs");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getComparisonPartRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getComparisonExpressionAccess().getLhsComparisonPartParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// o=operator
protected class ComparisonExpression_OAssignment_1 extends AssignmentToken  {
	
	public ComparisonExpression_OAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getOAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ComparisonExpression_LhsAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("o",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("o");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getComparisonExpressionAccess().getOOperatorParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// rhs=comparisonPart
protected class ComparisonExpression_RhsAssignment_2 extends AssignmentToken  {
	
	public ComparisonExpression_RhsAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonExpressionAccess().getRhsAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ComparisonPart_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rhs",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rhs");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getComparisonPartRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getComparisonExpressionAccess().getRhsComparisonPartParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ComparisonExpression_OAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule comparisonExpression ****************/


/************ begin Rule comparisonPart ****************
 *
 * comparisonPart:
 *   t=type|n=INT|df=dateFunction|u=upperFunction|l=lowerFunction|d=dateConstant; 
 * 	
 * 
 * 	  
 * 	    //number
 * 	   
 * 	  
 * 	  
 * 	  
 * 	
 * 
 * // here we pass only the type name of the argument, with the function as type
 *
 **/

// t=type|n=INT|df=dateFunction|u=upperFunction|l=lowerFunction|d=dateConstant 
// 	
// 
// 	  
// 	    //number
// 	   
// 	  
// 	  
// 	  
// 	
// 
// // here we pass only the type name of the argument, with the function as type
protected class ComparisonPart_Alternatives extends AlternativesToken {

	public ComparisonPart_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getComparisonPartAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ComparisonPart_TAssignment_0(parent, this, 0, inst);
			case 1: return new ComparisonPart_NAssignment_1(parent, this, 1, inst);
			case 2: return new ComparisonPart_DfAssignment_2(parent, this, 2, inst);
			case 3: return new ComparisonPart_UAssignment_3(parent, this, 3, inst);
			case 4: return new ComparisonPart_LAssignment_4(parent, this, 4, inst);
			case 5: return new ComparisonPart_DAssignment_5(parent, this, 5, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getComparisonPartRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// t=type
protected class ComparisonPart_TAssignment_0 extends AssignmentToken  {
	
	public ComparisonPart_TAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonPartAccess().getTAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("t",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("t");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getComparisonPartAccess().getTTypeParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// n=INT     //number
protected class ComparisonPart_NAssignment_1 extends AssignmentToken  {
	
	public ComparisonPart_NAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonPartAccess().getNAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("n",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("n");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getComparisonPartAccess().getNINTTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// df=dateFunction
protected class ComparisonPart_DfAssignment_2 extends AssignmentToken  {
	
	public ComparisonPart_DfAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonPartAccess().getDfAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("df",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("df");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getComparisonPartAccess().getDfDateFunctionParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// u=upperFunction
protected class ComparisonPart_UAssignment_3 extends AssignmentToken  {
	
	public ComparisonPart_UAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonPartAccess().getUAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UpperFunction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("u",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("u");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUpperFunctionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getComparisonPartAccess().getUUpperFunctionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// l=lowerFunction
protected class ComparisonPart_LAssignment_4 extends AssignmentToken  {
	
	public ComparisonPart_LAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonPartAccess().getLAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LowerFunction_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("l",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("l");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLowerFunctionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getComparisonPartAccess().getLLowerFunctionParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// d=dateConstant
protected class ComparisonPart_DAssignment_5 extends AssignmentToken  {
	
	public ComparisonPart_DAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getComparisonPartAccess().getDAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("d",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("d");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getComparisonPartAccess().getDDateConstantParserRuleCall_5_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule comparisonPart ****************/


/************ begin Rule upperFunction ****************
 *
 * upperFunction:
 *   "upper" "(" t=type ")"; 
 * 
 * // here we pass only the type name of the argument, with the function as type
 * 
 * 	        
 * 	
 * 
 * // here we pass only the type name of the argument, with the function as type
 *
 **/

// "upper" "(" t=type ")"
protected class UpperFunction_Group extends GroupToken {
	
	public UpperFunction_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUpperFunctionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UpperFunction_RightParenthesisKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUpperFunctionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "upper"
protected class UpperFunction_UpperKeyword_0 extends KeywordToken  {
	
	public UpperFunction_UpperKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUpperFunctionAccess().getUpperKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "("
protected class UpperFunction_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public UpperFunction_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUpperFunctionAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UpperFunction_UpperKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// t=type
protected class UpperFunction_TAssignment_2 extends AssignmentToken  {
	
	public UpperFunction_TAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUpperFunctionAccess().getTAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UpperFunction_LeftParenthesisKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("t",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("t");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getUpperFunctionAccess().getTTypeParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// ")"
protected class UpperFunction_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public UpperFunction_RightParenthesisKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUpperFunctionAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UpperFunction_TAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule upperFunction ****************/


/************ begin Rule lowerFunction ****************
 *
 * lowerFunction:
 *   "lower" "(" t=type ")"; 
 * 
 * // here we pass only the type name of the argument, with the function as type
 *
 **/

// "lower" "(" t=type ")"
protected class LowerFunction_Group extends GroupToken {
	
	public LowerFunction_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLowerFunctionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LowerFunction_RightParenthesisKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLowerFunctionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "lower"
protected class LowerFunction_LowerKeyword_0 extends KeywordToken  {
	
	public LowerFunction_LowerKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLowerFunctionAccess().getLowerKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "("
protected class LowerFunction_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public LowerFunction_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLowerFunctionAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LowerFunction_LowerKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// t=type
protected class LowerFunction_TAssignment_2 extends AssignmentToken  {
	
	public LowerFunction_TAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLowerFunctionAccess().getTAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LowerFunction_LeftParenthesisKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("t",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("t");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getLowerFunctionAccess().getTTypeParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}

// ")"
protected class LowerFunction_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public LowerFunction_RightParenthesisKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getLowerFunctionAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LowerFunction_TAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule lowerFunction ****************/







/************ begin Rule rangeValidationRuleDeclaration ****************
 *
 * rangeValidationRuleDeclaration:
 *   name=( "range" | "length" ) args=functionArguments "{" range=range "}"; 
 * 
 * 
 * //////// RANGE DEFINITION
 *
 **/

// name=( "range" | "length" ) args=functionArguments "{" range=range "}"
protected class RangeValidationRuleDeclaration_Group extends GroupToken {
	
	public RangeValidationRuleDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRangeValidationRuleDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RangeValidationRuleDeclaration_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRangeValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=( "range" | "length" )
protected class RangeValidationRuleDeclaration_NameAssignment_0 extends AssignmentToken  {
	
	public RangeValidationRuleDeclaration_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRangeValidationRuleDeclarationAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if("range".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRangeValidationRuleDeclarationAccess().getNameRangeKeyword_0_0_0();
			return obj;
		}
		if("length".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRangeValidationRuleDeclarationAccess().getNameLengthKeyword_0_0_1();
			return obj;
		}
		return null;
	}

}

// args=functionArguments
protected class RangeValidationRuleDeclaration_ArgsAssignment_1 extends AssignmentToken  {
	
	public RangeValidationRuleDeclaration_ArgsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRangeValidationRuleDeclarationAccess().getArgsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("args",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("args");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionArgumentsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRangeValidationRuleDeclarationAccess().getArgsFunctionArgumentsParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RangeValidationRuleDeclaration_NameAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "{"
protected class RangeValidationRuleDeclaration_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public RangeValidationRuleDeclaration_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRangeValidationRuleDeclarationAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RangeValidationRuleDeclaration_ArgsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// range=range
protected class RangeValidationRuleDeclaration_RangeAssignment_3 extends AssignmentToken  {
	
	public RangeValidationRuleDeclaration_RangeAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRangeValidationRuleDeclarationAccess().getRangeAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Range_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("range",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("range");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRangeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRangeValidationRuleDeclarationAccess().getRangeRangeParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RangeValidationRuleDeclaration_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class RangeValidationRuleDeclaration_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public RangeValidationRuleDeclaration_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRangeValidationRuleDeclarationAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RangeValidationRuleDeclaration_RangeAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule rangeValidationRuleDeclaration ****************/


/************ begin Rule regexValidationRuleDeclaration ****************
 *
 * regexValidationRuleDeclaration:
 *   name="matches" args=functionArguments "{" exp=STRING "}"; 
 * 	
 * 
 * 	          
 * 	
 * 
 * // name%length = [1..?]
 * // age%range = [18..99]
 *
 **/

// name="matches" args=functionArguments "{" exp=STRING "}"
protected class RegexValidationRuleDeclaration_Group extends GroupToken {
	
	public RegexValidationRuleDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRegexValidationRuleDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegexValidationRuleDeclaration_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRegexValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name="matches"
protected class RegexValidationRuleDeclaration_NameAssignment_0 extends AssignmentToken  {
	
	public RegexValidationRuleDeclaration_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegexValidationRuleDeclarationAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if("matches".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRegexValidationRuleDeclarationAccess().getNameMatchesKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// args=functionArguments
protected class RegexValidationRuleDeclaration_ArgsAssignment_1 extends AssignmentToken  {
	
	public RegexValidationRuleDeclaration_ArgsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegexValidationRuleDeclarationAccess().getArgsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("args",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("args");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionArgumentsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRegexValidationRuleDeclarationAccess().getArgsFunctionArgumentsParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RegexValidationRuleDeclaration_NameAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "{"
protected class RegexValidationRuleDeclaration_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public RegexValidationRuleDeclaration_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegexValidationRuleDeclarationAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegexValidationRuleDeclaration_ArgsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// exp=STRING
protected class RegexValidationRuleDeclaration_ExpAssignment_3 extends AssignmentToken  {
	
	public RegexValidationRuleDeclaration_ExpAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRegexValidationRuleDeclarationAccess().getExpAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegexValidationRuleDeclaration_LeftCurlyBracketKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("exp",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("exp");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getRegexValidationRuleDeclarationAccess().getExpSTRINGTerminalRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// "}"
protected class RegexValidationRuleDeclaration_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public RegexValidationRuleDeclaration_RightCurlyBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRegexValidationRuleDeclarationAccess().getRightCurlyBracketKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RegexValidationRuleDeclaration_ExpAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule regexValidationRuleDeclaration ****************/


/************ begin Rule range ****************
 *
 * range:
 *   f=rangeBound ".." t=rangeBound; 
 * 
 * // name%length = [1..?]
 * // age%range = [18..99]
 * 
 *      
 *             
 *     
 * 
 * // [1..?] [?..5]
 *
 **/

// f=rangeBound ".." t=rangeBound
protected class Range_Group extends GroupToken {
	
	public Range_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRangeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Range_TAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRangeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// f=rangeBound
protected class Range_FAssignment_0 extends AssignmentToken  {
	
	public Range_FAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRangeAccess().getFAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("f",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("f");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getRangeAccess().getFRangeBoundParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ".."
protected class Range_FullStopFullStopKeyword_1 extends KeywordToken  {
	
	public Range_FullStopFullStopKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRangeAccess().getFullStopFullStopKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Range_FAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// t=rangeBound
protected class Range_TAssignment_2 extends AssignmentToken  {
	
	public Range_TAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRangeAccess().getTAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Range_FullStopFullStopKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("t",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("t");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getRangeAccess().getTRangeBoundParserRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule range ****************/



/************ begin Rule uniquenessValidationRuleDeclaration ****************
 *
 * uniquenessValidationRuleDeclaration:
 *   name="unique" args=functionArguments; 
 * 
 * // unique(field1, field2) : "These need to be unique"
 *
 **/

// name="unique" args=functionArguments
protected class UniquenessValidationRuleDeclaration_Group extends GroupToken {
	
	public UniquenessValidationRuleDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUniquenessValidationRuleDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UniquenessValidationRuleDeclaration_ArgsAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUniquenessValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name="unique"
protected class UniquenessValidationRuleDeclaration_NameAssignment_0 extends AssignmentToken  {
	
	public UniquenessValidationRuleDeclaration_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUniquenessValidationRuleDeclarationAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if("unique".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUniquenessValidationRuleDeclarationAccess().getNameUniqueKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// args=functionArguments
protected class UniquenessValidationRuleDeclaration_ArgsAssignment_1 extends AssignmentToken  {
	
	public UniquenessValidationRuleDeclaration_ArgsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUniquenessValidationRuleDeclarationAccess().getArgsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("args",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("args");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionArgumentsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUniquenessValidationRuleDeclarationAccess().getArgsFunctionArgumentsParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UniquenessValidationRuleDeclaration_NameAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule uniquenessValidationRuleDeclaration ****************/


/************ begin Rule errorMessage ****************
 *
 * errorMessage:
 *   ":" message=STRING;
 *
 **/

// ":" message=STRING
protected class ErrorMessage_Group extends GroupToken {
	
	public ErrorMessage_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getErrorMessageAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ErrorMessage_MessageAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getErrorMessageRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ":"
protected class ErrorMessage_ColonKeyword_0 extends KeywordToken  {
	
	public ErrorMessage_ColonKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getErrorMessageAccess().getColonKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// message=STRING
protected class ErrorMessage_MessageAssignment_1 extends AssignmentToken  {
	
	public ErrorMessage_MessageAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getErrorMessageAccess().getMessageAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ErrorMessage_ColonKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("message",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("message");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getErrorMessageAccess().getMessageSTRINGTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule errorMessage ****************/


/************ begin Rule nativeValidationRuleDeclaration ****************
 *
 * nativeValidationRuleDeclaration:
 *   field=[fieldDeclaration] "." type=( "unique" | "notNull" | "NaN" | "notEmpty" | "notInt" |
 *   "notReal" | "notBoolean" ) "=" message=STRING; 
 * 
 * 
 *         
 *       
 *         
 *         
 *         
 *         
 *         
 *         
 *         
 *       
 *       
 *       
 *     
 * 
 * 
 * ///// Functions
 *
 **/

// field=[fieldDeclaration] "." type=( "unique" | "notNull" | "NaN" | "notEmpty" | "notInt" |
// "notReal" | "notBoolean" ) "=" message=STRING
protected class NativeValidationRuleDeclaration_Group extends GroupToken {
	
	public NativeValidationRuleDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNativeValidationRuleDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NativeValidationRuleDeclaration_MessageAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNativeValidationRuleDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// field=[fieldDeclaration]
protected class NativeValidationRuleDeclaration_FieldAssignment_0 extends AssignmentToken  {
	
	public NativeValidationRuleDeclaration_FieldAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNativeValidationRuleDeclarationAccess().getFieldAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("field",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("field");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNativeValidationRuleDeclarationAccess().getFieldFieldDeclarationCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getNativeValidationRuleDeclarationAccess().getFieldFieldDeclarationCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "."
protected class NativeValidationRuleDeclaration_FullStopKeyword_1 extends KeywordToken  {
	
	public NativeValidationRuleDeclaration_FullStopKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNativeValidationRuleDeclarationAccess().getFullStopKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NativeValidationRuleDeclaration_FieldAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=( "unique" | "notNull" | "NaN" | "notEmpty" | "notInt" | "notReal" | "notBoolean" )
protected class NativeValidationRuleDeclaration_TypeAssignment_2 extends AssignmentToken  {
	
	public NativeValidationRuleDeclaration_TypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNativeValidationRuleDeclarationAccess().getTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NativeValidationRuleDeclaration_FullStopKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if("unique".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getNativeValidationRuleDeclarationAccess().getTypeUniqueKeyword_2_0_0();
			return obj;
		}
		if("notNull".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getNativeValidationRuleDeclarationAccess().getTypeNotNullKeyword_2_0_1();
			return obj;
		}
		if("NaN".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getNativeValidationRuleDeclarationAccess().getTypeNaNKeyword_2_0_2();
			return obj;
		}
		if("notEmpty".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getNativeValidationRuleDeclarationAccess().getTypeNotEmptyKeyword_2_0_3();
			return obj;
		}
		if("notInt".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getNativeValidationRuleDeclarationAccess().getTypeNotIntKeyword_2_0_4();
			return obj;
		}
		if("notReal".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getNativeValidationRuleDeclarationAccess().getTypeNotRealKeyword_2_0_5();
			return obj;
		}
		if("notBoolean".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getNativeValidationRuleDeclarationAccess().getTypeNotBooleanKeyword_2_0_6();
			return obj;
		}
		return null;
	}

}

// "="
protected class NativeValidationRuleDeclaration_EqualsSignKeyword_3 extends KeywordToken  {
	
	public NativeValidationRuleDeclaration_EqualsSignKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNativeValidationRuleDeclarationAccess().getEqualsSignKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NativeValidationRuleDeclaration_TypeAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// message=STRING
protected class NativeValidationRuleDeclaration_MessageAssignment_4 extends AssignmentToken  {
	
	public NativeValidationRuleDeclaration_MessageAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNativeValidationRuleDeclarationAccess().getMessageAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NativeValidationRuleDeclaration_EqualsSignKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("message",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("message");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getNativeValidationRuleDeclarationAccess().getMessageSTRINGTerminalRuleCall_4_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule nativeValidationRuleDeclaration ****************/


/************ begin Rule functionDeclaration ****************
 *
 * functionDeclaration:
 *   (b=ID "%")? name=ID arg=functionArgumentDeclaration body=functionBody m=errorMessage?
 * ; 
 * 
 * 
 * ///// Functions
 *
 **/

// (b=ID "%")? name=ID arg=functionArgumentDeclaration body=functionBody m=errorMessage?
protected class FunctionDeclaration_Group extends GroupToken {
	
	public FunctionDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionDeclaration_MAssignment_4(parent, this, 0, inst);
			case 1: return new FunctionDeclaration_BodyAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFunctionDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// (b=ID "%")?
protected class FunctionDeclaration_Group_0 extends GroupToken {
	
	public FunctionDeclaration_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionDeclarationAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionDeclaration_PercentSignKeyword_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// b=ID
protected class FunctionDeclaration_BAssignment_0_0 extends AssignmentToken  {
	
	public FunctionDeclaration_BAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionDeclarationAccess().getBAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("b",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("b");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getFunctionDeclarationAccess().getBIDTerminalRuleCall_0_0_0();
			return obj;
		}
		return null;
	}

}

// "%"
protected class FunctionDeclaration_PercentSignKeyword_0_1 extends KeywordToken  {
	
	public FunctionDeclaration_PercentSignKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionDeclarationAccess().getPercentSignKeyword_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionDeclaration_BAssignment_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// name=ID
protected class FunctionDeclaration_NameAssignment_1 extends AssignmentToken  {
	
	public FunctionDeclaration_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionDeclarationAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionDeclaration_Group_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getFunctionDeclarationAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// arg=functionArgumentDeclaration
protected class FunctionDeclaration_ArgAssignment_2 extends AssignmentToken  {
	
	public FunctionDeclaration_ArgAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionDeclarationAccess().getArgAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("arg",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("arg");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionArgumentDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionDeclarationAccess().getArgFunctionArgumentDeclarationParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionDeclaration_NameAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// body=functionBody
protected class FunctionDeclaration_BodyAssignment_3 extends AssignmentToken  {
	
	public FunctionDeclaration_BodyAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionDeclarationAccess().getBodyAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionBody_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("body",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("body");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionBodyRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionDeclarationAccess().getBodyFunctionBodyParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionDeclaration_ArgAssignment_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// m=errorMessage?
protected class FunctionDeclaration_MAssignment_4 extends AssignmentToken  {
	
	public FunctionDeclaration_MAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionDeclarationAccess().getMAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ErrorMessage_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("m",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("m");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getErrorMessageRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionDeclarationAccess().getMErrorMessageParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionDeclaration_BodyAssignment_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule functionDeclaration ****************/


/************ begin Rule functionArgumentDeclaration ****************
 *
 * functionArgumentDeclaration:
 *   {functionArgumentDeclaration} "(" f+=functionArgumentBody? ("," f+=
 *   functionArgumentBody)* ")"; 
 *   
 * 
 *           
 * 
 * // TODO: fix this so that function label can show param type instead of the name
 * // ugly fix until the syntax change
 *
 **/

// {functionArgumentDeclaration} "(" f+=functionArgumentBody? ("," f+=
// functionArgumentBody)* ")"
protected class FunctionArgumentDeclaration_Group extends GroupToken {
	
	public FunctionArgumentDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionArgumentDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentDeclaration_RightParenthesisKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFunctionArgumentDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {functionArgumentDeclaration}
protected class FunctionArgumentDeclaration_FunctionArgumentDeclarationAction_0 extends ActionToken  {

	public FunctionArgumentDeclaration_FunctionArgumentDeclarationAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getFunctionArgumentDeclarationAccess().getFunctionArgumentDeclarationAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getFunctionArgumentDeclarationAccess().getFunctionArgumentDeclarationAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "("
protected class FunctionArgumentDeclaration_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public FunctionArgumentDeclaration_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionArgumentDeclarationAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentDeclaration_FunctionArgumentDeclarationAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// f+=functionArgumentBody?
protected class FunctionArgumentDeclaration_FAssignment_2 extends AssignmentToken  {
	
	public FunctionArgumentDeclaration_FAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionArgumentDeclarationAccess().getFAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("f",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("f");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionArgumentBodyRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionArgumentDeclarationAccess().getFFunctionArgumentBodyParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionArgumentDeclaration_LeftParenthesisKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," f+=functionArgumentBody)*
protected class FunctionArgumentDeclaration_Group_3 extends GroupToken {
	
	public FunctionArgumentDeclaration_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionArgumentDeclarationAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentDeclaration_FAssignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class FunctionArgumentDeclaration_CommaKeyword_3_0 extends KeywordToken  {
	
	public FunctionArgumentDeclaration_CommaKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionArgumentDeclarationAccess().getCommaKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentDeclaration_Group_3(parent, this, 0, inst);
			case 1: return new FunctionArgumentDeclaration_FAssignment_2(parent, this, 1, inst);
			case 2: return new FunctionArgumentDeclaration_LeftParenthesisKeyword_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// f+=functionArgumentBody
protected class FunctionArgumentDeclaration_FAssignment_3_1 extends AssignmentToken  {
	
	public FunctionArgumentDeclaration_FAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionArgumentDeclarationAccess().getFAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("f",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("f");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionArgumentBodyRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionArgumentDeclarationAccess().getFFunctionArgumentBodyParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionArgumentDeclaration_CommaKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ")"
protected class FunctionArgumentDeclaration_RightParenthesisKeyword_4 extends KeywordToken  {
	
	public FunctionArgumentDeclaration_RightParenthesisKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionArgumentDeclarationAccess().getRightParenthesisKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentDeclaration_Group_3(parent, this, 0, inst);
			case 1: return new FunctionArgumentDeclaration_FAssignment_2(parent, this, 1, inst);
			case 2: return new FunctionArgumentDeclaration_LeftParenthesisKeyword_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule functionArgumentDeclaration ****************/


/************ begin Rule functionArgumentBody ****************
 *
 * functionArgumentBody:
 *   (charType|intEnum|"set" intEnum|charEnum|"set" charEnum|"int"|"real"|"boolean"|
 *   "text"|"binary"|"file"|"date"|"ptr" type|"set" type) name=( ID | keyword ); 
 * 
 * // TODO: fix this so that function label can show param type instead of the name
 * // ugly fix until the syntax change
 *
 **/

// (charType|intEnum|"set" intEnum|charEnum|"set" charEnum|"int"|"real"|"boolean"|
// "text"|"binary"|"file"|"date"|"ptr" type|"set" type) name=( ID | keyword )
protected class FunctionArgumentBody_Group extends GroupToken {
	
	public FunctionArgumentBody_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFunctionArgumentBodyRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// charType|intEnum|"set" intEnum|charEnum|"set" charEnum|"int"|"real"|"boolean"|
// "text"|"binary"|"file"|"date"|"ptr" type|"set" type
protected class FunctionArgumentBody_Alternatives_0 extends AlternativesToken {

	public FunctionArgumentBody_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_CharTypeParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new FunctionArgumentBody_IntEnumParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new FunctionArgumentBody_Group_0_2(parent, this, 2, inst);
			case 3: return new FunctionArgumentBody_CharEnumParserRuleCall_0_3(parent, this, 3, inst);
			case 4: return new FunctionArgumentBody_Group_0_4(parent, this, 4, inst);
			case 5: return new FunctionArgumentBody_IntKeyword_0_5(parent, this, 5, inst);
			case 6: return new FunctionArgumentBody_Group_0_12(parent, this, 6, inst);
			case 7: return new FunctionArgumentBody_Group_0_13(parent, this, 7, inst);
			default: return null;
		}	
	}	
		
}

// charType
protected class FunctionArgumentBody_CharTypeParserRuleCall_0_0 extends RuleCallToken {
	
	public FunctionArgumentBody_CharTypeParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getCharTypeParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharType_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CharType_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCharTypeRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// intEnum
protected class FunctionArgumentBody_IntEnumParserRuleCall_0_1 extends RuleCallToken {
	
	public FunctionArgumentBody_IntEnumParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getIntEnumParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntEnum_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntEnum_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntEnumRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// "set" intEnum
protected class FunctionArgumentBody_Group_0_2 extends GroupToken {
	
	public FunctionArgumentBody_Group_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getGroup_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_IntEnumParserRuleCall_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "set"
protected class FunctionArgumentBody_SetKeyword_0_2_0 extends KeywordToken  {
	
	public FunctionArgumentBody_SetKeyword_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getSetKeyword_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// intEnum
protected class FunctionArgumentBody_IntEnumParserRuleCall_0_2_1 extends RuleCallToken {
	
	public FunctionArgumentBody_IntEnumParserRuleCall_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getIntEnumParserRuleCall_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntEnum_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntEnum_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntEnumRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_SetKeyword_0_2_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}


// charEnum
protected class FunctionArgumentBody_CharEnumParserRuleCall_0_3 extends RuleCallToken {
	
	public FunctionArgumentBody_CharEnumParserRuleCall_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getCharEnumParserRuleCall_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharEnum_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CharEnum_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCharEnumRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// "set" charEnum
protected class FunctionArgumentBody_Group_0_4 extends GroupToken {
	
	public FunctionArgumentBody_Group_0_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getGroup_0_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_CharEnumParserRuleCall_0_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "set"
protected class FunctionArgumentBody_SetKeyword_0_4_0 extends KeywordToken  {
	
	public FunctionArgumentBody_SetKeyword_0_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getSetKeyword_0_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// charEnum
protected class FunctionArgumentBody_CharEnumParserRuleCall_0_4_1 extends RuleCallToken {
	
	public FunctionArgumentBody_CharEnumParserRuleCall_0_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getCharEnumParserRuleCall_0_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharEnum_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CharEnum_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCharEnumRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_SetKeyword_0_4_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}


// "int"
protected class FunctionArgumentBody_IntKeyword_0_5 extends KeywordToken  {
	
	public FunctionArgumentBody_IntKeyword_0_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getIntKeyword_0_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "ptr" type
protected class FunctionArgumentBody_Group_0_12 extends GroupToken {
	
	public FunctionArgumentBody_Group_0_12(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getGroup_0_12();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_TypeParserRuleCall_0_12_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "ptr"
protected class FunctionArgumentBody_PtrKeyword_0_12_0 extends KeywordToken  {
	
	public FunctionArgumentBody_PtrKeyword_0_12_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getPtrKeyword_0_12_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// type
protected class FunctionArgumentBody_TypeParserRuleCall_0_12_1 extends UnassignedTextToken {

	public FunctionArgumentBody_TypeParserRuleCall_0_12_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getTypeParserRuleCall_0_12_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_PtrKeyword_0_12_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "set" type
protected class FunctionArgumentBody_Group_0_13 extends GroupToken {
	
	public FunctionArgumentBody_Group_0_13(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getGroup_0_13();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_TypeParserRuleCall_0_13_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "set"
protected class FunctionArgumentBody_SetKeyword_0_13_0 extends KeywordToken  {
	
	public FunctionArgumentBody_SetKeyword_0_13_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getSetKeyword_0_13_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// type
protected class FunctionArgumentBody_TypeParserRuleCall_0_13_1 extends UnassignedTextToken {

	public FunctionArgumentBody_TypeParserRuleCall_0_13_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getTypeParserRuleCall_0_13_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_SetKeyword_0_13_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// name=( ID | keyword )
protected class FunctionArgumentBody_NameAssignment_1 extends AssignmentToken  {
	
	public FunctionArgumentBody_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionArgumentBodyAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArgumentBody_Alternatives_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getFunctionArgumentBodyAccess().getNameIDTerminalRuleCall_1_0_0();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getFunctionArgumentBodyAccess().getNameKeywordParserRuleCall_1_0_1();
			return obj;
		}
		return null;
	}

}


/************ end Rule functionArgumentBody ****************/


/************ begin Rule functionCall ****************
 *
 * functionCall:
 *   name=ID f=functionArguments;
 *
 **/

// name=ID f=functionArguments
protected class FunctionCall_Group extends GroupToken {
	
	public FunctionCall_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionCallAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionCall_FAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFunctionCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class FunctionCall_NameAssignment_0 extends AssignmentToken  {
	
	public FunctionCall_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionCallAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getFunctionCallAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// f=functionArguments
protected class FunctionCall_FAssignment_1 extends AssignmentToken  {
	
	public FunctionCall_FAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionCallAccess().getFAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("f",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("f");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionArgumentsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionCallAccess().getFFunctionArgumentsParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionCall_NameAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule functionCall ****************/


/************ begin Rule functionArguments ****************
 *
 * functionArguments:
 *   {functionArguments} "(" (a+=type ("," a+=type)*)? ")";
 *
 **/

// {functionArguments} "(" (a+=type ("," a+=type)*)? ")"
protected class FunctionArguments_Group extends GroupToken {
	
	public FunctionArguments_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionArgumentsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_RightParenthesisKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFunctionArgumentsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {functionArguments}
protected class FunctionArguments_FunctionArgumentsAction_0 extends ActionToken  {

	public FunctionArguments_FunctionArgumentsAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getFunctionArgumentsAccess().getFunctionArgumentsAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getFunctionArgumentsAccess().getFunctionArgumentsAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "("
protected class FunctionArguments_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public FunctionArguments_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionArgumentsAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_FunctionArgumentsAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (a+=type ("," a+=type)*)?
protected class FunctionArguments_Group_2 extends GroupToken {
	
	public FunctionArguments_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionArgumentsAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_Group_2_1(parent, this, 0, inst);
			case 1: return new FunctionArguments_AAssignment_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// a+=type
protected class FunctionArguments_AAssignment_2_0 extends AssignmentToken  {
	
	public FunctionArguments_AAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionArgumentsAccess().getAAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_LeftParenthesisKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("a",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("a");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getFunctionArgumentsAccess().getATypeParserRuleCall_2_0_0();
			return obj;
		}
		return null;
	}

}

// ("," a+=type)*
protected class FunctionArguments_Group_2_1 extends GroupToken {
	
	public FunctionArguments_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionArgumentsAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_AAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class FunctionArguments_CommaKeyword_2_1_0 extends KeywordToken  {
	
	public FunctionArguments_CommaKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionArgumentsAccess().getCommaKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_Group_2_1(parent, this, 0, inst);
			case 1: return new FunctionArguments_AAssignment_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// a+=type
protected class FunctionArguments_AAssignment_2_1_1 extends AssignmentToken  {
	
	public FunctionArguments_AAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionArgumentsAccess().getAAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_CommaKeyword_2_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("a",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("a");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getFunctionArgumentsAccess().getATypeParserRuleCall_2_1_1_0();
			return obj;
		}
		return null;
	}

}



// ")"
protected class FunctionArguments_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public FunctionArguments_RightParenthesisKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionArgumentsAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionArguments_Group_2(parent, this, 0, inst);
			case 1: return new FunctionArguments_LeftParenthesisKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule functionArguments ****************/


/************ begin Rule functionBody ****************
 *
 * functionBody:
 *   "{" (s=statement|e=expression) "}"; 
 *   
 * 
 *            
 *   
 * 
 * 
 * ///// HQL stuff
 *
 **/

// "{" (s=statement|e=expression) "}"
protected class FunctionBody_Group extends GroupToken {
	
	public FunctionBody_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionBodyAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionBody_RightCurlyBracketKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFunctionBodyRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "{"
protected class FunctionBody_LeftCurlyBracketKeyword_0 extends KeywordToken  {
	
	public FunctionBody_LeftCurlyBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionBodyAccess().getLeftCurlyBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// s=statement|e=expression
protected class FunctionBody_Alternatives_1 extends AlternativesToken {

	public FunctionBody_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFunctionBodyAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionBody_SAssignment_1_0(parent, this, 0, inst);
			case 1: return new FunctionBody_EAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// s=statement
protected class FunctionBody_SAssignment_1_0 extends AssignmentToken  {
	
	public FunctionBody_SAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionBodyAccess().getSAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Statement_QueryRuleParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("s",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("s");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getStatementRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionBodyAccess().getSStatementParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionBody_LeftCurlyBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// e=expression
protected class FunctionBody_EAssignment_1_1 extends AssignmentToken  {
	
	public FunctionBody_EAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionBodyAccess().getEAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionBodyAccess().getEExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionBody_LeftCurlyBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class FunctionBody_RightCurlyBracketKeyword_2 extends KeywordToken  {
	
	public FunctionBody_RightCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionBodyAccess().getRightCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionBody_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule functionBody ****************/


/************ begin Rule statement ****************
 *
 * statement:
 *   queryRule; 
 * 
 * 
 * ///// HQL stuff
 *
 **/

// queryRule
protected class Statement_QueryRuleParserRuleCall extends RuleCallToken {
	
	public Statement_QueryRuleParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStatementAccess().getQueryRuleParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QueryRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStatementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(QueryRule_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getQueryRuleRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule statement ****************/


/************ begin Rule unionRule ****************
 *
 * unionRule:
 *   q+=queryRule ("union" q+=queryRule)*; 
 * 
 * 
 * 
 * 	      
 * 	
 * 
 * //## query:
 * //##     [selectClause] fromClause [whereClause] [groupByClause] [havingClause] [orderByClause];
 *
 **/

// q+=queryRule ("union" q+=queryRule)*
protected class UnionRule_Group extends GroupToken {
	
	public UnionRule_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnionRuleAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnionRule_Group_1(parent, this, 0, inst);
			case 1: return new UnionRule_QAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnionRuleRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// q+=queryRule
protected class UnionRule_QAssignment_0 extends AssignmentToken  {
	
	public UnionRule_QAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnionRuleAccess().getQAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QueryRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("q",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("q");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQueryRuleRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnionRuleAccess().getQQueryRuleParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("union" q+=queryRule)*
protected class UnionRule_Group_1 extends GroupToken {
	
	public UnionRule_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnionRuleAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnionRule_QAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "union"
protected class UnionRule_UnionKeyword_1_0 extends KeywordToken  {
	
	public UnionRule_UnionKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnionRuleAccess().getUnionKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnionRule_Group_1(parent, this, 0, inst);
			case 1: return new UnionRule_QAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// q+=queryRule
protected class UnionRule_QAssignment_1_1 extends AssignmentToken  {
	
	public UnionRule_QAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnionRuleAccess().getQAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QueryRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("q",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("q");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getQueryRuleRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnionRuleAccess().getQQueryRuleParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnionRule_UnionKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule unionRule ****************/


/************ begin Rule queryRule ****************
 *
 * queryRule:
 *   selectFrom where=whereClause? groupBy=groupByClause? orderBy=orderByClause?; 
 * 
 * //## query:
 * //##     [selectClause] fromClause [whereClause] [groupByClause] [havingClause] [orderByClause];
 *
 **/

// selectFrom where=whereClause? groupBy=groupByClause? orderBy=orderByClause?
protected class QueryRule_Group extends GroupToken {
	
	public QueryRule_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQueryRuleAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QueryRule_OrderByAssignment_3(parent, this, 0, inst);
			case 1: return new QueryRule_GroupByAssignment_2(parent, this, 1, inst);
			case 2: return new QueryRule_WhereAssignment_1(parent, this, 2, inst);
			case 3: return new QueryRule_SelectFromParserRuleCall_0(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getQueryRuleRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// selectFrom
protected class QueryRule_SelectFromParserRuleCall_0 extends RuleCallToken {
	
	public QueryRule_SelectFromParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getQueryRuleAccess().getSelectFromParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectFrom_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SelectFrom_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSelectFromRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// where=whereClause?
protected class QueryRule_WhereAssignment_1 extends AssignmentToken  {
	
	public QueryRule_WhereAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQueryRuleAccess().getWhereAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WhereClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("where",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("where");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getWhereClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getQueryRuleAccess().getWhereWhereClauseParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new QueryRule_SelectFromParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// groupBy=groupByClause?
protected class QueryRule_GroupByAssignment_2 extends AssignmentToken  {
	
	public QueryRule_GroupByAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQueryRuleAccess().getGroupByAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GroupByClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("groupBy",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groupBy");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGroupByClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getQueryRuleAccess().getGroupByGroupByClauseParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new QueryRule_WhereAssignment_1(parent, next, actIndex, consumed);
			case 1: return new QueryRule_SelectFromParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// orderBy=orderByClause?
protected class QueryRule_OrderByAssignment_3 extends AssignmentToken  {
	
	public QueryRule_OrderByAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQueryRuleAccess().getOrderByAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrderByClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("orderBy",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("orderBy");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrderByClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getQueryRuleAccess().getOrderByOrderByClauseParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new QueryRule_GroupByAssignment_2(parent, next, actIndex, consumed);
			case 1: return new QueryRule_WhereAssignment_1(parent, next, actIndex, consumed);
			case 2: return new QueryRule_SelectFromParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule queryRule ****************/


/************ begin Rule selectFrom ****************
 *
 * selectFrom:
 *   {selectFrom} s=selectClause? from=fromClause?; 
 * 
 * 
 * 	        
 * 	
 * 
 * //## selectClause:
 * //##     SELECT DISTINCT? selectedPropertiesList | ( NEW className OPEN selectedPropertiesList CLOSE );
 *
 **/

// {selectFrom} s=selectClause? from=fromClause?
protected class SelectFrom_Group extends GroupToken {
	
	public SelectFrom_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSelectFromAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectFrom_FromAssignment_2(parent, this, 0, inst);
			case 1: return new SelectFrom_SAssignment_1(parent, this, 1, inst);
			case 2: return new SelectFrom_SelectFromAction_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSelectFromRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {selectFrom}
protected class SelectFrom_SelectFromAction_0 extends ActionToken  {

	public SelectFrom_SelectFromAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getSelectFromAccess().getSelectFromAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getSelectFromAccess().getSelectFromAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// s=selectClause?
protected class SelectFrom_SAssignment_1 extends AssignmentToken  {
	
	public SelectFrom_SAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSelectFromAccess().getSAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("s",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("s");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSelectClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSelectFromAccess().getSSelectClauseParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SelectFrom_SelectFromAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// from=fromClause?
protected class SelectFrom_FromAssignment_2 extends AssignmentToken  {
	
	public SelectFrom_FromAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSelectFromAccess().getFromAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("from",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("from");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFromClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSelectFromAccess().getFromFromClauseParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SelectFrom_SAssignment_1(parent, next, actIndex, consumed);
			case 1: return new SelectFrom_SelectFromAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule selectFrom ****************/


/************ begin Rule selectClause ****************
 *
 * selectClause:
 *   {selectCause} SELECT DISTINCT? (s=selectedPropertiesList|n=newExpression|
 *   selectObject); 
 * 
 * //## selectClause:
 * //##     SELECT DISTINCT? selectedPropertiesList | ( NEW className OPEN selectedPropertiesList CLOSE );
 *
 **/

// {selectCause} SELECT DISTINCT? (s=selectedPropertiesList|n=newExpression|
// selectObject)
protected class SelectClause_Group extends GroupToken {
	
	public SelectClause_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSelectClauseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectClause_Alternatives_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSelectClauseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {selectCause}
protected class SelectClause_SelectCauseAction_0 extends ActionToken  {

	public SelectClause_SelectCauseAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getSelectClauseAccess().getSelectCauseAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getSelectClauseAccess().getSelectCauseAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// SELECT
protected class SelectClause_SELECTParserRuleCall_1 extends UnassignedTextToken {

	public SelectClause_SELECTParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getSelectClauseAccess().getSELECTParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectClause_SelectCauseAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// DISTINCT?
protected class SelectClause_DISTINCTParserRuleCall_2 extends UnassignedTextToken {

	public SelectClause_DISTINCTParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getSelectClauseAccess().getDISTINCTParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectClause_SELECTParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// s=selectedPropertiesList|n=newExpression|selectObject
protected class SelectClause_Alternatives_3 extends AlternativesToken {

	public SelectClause_Alternatives_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getSelectClauseAccess().getAlternatives_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectClause_SAssignment_3_0(parent, this, 0, inst);
			case 1: return new SelectClause_NAssignment_3_1(parent, this, 1, inst);
			case 2: return new SelectClause_SelectObjectParserRuleCall_3_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// s=selectedPropertiesList
protected class SelectClause_SAssignment_3_0 extends AssignmentToken  {
	
	public SelectClause_SAssignment_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSelectClauseAccess().getSAssignment_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectedPropertiesList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("s",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("s");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSelectedPropertiesListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSelectClauseAccess().getSSelectedPropertiesListParserRuleCall_3_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SelectClause_DISTINCTParserRuleCall_2(parent, next, actIndex, consumed);
			case 1: return new SelectClause_SELECTParserRuleCall_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// n=newExpression
protected class SelectClause_NAssignment_3_1 extends AssignmentToken  {
	
	public SelectClause_NAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSelectClauseAccess().getNAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NewExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("n",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("n");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNewExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSelectClauseAccess().getNNewExpressionParserRuleCall_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SelectClause_DISTINCTParserRuleCall_2(parent, next, actIndex, consumed);
			case 1: return new SelectClause_SELECTParserRuleCall_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// selectObject
protected class SelectClause_SelectObjectParserRuleCall_3_2 extends UnassignedTextToken {

	public SelectClause_SelectObjectParserRuleCall_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getSelectClauseAccess().getSelectObjectParserRuleCall_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectClause_DISTINCTParserRuleCall_2(parent, this, 0, inst);
			case 1: return new SelectClause_SELECTParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule selectClause ****************/


/************ begin Rule newExpression ****************
 *
 * newExpression:
 *   NEW p=path "(" s=selectedPropertiesList ")";
 *
 **/

// NEW p=path "(" s=selectedPropertiesList ")"
protected class NewExpression_Group extends GroupToken {
	
	public NewExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNewExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NewExpression_RightParenthesisKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNewExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// NEW
protected class NewExpression_NEWParserRuleCall_0 extends UnassignedTextToken {

	public NewExpression_NEWParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNewExpressionAccess().getNEWParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// p=path
protected class NewExpression_PAssignment_1 extends AssignmentToken  {
	
	public NewExpression_PAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNewExpressionAccess().getPAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NewExpression_NEWParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("p",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("p");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getNewExpressionAccess().getPPathParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class NewExpression_LeftParenthesisKeyword_2 extends KeywordToken  {
	
	public NewExpression_LeftParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNewExpressionAccess().getLeftParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NewExpression_PAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// s=selectedPropertiesList
protected class NewExpression_SAssignment_3 extends AssignmentToken  {
	
	public NewExpression_SAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNewExpressionAccess().getSAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectedPropertiesList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("s",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("s");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSelectedPropertiesListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNewExpressionAccess().getSSelectedPropertiesListParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NewExpression_LeftParenthesisKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class NewExpression_RightParenthesisKeyword_4 extends KeywordToken  {
	
	public NewExpression_RightParenthesisKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNewExpressionAccess().getRightParenthesisKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NewExpression_SAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule newExpression ****************/



/************ begin Rule fromClause ****************
 *
 * fromClause:
 *   FROM fromRange+=fromRange (fromJoin+=fromJoin|"," fromRange+=fromRange)*; 
 * 
 * //## fromClause:
 * //##    FROM className AS? identifier (  ( ',' className AS? identifier ) | ( joinType path AS? identifier ) )*;
 * 
 * // NOTE: This *must* begin with the "FROM" token, otherwise the sub-query rule will be ambiguous
 * // with the expression rule.
 * // Also note: after a comma weak keywords are allowed and should be treated as identifiers.
 * 
 * 
 * 	                
 * 	
 * 
 * 
 * //## joinType:
 * //##     ( ( 'left'|'right' 'outer'? ) | 'full' | 'inner' )? JOIN FETCH?;
 *
 **/

// FROM fromRange+=fromRange (fromJoin+=fromJoin|"," fromRange+=fromRange)*
protected class FromClause_Group extends GroupToken {
	
	public FromClause_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFromClauseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromClause_Alternatives_2(parent, this, 0, inst);
			case 1: return new FromClause_FromRangeAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFromClauseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// FROM
protected class FromClause_FROMParserRuleCall_0 extends UnassignedTextToken {

	public FromClause_FROMParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromClauseAccess().getFROMParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// fromRange+=fromRange
protected class FromClause_FromRangeAssignment_1 extends AssignmentToken  {
	
	public FromClause_FromRangeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFromClauseAccess().getFromRangeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromRange_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fromRange",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fromRange");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFromRangeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFromClauseAccess().getFromRangeFromRangeParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FromClause_FROMParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// (fromJoin+=fromJoin|"," fromRange+=fromRange)*
protected class FromClause_Alternatives_2 extends AlternativesToken {

	public FromClause_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFromClauseAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromClause_FromJoinAssignment_2_0(parent, this, 0, inst);
			case 1: return new FromClause_Group_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// fromJoin+=fromJoin
protected class FromClause_FromJoinAssignment_2_0 extends AssignmentToken  {
	
	public FromClause_FromJoinAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFromClauseAccess().getFromJoinAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromJoin_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fromJoin",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fromJoin");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFromJoinRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFromClauseAccess().getFromJoinFromJoinParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FromClause_Alternatives_2(parent, next, actIndex, consumed);
			case 1: return new FromClause_FromRangeAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "," fromRange+=fromRange
protected class FromClause_Group_2_1 extends GroupToken {
	
	public FromClause_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFromClauseAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromClause_FromRangeAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class FromClause_CommaKeyword_2_1_0 extends KeywordToken  {
	
	public FromClause_CommaKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFromClauseAccess().getCommaKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromClause_Alternatives_2(parent, this, 0, inst);
			case 1: return new FromClause_FromRangeAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// fromRange+=fromRange
protected class FromClause_FromRangeAssignment_2_1_1 extends AssignmentToken  {
	
	public FromClause_FromRangeAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFromClauseAccess().getFromRangeAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromRange_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("fromRange",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fromRange");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFromRangeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFromClauseAccess().getFromRangeFromRangeParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FromClause_CommaKeyword_2_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule fromClause ****************/


/************ begin Rule fromJoin ****************
 *
 * fromJoin:
 *   ((LEFT|RIGHT) OUTER?|FULL|INNER)? JOIN FETCH? fromClassOrOuterQueryPath w=withClause?
 * ; 
 * 
 * 
 * //## joinType:
 * //##     ( ( 'left'|'right' 'outer'? ) | 'full' | 'inner' )? JOIN FETCH?;
 *
 **/

// ((LEFT|RIGHT) OUTER?|FULL|INNER)? JOIN FETCH? fromClassOrOuterQueryPath w=withClause?
protected class FromJoin_Group extends GroupToken {
	
	public FromJoin_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromJoin_WAssignment_4(parent, this, 0, inst);
			case 1: return new FromJoin_FromClassOrOuterQueryPathParserRuleCall_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFromJoinRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ((LEFT|RIGHT) OUTER?|FULL|INNER)?
protected class FromJoin_Alternatives_0 extends AlternativesToken {

	public FromJoin_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromJoin_Group_0_0(parent, this, 0, inst);
			case 1: return new FromJoin_FULLParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new FromJoin_INNERParserRuleCall_0_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// (LEFT|RIGHT) OUTER?
protected class FromJoin_Group_0_0 extends GroupToken {
	
	public FromJoin_Group_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getGroup_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromJoin_OUTERParserRuleCall_0_0_1(parent, this, 0, inst);
			case 1: return new FromJoin_Alternatives_0_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// LEFT|RIGHT
protected class FromJoin_Alternatives_0_0_0 extends AlternativesToken {

	public FromJoin_Alternatives_0_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getAlternatives_0_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromJoin_LEFTParserRuleCall_0_0_0_0(parent, this, 0, inst);
			case 1: return new FromJoin_RIGHTParserRuleCall_0_0_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// LEFT
protected class FromJoin_LEFTParserRuleCall_0_0_0_0 extends UnassignedTextToken {

	public FromJoin_LEFTParserRuleCall_0_0_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getLEFTParserRuleCall_0_0_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// RIGHT
protected class FromJoin_RIGHTParserRuleCall_0_0_0_1 extends UnassignedTextToken {

	public FromJoin_RIGHTParserRuleCall_0_0_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getRIGHTParserRuleCall_0_0_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}


// OUTER?
protected class FromJoin_OUTERParserRuleCall_0_0_1 extends UnassignedTextToken {

	public FromJoin_OUTERParserRuleCall_0_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getOUTERParserRuleCall_0_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromJoin_Alternatives_0_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// FULL
protected class FromJoin_FULLParserRuleCall_0_1 extends UnassignedTextToken {

	public FromJoin_FULLParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getFULLParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// INNER
protected class FromJoin_INNERParserRuleCall_0_2 extends UnassignedTextToken {

	public FromJoin_INNERParserRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getINNERParserRuleCall_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}


// JOIN
protected class FromJoin_JOINParserRuleCall_1 extends UnassignedTextToken {

	public FromJoin_JOINParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getJOINParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromJoin_Alternatives_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// FETCH?
protected class FromJoin_FETCHParserRuleCall_2 extends UnassignedTextToken {

	public FromJoin_FETCHParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getFETCHParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromJoin_JOINParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// fromClassOrOuterQueryPath
protected class FromJoin_FromClassOrOuterQueryPathParserRuleCall_3 extends RuleCallToken {
	
	public FromJoin_FromClassOrOuterQueryPathParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getFromClassOrOuterQueryPathParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromClassOrOuterQueryPath_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FromClassOrOuterQueryPath_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFromClassOrOuterQueryPathRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromJoin_FETCHParserRuleCall_2(parent, next, actIndex, inst);
			case 1: return new FromJoin_JOINParserRuleCall_1(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// w=withClause?
protected class FromJoin_WAssignment_4 extends AssignmentToken  {
	
	public FromJoin_WAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFromJoinAccess().getWAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("w",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("w");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getWithClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFromJoinAccess().getWWithClauseParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FromJoin_FromClassOrOuterQueryPathParserRuleCall_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule fromJoin ****************/


/************ begin Rule withClause ****************
 *
 * withClause:
 *   WITH e=expression;
 *
 **/

// WITH e=expression
protected class WithClause_Group extends GroupToken {
	
	public WithClause_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WithClause_EAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWithClauseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// WITH
protected class WithClause_WITHParserRuleCall_0 extends UnassignedTextToken {

	public WithClause_WITHParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getWITHParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// e=expression
protected class WithClause_EAssignment_1 extends AssignmentToken  {
	
	public WithClause_EAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWithClauseAccess().getEAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWithClauseAccess().getEExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WithClause_WITHParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule withClause ****************/


/************ begin Rule fromRange ****************
 *
 * fromRange:
 *   fromClassOrOuterQueryPath|alias=identifier IN_CLASS p=path|IN "(" p=path ")" alias=
 *   identifier|inCollectionElementsDeclaration;
 *
 **/

// fromClassOrOuterQueryPath|alias=identifier IN_CLASS p=path|IN "(" p=path ")" alias=
// identifier|inCollectionElementsDeclaration
protected class FromRange_Alternatives extends AlternativesToken {

	public FromRange_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromRange_FromClassOrOuterQueryPathParserRuleCall_0(parent, this, 0, inst);
			case 1: return new FromRange_Group_1(parent, this, 1, inst);
			case 2: return new FromRange_Group_2(parent, this, 2, inst);
			case 3: return new FromRange_InCollectionElementsDeclarationParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFromRangeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// fromClassOrOuterQueryPath
protected class FromRange_FromClassOrOuterQueryPathParserRuleCall_0 extends RuleCallToken {
	
	public FromRange_FromClassOrOuterQueryPathParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getFromClassOrOuterQueryPathParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromClassOrOuterQueryPath_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FromClassOrOuterQueryPath_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFromClassOrOuterQueryPathRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// alias=identifier IN_CLASS p=path
protected class FromRange_Group_1 extends GroupToken {
	
	public FromRange_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromRange_PAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// alias=identifier
protected class FromRange_AliasAssignment_1_0 extends AssignmentToken  {
	
	public FromRange_AliasAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getAliasAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("alias",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getFromRangeAccess().getAliasIdentifierParserRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// IN_CLASS
protected class FromRange_IN_CLASSParserRuleCall_1_1 extends UnassignedTextToken {

	public FromRange_IN_CLASSParserRuleCall_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getIN_CLASSParserRuleCall_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromRange_AliasAssignment_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// p=path
protected class FromRange_PAssignment_1_2 extends AssignmentToken  {
	
	public FromRange_PAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getPAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromRange_IN_CLASSParserRuleCall_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("p",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("p");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getFromRangeAccess().getPPathParserRuleCall_1_2_0();
			return obj;
		}
		return null;
	}

}


// IN "(" p=path ")" alias=identifier
protected class FromRange_Group_2 extends GroupToken {
	
	public FromRange_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromRange_AliasAssignment_2_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// IN
protected class FromRange_INParserRuleCall_2_0 extends UnassignedTextToken {

	public FromRange_INParserRuleCall_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getINParserRuleCall_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "("
protected class FromRange_LeftParenthesisKeyword_2_1 extends KeywordToken  {
	
	public FromRange_LeftParenthesisKeyword_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getLeftParenthesisKeyword_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromRange_INParserRuleCall_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// p=path
protected class FromRange_PAssignment_2_2 extends AssignmentToken  {
	
	public FromRange_PAssignment_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getPAssignment_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromRange_LeftParenthesisKeyword_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("p",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("p");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getFromRangeAccess().getPPathParserRuleCall_2_2_0();
			return obj;
		}
		return null;
	}

}

// ")"
protected class FromRange_RightParenthesisKeyword_2_3 extends KeywordToken  {
	
	public FromRange_RightParenthesisKeyword_2_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getRightParenthesisKeyword_2_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromRange_PAssignment_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// alias=identifier
protected class FromRange_AliasAssignment_2_4 extends AssignmentToken  {
	
	public FromRange_AliasAssignment_2_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getAliasAssignment_2_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromRange_RightParenthesisKeyword_2_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("alias",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getFromRangeAccess().getAliasIdentifierParserRuleCall_2_4_0();
			return obj;
		}
		return null;
	}

}


// inCollectionElementsDeclaration
protected class FromRange_InCollectionElementsDeclarationParserRuleCall_3 extends RuleCallToken {
	
	public FromRange_InCollectionElementsDeclarationParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromRangeAccess().getInCollectionElementsDeclarationParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InCollectionElementsDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(InCollectionElementsDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getInCollectionElementsDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule fromRange ****************/


/************ begin Rule fromClassOrOuterQueryPath ****************
 *
 * fromClassOrOuterQueryPath:
 *   {fromClassOrOuterQueryPath} path asAlias=asAlias? propertyFetch=propertyFetch?;
 *
 **/

// {fromClassOrOuterQueryPath} path asAlias=asAlias? propertyFetch=propertyFetch?
protected class FromClassOrOuterQueryPath_Group extends GroupToken {
	
	public FromClassOrOuterQueryPath_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFromClassOrOuterQueryPathAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromClassOrOuterQueryPath_PropertyFetchAssignment_3(parent, this, 0, inst);
			case 1: return new FromClassOrOuterQueryPath_AsAliasAssignment_2(parent, this, 1, inst);
			case 2: return new FromClassOrOuterQueryPath_PathParserRuleCall_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFromClassOrOuterQueryPathRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {fromClassOrOuterQueryPath}
protected class FromClassOrOuterQueryPath_FromClassOrOuterQueryPathAction_0 extends ActionToken  {

	public FromClassOrOuterQueryPath_FromClassOrOuterQueryPathAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getFromClassOrOuterQueryPathAccess().getFromClassOrOuterQueryPathAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getFromClassOrOuterQueryPathAccess().getFromClassOrOuterQueryPathAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// path
protected class FromClassOrOuterQueryPath_PathParserRuleCall_1 extends UnassignedTextToken {

	public FromClassOrOuterQueryPath_PathParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFromClassOrOuterQueryPathAccess().getPathParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromClassOrOuterQueryPath_FromClassOrOuterQueryPathAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// asAlias=asAlias?
protected class FromClassOrOuterQueryPath_AsAliasAssignment_2 extends AssignmentToken  {
	
	public FromClassOrOuterQueryPath_AsAliasAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFromClassOrOuterQueryPathAccess().getAsAliasAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AsAlias_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("asAlias",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("asAlias");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAsAliasRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFromClassOrOuterQueryPathAccess().getAsAliasAsAliasParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FromClassOrOuterQueryPath_PathParserRuleCall_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// propertyFetch=propertyFetch?
protected class FromClassOrOuterQueryPath_PropertyFetchAssignment_3 extends AssignmentToken  {
	
	public FromClassOrOuterQueryPath_PropertyFetchAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFromClassOrOuterQueryPathAccess().getPropertyFetchAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FromClassOrOuterQueryPath_AsAliasAssignment_2(parent, this, 0, inst);
			case 1: return new FromClassOrOuterQueryPath_PathParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("propertyFetch",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("propertyFetch");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getFromClassOrOuterQueryPathAccess().getPropertyFetchPropertyFetchParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule fromClassOrOuterQueryPath ****************/


/************ begin Rule inCollectionElementsDeclaration ****************
 *
 * inCollectionElementsDeclaration:
 *   alias=identifier IN_ELEMENTS "(" p=path ")"; 
 * 
 * 
 * 	           
 *     
 * 
 * // Alias rule - Parses the optional 'as' token and forces an AST identifier node.
 *
 **/

// alias=identifier IN_ELEMENTS "(" p=path ")"
protected class InCollectionElementsDeclaration_Group extends GroupToken {
	
	public InCollectionElementsDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getInCollectionElementsDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InCollectionElementsDeclaration_RightParenthesisKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInCollectionElementsDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// alias=identifier
protected class InCollectionElementsDeclaration_AliasAssignment_0 extends AssignmentToken  {
	
	public InCollectionElementsDeclaration_AliasAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInCollectionElementsDeclarationAccess().getAliasAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("alias",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getInCollectionElementsDeclarationAccess().getAliasIdentifierParserRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// IN_ELEMENTS
protected class InCollectionElementsDeclaration_IN_ELEMENTSParserRuleCall_1 extends UnassignedTextToken {

	public InCollectionElementsDeclaration_IN_ELEMENTSParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getInCollectionElementsDeclarationAccess().getIN_ELEMENTSParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InCollectionElementsDeclaration_AliasAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class InCollectionElementsDeclaration_LeftParenthesisKeyword_2 extends KeywordToken  {
	
	public InCollectionElementsDeclaration_LeftParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInCollectionElementsDeclarationAccess().getLeftParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InCollectionElementsDeclaration_IN_ELEMENTSParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// p=path
protected class InCollectionElementsDeclaration_PAssignment_3 extends AssignmentToken  {
	
	public InCollectionElementsDeclaration_PAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getInCollectionElementsDeclarationAccess().getPAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InCollectionElementsDeclaration_LeftParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("p",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("p");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getInCollectionElementsDeclarationAccess().getPPathParserRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// ")"
protected class InCollectionElementsDeclaration_RightParenthesisKeyword_4 extends KeywordToken  {
	
	public InCollectionElementsDeclaration_RightParenthesisKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getInCollectionElementsDeclarationAccess().getRightParenthesisKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InCollectionElementsDeclaration_PAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule inCollectionElementsDeclaration ****************/


/************ begin Rule asAlias ****************
 *
 * asAlias:
 *   AS? alias=identifier; 
 * 
 * // Alias rule - Parses the optional 'as' token and forces an AST identifier node.
 *
 **/

// AS? alias=identifier
protected class AsAlias_Group extends GroupToken {
	
	public AsAlias_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAsAliasAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AsAlias_AliasAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAsAliasRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AS?
protected class AsAlias_ASParserRuleCall_0 extends UnassignedTextToken {

	public AsAlias_ASParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAsAliasAccess().getASParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// alias=identifier
protected class AsAlias_AliasAssignment_1 extends AssignmentToken  {
	
	public AsAlias_AliasAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAsAliasAccess().getAliasAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AsAlias_ASParserRuleCall_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("alias",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getAsAliasAccess().getAliasIdentifierParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule asAlias ****************/



/************ begin Rule groupByClause ****************
 *
 * groupByClause:
 *   GROUP_BY e+=expression ("," e+=expression)* h=havingClause?; 
 * 
 * //## groupByClause:
 * //##     GROUP_BY path ( ',' path )*;
 * 
 * 
 * 	            
 * 		
 * 	
 * 
 * //## orderByClause:
 * //##     ORDER_BY selectedPropertiesList;
 *
 **/

// GROUP_BY e+=expression ("," e+=expression)* h=havingClause?
protected class GroupByClause_Group extends GroupToken {
	
	public GroupByClause_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGroupByClauseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GroupByClause_HAssignment_3(parent, this, 0, inst);
			case 1: return new GroupByClause_Group_2(parent, this, 1, inst);
			case 2: return new GroupByClause_EAssignment_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getGroupByClauseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// GROUP_BY
protected class GroupByClause_GROUP_BYParserRuleCall_0 extends UnassignedTextToken {

	public GroupByClause_GROUP_BYParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getGroupByClauseAccess().getGROUP_BYParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// e+=expression
protected class GroupByClause_EAssignment_1 extends AssignmentToken  {
	
	public GroupByClause_EAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGroupByClauseAccess().getEAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getGroupByClauseAccess().getEExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new GroupByClause_GROUP_BYParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," e+=expression)*
protected class GroupByClause_Group_2 extends GroupToken {
	
	public GroupByClause_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGroupByClauseAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GroupByClause_EAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class GroupByClause_CommaKeyword_2_0 extends KeywordToken  {
	
	public GroupByClause_CommaKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGroupByClauseAccess().getCommaKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GroupByClause_Group_2(parent, this, 0, inst);
			case 1: return new GroupByClause_EAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// e+=expression
protected class GroupByClause_EAssignment_2_1 extends AssignmentToken  {
	
	public GroupByClause_EAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGroupByClauseAccess().getEAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getGroupByClauseAccess().getEExpressionParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new GroupByClause_CommaKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// h=havingClause?
protected class GroupByClause_HAssignment_3 extends AssignmentToken  {
	
	public GroupByClause_HAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGroupByClauseAccess().getHAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HavingClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("h",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("h");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getHavingClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getGroupByClauseAccess().getHHavingClauseParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new GroupByClause_Group_2(parent, next, actIndex, consumed);
			case 1: return new GroupByClause_EAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule groupByClause ****************/


/************ begin Rule orderByClause ****************
 *
 * orderByClause:
 *   ORDER_BY o+=orderElement ("," o+=orderElement)*; 
 * 
 * //## orderByClause:
 * //##     ORDER_BY selectedPropertiesList;
 *
 **/

// ORDER_BY o+=orderElement ("," o+=orderElement)*
protected class OrderByClause_Group extends GroupToken {
	
	public OrderByClause_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrderByClauseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrderByClause_Group_2(parent, this, 0, inst);
			case 1: return new OrderByClause_OAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrderByClauseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ORDER_BY
protected class OrderByClause_ORDER_BYParserRuleCall_0 extends UnassignedTextToken {

	public OrderByClause_ORDER_BYParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrderByClauseAccess().getORDER_BYParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// o+=orderElement
protected class OrderByClause_OAssignment_1 extends AssignmentToken  {
	
	public OrderByClause_OAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrderByClauseAccess().getOAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrderElement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("o",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("o");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrderElementRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrderByClauseAccess().getOOrderElementParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrderByClause_ORDER_BYParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," o+=orderElement)*
protected class OrderByClause_Group_2 extends GroupToken {
	
	public OrderByClause_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrderByClauseAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrderByClause_OAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class OrderByClause_CommaKeyword_2_0 extends KeywordToken  {
	
	public OrderByClause_CommaKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getOrderByClauseAccess().getCommaKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrderByClause_Group_2(parent, this, 0, inst);
			case 1: return new OrderByClause_OAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// o+=orderElement
protected class OrderByClause_OAssignment_2_1 extends AssignmentToken  {
	
	public OrderByClause_OAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrderByClauseAccess().getOAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrderElement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("o",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("o");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrderElementRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrderByClauseAccess().getOOrderElementParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrderByClause_CommaKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule orderByClause ****************/


/************ begin Rule orderElement ****************
 *
 * orderElement:
 *   expression ascendingOrDescending?;
 *
 **/

// expression ascendingOrDescending?
protected class OrderElement_Group extends GroupToken {
	
	public OrderElement_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrderElementAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrderElement_AscendingOrDescendingParserRuleCall_1(parent, this, 0, inst);
			case 1: return new OrderElement_ExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrderElementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// expression
protected class OrderElement_ExpressionParserRuleCall_0 extends RuleCallToken {
	
	public OrderElement_ExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrderElementAccess().getExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Expression_LogicalOrExpressionParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ascendingOrDescending?
protected class OrderElement_AscendingOrDescendingParserRuleCall_1 extends UnassignedTextToken {

	public OrderElement_AscendingOrDescendingParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrderElementAccess().getAscendingOrDescendingParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrderElement_ExpressionParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule orderElement ****************/



/************ begin Rule havingClause ****************
 *
 * havingClause:
 *   HAVING e=expression; 
 * 
 * //## havingClause:
 * //##     HAVING logicalExpression;
 * 
 * 
 * 	    
 * 	
 * 
 * //## whereClause:
 * //##     WHERE logicalExpression;
 *
 **/

// HAVING e=expression
protected class HavingClause_Group extends GroupToken {
	
	public HavingClause_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getHavingClauseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new HavingClause_EAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getHavingClauseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// HAVING
protected class HavingClause_HAVINGParserRuleCall_0 extends UnassignedTextToken {

	public HavingClause_HAVINGParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getHavingClauseAccess().getHAVINGParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// e=expression
protected class HavingClause_EAssignment_1 extends AssignmentToken  {
	
	public HavingClause_EAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getHavingClauseAccess().getEAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getHavingClauseAccess().getEExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new HavingClause_HAVINGParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule havingClause ****************/


/************ begin Rule whereClause ****************
 *
 * whereClause:
 *   WHERE e=expression; 
 * 
 * //## whereClause:
 * //##     WHERE logicalExpression;
 * 
 * 
 * 	    
 * 	
 * 
 * //## selectedPropertiesList:
 * //##     ( path | aggregate ) ( ',' path | aggregate )*;
 *
 **/

// WHERE e=expression
protected class WhereClause_Group extends GroupToken {
	
	public WhereClause_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWhereClauseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WhereClause_EAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWhereClauseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// WHERE
protected class WhereClause_WHEREParserRuleCall_0 extends UnassignedTextToken {

	public WhereClause_WHEREParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getWhereClauseAccess().getWHEREParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// e=expression
protected class WhereClause_EAssignment_1 extends AssignmentToken  {
	
	public WhereClause_EAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWhereClauseAccess().getEAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWhereClauseAccess().getEExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WhereClause_WHEREParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule whereClause ****************/


/************ begin Rule selectedPropertiesList ****************
 *
 * selectedPropertiesList:
 *   a+=aliasedExpression ("," a+=aliasedExpression)*; 
 * 
 * //## selectedPropertiesList:
 * //##     ( path | aggregate ) ( ',' path | aggregate )*;
 *
 **/

// a+=aliasedExpression ("," a+=aliasedExpression)*
protected class SelectedPropertiesList_Group extends GroupToken {
	
	public SelectedPropertiesList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSelectedPropertiesListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectedPropertiesList_Group_1(parent, this, 0, inst);
			case 1: return new SelectedPropertiesList_AAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSelectedPropertiesListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// a+=aliasedExpression
protected class SelectedPropertiesList_AAssignment_0 extends AssignmentToken  {
	
	public SelectedPropertiesList_AAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSelectedPropertiesListAccess().getAAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AliasedExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("a",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("a");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAliasedExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSelectedPropertiesListAccess().getAAliasedExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("," a+=aliasedExpression)*
protected class SelectedPropertiesList_Group_1 extends GroupToken {
	
	public SelectedPropertiesList_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSelectedPropertiesListAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectedPropertiesList_AAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class SelectedPropertiesList_CommaKeyword_1_0 extends KeywordToken  {
	
	public SelectedPropertiesList_CommaKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSelectedPropertiesListAccess().getCommaKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SelectedPropertiesList_Group_1(parent, this, 0, inst);
			case 1: return new SelectedPropertiesList_AAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// a+=aliasedExpression
protected class SelectedPropertiesList_AAssignment_1_1 extends AssignmentToken  {
	
	public SelectedPropertiesList_AAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSelectedPropertiesListAccess().getAAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AliasedExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("a",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("a");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAliasedExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSelectedPropertiesListAccess().getAAliasedExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SelectedPropertiesList_CommaKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule selectedPropertiesList ****************/


/************ begin Rule aliasedExpression ****************
 *
 * aliasedExpression:
 *   expression (AS id=identifier)?; 
 * 	
 * 
 * 	          
 * 	
 * 
 * // expressions
 * // Note that most of these expressions follow the pattern
 * //   thisLevelExpression :
 * //       nextHigherPrecedenceExpression
 * //           (OPERATOR nextHigherPrecedenceExpression)*
 * // which is a standard recursive definition for a parsing an expression.
 * //
 * // Operator precedence in HQL
 * // lowest  --> ( 7)  OR
 * //             ( 6)  AND, NOT
 * //             ( 5)  equality: ==, <>, =, is
 * //             ( 4)  relational: <, <=, >, >=,
 * //                   LIKE, NOT LIKE, BETWEEN, NOT BETWEEN, IN, NOT IN
 * //             ( 3)  addition and subtraction: +(binary) -(binary)
 * //             ( 2)  multiplication: * / %, concatenate: ||
 * // highest --> ( 1)  +(unary) -(unary)
 * //                   []   () (method call)  . (dot -- identifier qualification)
 * //                   aggregate function
 * //                   ()  (explicit parenthesis)
 * //
 * // Note that the above precedence levels map to the rules below...
 * // Once you have a precedence chart, writing the appropriate rules as below
 * // is usually very straightfoward
 * 
 * // Main expression rule
 *
 **/

// expression (AS id=identifier)?
protected class AliasedExpression_Group extends GroupToken {
	
	public AliasedExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAliasedExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AliasedExpression_Group_1(parent, this, 0, inst);
			case 1: return new AliasedExpression_ExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAliasedExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// expression
protected class AliasedExpression_ExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AliasedExpression_ExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAliasedExpressionAccess().getExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Expression_LogicalOrExpressionParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// (AS id=identifier)?
protected class AliasedExpression_Group_1 extends GroupToken {
	
	public AliasedExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAliasedExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AliasedExpression_IdAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// AS
protected class AliasedExpression_ASParserRuleCall_1_0 extends UnassignedTextToken {

	public AliasedExpression_ASParserRuleCall_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAliasedExpressionAccess().getASParserRuleCall_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AliasedExpression_ExpressionParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// id=identifier
protected class AliasedExpression_IdAssignment_1_1 extends AssignmentToken  {
	
	public AliasedExpression_IdAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAliasedExpressionAccess().getIdAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AliasedExpression_ASParserRuleCall_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getAliasedExpressionAccess().getIdIdentifierParserRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule aliasedExpression ****************/


/************ begin Rule expression ****************
 *
 * expression:
 *   logicalOrExpression; 
 * 
 * // expressions
 * // Note that most of these expressions follow the pattern
 * //   thisLevelExpression :
 * //       nextHigherPrecedenceExpression
 * //           (OPERATOR nextHigherPrecedenceExpression)*
 * // which is a standard recursive definition for a parsing an expression.
 * //
 * // Operator precedence in HQL
 * // lowest  --> ( 7)  OR
 * //             ( 6)  AND, NOT
 * //             ( 5)  equality: ==, <>, =, is
 * //             ( 4)  relational: <, <=, >, >=,
 * //                   LIKE, NOT LIKE, BETWEEN, NOT BETWEEN, IN, NOT IN
 * //             ( 3)  addition and subtraction: +(binary) -(binary)
 * //             ( 2)  multiplication: * / %, concatenate: ||
 * // highest --> ( 1)  +(unary) -(unary)
 * //                   []   () (method call)  . (dot -- identifier qualification)
 * //                   aggregate function
 * //                   ()  (explicit parenthesis)
 * //
 * // Note that the above precedence levels map to the rules below...
 * // Once you have a precedence chart, writing the appropriate rules as below
 * // is usually very straightfoward
 * 
 * // Main expression rule
 * 
 * 	  
 * 	
 * 
 * // level 7 - OR
 *
 **/

// logicalOrExpression
protected class Expression_LogicalOrExpressionParserRuleCall extends RuleCallToken {
	
	public Expression_LogicalOrExpressionParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getLogicalOrExpressionParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalOrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(LogicalOrExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getLogicalOrExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule expression ****************/


/************ begin Rule logicalOrExpression ****************
 *
 * logicalOrExpression:
 *   l+=logicalAndExpression (OR l+=logicalAndExpression)*; 
 * 
 * // level 7 - OR
 * 
 * 	          
 * 	
 * 
 * // level 6 - AND, NOT
 *
 **/

// l+=logicalAndExpression (OR l+=logicalAndExpression)*
protected class LogicalOrExpression_Group extends GroupToken {
	
	public LogicalOrExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLogicalOrExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalOrExpression_Group_1(parent, this, 0, inst);
			case 1: return new LogicalOrExpression_LAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLogicalOrExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// l+=logicalAndExpression
protected class LogicalOrExpression_LAssignment_0 extends AssignmentToken  {
	
	public LogicalOrExpression_LAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLogicalOrExpressionAccess().getLAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalAndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("l",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("l");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLogicalAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLogicalOrExpressionAccess().getLLogicalAndExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (OR l+=logicalAndExpression)*
protected class LogicalOrExpression_Group_1 extends GroupToken {
	
	public LogicalOrExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLogicalOrExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalOrExpression_LAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// OR
protected class LogicalOrExpression_ORParserRuleCall_1_0 extends UnassignedTextToken {

	public LogicalOrExpression_ORParserRuleCall_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLogicalOrExpressionAccess().getORParserRuleCall_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalOrExpression_Group_1(parent, this, 0, inst);
			case 1: return new LogicalOrExpression_LAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// l+=logicalAndExpression
protected class LogicalOrExpression_LAssignment_1_1 extends AssignmentToken  {
	
	public LogicalOrExpression_LAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLogicalOrExpressionAccess().getLAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalAndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("l",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("l");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLogicalAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLogicalOrExpressionAccess().getLLogicalAndExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LogicalOrExpression_ORParserRuleCall_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule logicalOrExpression ****************/


/************ begin Rule logicalAndExpression ****************
 *
 * logicalAndExpression:
 *   n+=negatedExpression (AND n+=negatedExpression)*; 
 * 
 * // level 6 - AND, NOT
 * 
 * 	          
 * 	
 * 
 * // NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
 * // negated, if possible.   Expressions without a NOT parent are passed through.
 *
 **/

// n+=negatedExpression (AND n+=negatedExpression)*
protected class LogicalAndExpression_Group extends GroupToken {
	
	public LogicalAndExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLogicalAndExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalAndExpression_Group_1(parent, this, 0, inst);
			case 1: return new LogicalAndExpression_NAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLogicalAndExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// n+=negatedExpression
protected class LogicalAndExpression_NAssignment_0 extends AssignmentToken  {
	
	public LogicalAndExpression_NAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLogicalAndExpressionAccess().getNAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NegatedExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("n",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("n");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNegatedExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLogicalAndExpressionAccess().getNNegatedExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (AND n+=negatedExpression)*
protected class LogicalAndExpression_Group_1 extends GroupToken {
	
	public LogicalAndExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLogicalAndExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalAndExpression_NAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// AND
protected class LogicalAndExpression_ANDParserRuleCall_1_0 extends UnassignedTextToken {

	public LogicalAndExpression_ANDParserRuleCall_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLogicalAndExpressionAccess().getANDParserRuleCall_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LogicalAndExpression_Group_1(parent, this, 0, inst);
			case 1: return new LogicalAndExpression_NAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// n+=negatedExpression
protected class LogicalAndExpression_NAssignment_1_1 extends AssignmentToken  {
	
	public LogicalAndExpression_NAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLogicalAndExpressionAccess().getNAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NegatedExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("n",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("n");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNegatedExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLogicalAndExpressionAccess().getNNegatedExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LogicalAndExpression_ANDParserRuleCall_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule logicalAndExpression ****************/


/************ begin Rule negatedExpression ****************
 *
 * negatedExpression:
 *   NOT n=negatedExpression|equalityExpression; 
 * 
 * // NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
 * // negated, if possible.   Expressions without a NOT parent are passed through.
 * 
 *  // Weak keywords can appear in an expression, so look ahead.
 * 	      
 * 	   
 * 	
 * 
 * //## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
 * 
 * // level 5 - EQ, NE
 *
 **/

// NOT n=negatedExpression|equalityExpression 
// 
// // NOT nodes aren't generated.  Instead, the operator in the sub-tree will be
// // negated, if possible.   Expressions without a NOT parent are passed through.
// 
//  // Weak keywords can appear in an expression, so look ahead.
// 	      
// 	   
// 	
// 
// //## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
// 
// // level 5 - EQ, NE
protected class NegatedExpression_Alternatives extends AlternativesToken {

	public NegatedExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNegatedExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NegatedExpression_Group_0(parent, this, 0, inst);
			case 1: return new NegatedExpression_EqualityExpressionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNegatedExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// NOT n=negatedExpression
protected class NegatedExpression_Group_0 extends GroupToken {
	
	public NegatedExpression_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNegatedExpressionAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NegatedExpression_NAssignment_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// NOT
protected class NegatedExpression_NOTParserRuleCall_0_0 extends UnassignedTextToken {

	public NegatedExpression_NOTParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNegatedExpressionAccess().getNOTParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// n=negatedExpression
protected class NegatedExpression_NAssignment_0_1 extends AssignmentToken  {
	
	public NegatedExpression_NAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNegatedExpressionAccess().getNAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NegatedExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("n",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("n");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNegatedExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNegatedExpressionAccess().getNNegatedExpressionParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NegatedExpression_NOTParserRuleCall_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// equalityExpression
protected class NegatedExpression_EqualityExpressionParserRuleCall_1 extends RuleCallToken {
	
	public NegatedExpression_EqualityExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNegatedExpressionAccess().getEqualityExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EqualityExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEqualityExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule negatedExpression ****************/


/************ begin Rule equalityExpression ****************
 *
 * equalityExpression:
 *   r+=relationalExpression (("="|IS NOT?|"!="|"<>") r+=relationalExpression)*; 
 * 
 * //## OP: EQ | LT | GT | LE | GE | NE | SQL_NE | LIKE;
 * 
 * // level 5 - EQ, NE
 * 
 * 	    
 * 		  
 * 		  	     
 * 		  
 * 		  	
 * 		   
 * 	
 * 
 * // level 4 - LT, GT, LE, GE, LIKE, NOT LIKE, BETWEEN, NOT BETWEEN
 * // NOTE: The NOT prefix for LIKE and BETWEEN will be represented in the
 * // token type.  When traversing the AST, use the token type, and not the
 * // token text to interpret the semantics of these nodes.
 *
 **/

// r+=relationalExpression (("="|IS NOT?|"!="|"<>") r+=relationalExpression)*
protected class EqualityExpression_Group extends GroupToken {
	
	public EqualityExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group_1(parent, this, 0, inst);
			case 1: return new EqualityExpression_RAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEqualityExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// r+=relationalExpression
protected class EqualityExpression_RAssignment_0 extends AssignmentToken  {
	
	public EqualityExpression_RAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getRAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("r",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("r");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEqualityExpressionAccess().getRRelationalExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (("="|IS NOT?|"!="|"<>") r+=relationalExpression)*
protected class EqualityExpression_Group_1 extends GroupToken {
	
	public EqualityExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_RAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="|IS NOT?|"!="|"<>"
protected class EqualityExpression_Alternatives_1_0 extends AlternativesToken {

	public EqualityExpression_Alternatives_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getAlternatives_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_EqualsSignKeyword_1_0_0(parent, this, 0, inst);
			case 1: return new EqualityExpression_Group_1_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class EqualityExpression_EqualsSignKeyword_1_0_0 extends KeywordToken  {
	
	public EqualityExpression_EqualsSignKeyword_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getEqualsSignKeyword_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group_1(parent, this, 0, inst);
			case 1: return new EqualityExpression_RAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// IS NOT?
protected class EqualityExpression_Group_1_0_1 extends GroupToken {
	
	public EqualityExpression_Group_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getGroup_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_NOTParserRuleCall_1_0_1_1(parent, this, 0, inst);
			case 1: return new EqualityExpression_ISParserRuleCall_1_0_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// IS
protected class EqualityExpression_ISParserRuleCall_1_0_1_0 extends UnassignedTextToken {

	public EqualityExpression_ISParserRuleCall_1_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getISParserRuleCall_1_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group_1(parent, this, 0, inst);
			case 1: return new EqualityExpression_RAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// NOT?
protected class EqualityExpression_NOTParserRuleCall_1_0_1_1 extends UnassignedTextToken {

	public EqualityExpression_NOTParserRuleCall_1_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getNOTParserRuleCall_1_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_ISParserRuleCall_1_0_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// r+=relationalExpression
protected class EqualityExpression_RAssignment_1_1 extends AssignmentToken  {
	
	public EqualityExpression_RAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getRAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("r",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("r");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEqualityExpressionAccess().getRRelationalExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EqualityExpression_Alternatives_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule equalityExpression ****************/


/************ begin Rule relationalExpression ****************
 *
 * relationalExpression:
 *   concatenation ((("<"|">"|"<="|">=") a+=additiveExpression)*|NOT? (IN i=compoundExpr|
 *   BETWEEN b=betweenList|LIKE c=concatenation l=likeEscape|MEMBER OF? p=path)); 
 * 
 * // level 4 - LT, GT, LE, GE, LIKE, NOT LIKE, BETWEEN, NOT BETWEEN
 * // NOTE: The NOT prefix for LIKE and BETWEEN will be represented in the
 * // token type.  When traversing the AST, use the token type, and not the
 * // token text to interpret the semantics of these nodes.
 * 
 * 	    
 * 		                          
 * 		// Disable node production for the optional 'not'.
 * 		     
 * 			// Represent the optional NOT prefix using the token type by
 * 			 // testing 'n' and setting the token type accordingly.
 *
 **/

// concatenation ((("<"|">"|"<="|">=") a+=additiveExpression)*|NOT? (IN i=compoundExpr|
// BETWEEN b=betweenList|LIKE c=concatenation l=likeEscape|MEMBER OF? p=path))     
// 		                          
// 		// Disable node production for the optional 'not'.
// 		     
// 			// Represent the optional NOT prefix using the token type by
// 			 // testing 'n' and setting the token type accordingly.
protected class RelationalExpression_Group extends GroupToken {
	
	public RelationalExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// concatenation
protected class RelationalExpression_ConcatenationParserRuleCall_0 extends RuleCallToken {
	
	public RelationalExpression_ConcatenationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getConcatenationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concatenation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Concatenation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getConcatenationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// (("<"|">"|"<="|">=") a+=additiveExpression)*|NOT? (IN i=compoundExpr|BETWEEN b=
// betweenList|LIKE c=concatenation l=likeEscape|MEMBER OF? p=path)   
// 		                          
// 		// Disable node production for the optional 'not'.
// 		     
// 			// Represent the optional NOT prefix using the token type by
// 			 // testing 'n' and setting the token type accordingly.
protected class RelationalExpression_Alternatives_1 extends AlternativesToken {

	public RelationalExpression_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group_1_0(parent, this, 0, inst);
			case 1: return new RelationalExpression_Group_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// (("<"|">"|"<="|">=") a+=additiveExpression)*
protected class RelationalExpression_Group_1_0 extends GroupToken {
	
	public RelationalExpression_Group_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_AAssignment_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"|">"|"<="|">="
protected class RelationalExpression_Alternatives_1_0_0 extends AlternativesToken {

	public RelationalExpression_Alternatives_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getAlternatives_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_LessThanSignKeyword_1_0_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class RelationalExpression_LessThanSignKeyword_1_0_0_0 extends KeywordToken  {
	
	public RelationalExpression_LessThanSignKeyword_1_0_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getLessThanSignKeyword_1_0_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group_1_0(parent, this, 0, inst);
			case 1: return new RelationalExpression_ConcatenationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// a+=additiveExpression
protected class RelationalExpression_AAssignment_1_0_1 extends AssignmentToken  {
	
	public RelationalExpression_AAssignment_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getAAssignment_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("a",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("a");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalExpressionAccess().getAAdditiveExpressionParserRuleCall_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RelationalExpression_Alternatives_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// NOT? (IN i=compoundExpr|BETWEEN b=betweenList|LIKE c=concatenation l=likeEscape|
// MEMBER OF? p=path)     
// 			// Represent the optional NOT prefix using the token type by
// 			 // testing 'n' and setting the token type accordingly.
protected class RelationalExpression_Group_1_1 extends GroupToken {
	
	public RelationalExpression_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Alternatives_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// NOT?
protected class RelationalExpression_NOTParserRuleCall_1_1_0 extends UnassignedTextToken {

	public RelationalExpression_NOTParserRuleCall_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getNOTParserRuleCall_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_ConcatenationParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// IN i=compoundExpr|BETWEEN b=betweenList|LIKE c=concatenation l=likeEscape|MEMBER OF? p
// =path   
// 			// Represent the optional NOT prefix using the token type by
// 			 // testing 'n' and setting the token type accordingly.
protected class RelationalExpression_Alternatives_1_1_1 extends AlternativesToken {

	public RelationalExpression_Alternatives_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getAlternatives_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group_1_1_1_0(parent, this, 0, inst);
			case 1: return new RelationalExpression_Group_1_1_1_1(parent, this, 1, inst);
			case 2: return new RelationalExpression_Group_1_1_1_2(parent, this, 2, inst);
			case 3: return new RelationalExpression_Group_1_1_1_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
}

// IN i=compoundExpr
protected class RelationalExpression_Group_1_1_1_0 extends GroupToken {
	
	public RelationalExpression_Group_1_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup_1_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_IAssignment_1_1_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// IN
protected class RelationalExpression_INParserRuleCall_1_1_1_0_0 extends UnassignedTextToken {

	public RelationalExpression_INParserRuleCall_1_1_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getINParserRuleCall_1_1_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_NOTParserRuleCall_1_1_0(parent, this, 0, inst);
			case 1: return new RelationalExpression_ConcatenationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// i=compoundExpr
protected class RelationalExpression_IAssignment_1_1_1_0_1 extends AssignmentToken  {
	
	public RelationalExpression_IAssignment_1_1_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getIAssignment_1_1_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundExpr_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("i",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("i");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCompoundExprRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalExpressionAccess().getICompoundExprParserRuleCall_1_1_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RelationalExpression_INParserRuleCall_1_1_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// BETWEEN b=betweenList
protected class RelationalExpression_Group_1_1_1_1 extends GroupToken {
	
	public RelationalExpression_Group_1_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup_1_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_BAssignment_1_1_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// BETWEEN
protected class RelationalExpression_BETWEENParserRuleCall_1_1_1_1_0 extends UnassignedTextToken {

	public RelationalExpression_BETWEENParserRuleCall_1_1_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getBETWEENParserRuleCall_1_1_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_NOTParserRuleCall_1_1_0(parent, this, 0, inst);
			case 1: return new RelationalExpression_ConcatenationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// b=betweenList
protected class RelationalExpression_BAssignment_1_1_1_1_1 extends AssignmentToken  {
	
	public RelationalExpression_BAssignment_1_1_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getBAssignment_1_1_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BetweenList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("b",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("b");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBetweenListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalExpressionAccess().getBBetweenListParserRuleCall_1_1_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RelationalExpression_BETWEENParserRuleCall_1_1_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// LIKE c=concatenation l=likeEscape
protected class RelationalExpression_Group_1_1_1_2 extends GroupToken {
	
	public RelationalExpression_Group_1_1_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup_1_1_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_LAssignment_1_1_1_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// LIKE
protected class RelationalExpression_LIKEParserRuleCall_1_1_1_2_0 extends UnassignedTextToken {

	public RelationalExpression_LIKEParserRuleCall_1_1_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getLIKEParserRuleCall_1_1_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_NOTParserRuleCall_1_1_0(parent, this, 0, inst);
			case 1: return new RelationalExpression_ConcatenationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// c=concatenation
protected class RelationalExpression_CAssignment_1_1_1_2_1 extends AssignmentToken  {
	
	public RelationalExpression_CAssignment_1_1_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getCAssignment_1_1_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concatenation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("c",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("c");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcatenationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalExpressionAccess().getCConcatenationParserRuleCall_1_1_1_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RelationalExpression_LIKEParserRuleCall_1_1_1_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// l=likeEscape
protected class RelationalExpression_LAssignment_1_1_1_2_2 extends AssignmentToken  {
	
	public RelationalExpression_LAssignment_1_1_1_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getLAssignment_1_1_1_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LikeEscape_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("l",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("l");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLikeEscapeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalExpressionAccess().getLLikeEscapeParserRuleCall_1_1_1_2_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RelationalExpression_CAssignment_1_1_1_2_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// MEMBER OF? p=path
protected class RelationalExpression_Group_1_1_1_3 extends GroupToken {
	
	public RelationalExpression_Group_1_1_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup_1_1_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_PAssignment_1_1_1_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// MEMBER
protected class RelationalExpression_MEMBERParserRuleCall_1_1_1_3_0 extends UnassignedTextToken {

	public RelationalExpression_MEMBERParserRuleCall_1_1_1_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getMEMBERParserRuleCall_1_1_1_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_NOTParserRuleCall_1_1_0(parent, this, 0, inst);
			case 1: return new RelationalExpression_ConcatenationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// OF?
protected class RelationalExpression_OFParserRuleCall_1_1_1_3_1 extends UnassignedTextToken {

	public RelationalExpression_OFParserRuleCall_1_1_1_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getOFParserRuleCall_1_1_1_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_MEMBERParserRuleCall_1_1_1_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// p=path
protected class RelationalExpression_PAssignment_1_1_1_3_2 extends AssignmentToken  {
	
	public RelationalExpression_PAssignment_1_1_1_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getPAssignment_1_1_1_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_OFParserRuleCall_1_1_1_3_1(parent, this, 0, inst);
			case 1: return new RelationalExpression_MEMBERParserRuleCall_1_1_1_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("p",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("p");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getRelationalExpressionAccess().getPPathParserRuleCall_1_1_1_3_2_0();
			return obj;
		}
		return null;
	}

}






/************ end Rule relationalExpression ****************/


/************ begin Rule likeEscape ****************
 *
 * likeEscape:
 *   {likeEscape} (ESCAPE c=concatenation)?;
 *
 **/

// {likeEscape} (ESCAPE c=concatenation)?
protected class LikeEscape_Group extends GroupToken {
	
	public LikeEscape_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLikeEscapeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LikeEscape_Group_1(parent, this, 0, inst);
			case 1: return new LikeEscape_LikeEscapeAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLikeEscapeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {likeEscape}
protected class LikeEscape_LikeEscapeAction_0 extends ActionToken  {

	public LikeEscape_LikeEscapeAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getLikeEscapeAccess().getLikeEscapeAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getLikeEscapeAccess().getLikeEscapeAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// (ESCAPE c=concatenation)?
protected class LikeEscape_Group_1 extends GroupToken {
	
	public LikeEscape_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getLikeEscapeAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LikeEscape_CAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ESCAPE
protected class LikeEscape_ESCAPEParserRuleCall_1_0 extends UnassignedTextToken {

	public LikeEscape_ESCAPEParserRuleCall_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLikeEscapeAccess().getESCAPEParserRuleCall_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new LikeEscape_LikeEscapeAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// c=concatenation
protected class LikeEscape_CAssignment_1_1 extends AssignmentToken  {
	
	public LikeEscape_CAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getLikeEscapeAccess().getCAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concatenation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("c",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("c");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcatenationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getLikeEscapeAccess().getCConcatenationParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new LikeEscape_ESCAPEParserRuleCall_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule likeEscape ****************/


/************ begin Rule betweenList ****************
 *
 * betweenList:
 *   c+=concatenation AND c+=concatenation; 
 * 
 * 
 * 	      
 * 	
 * 
 * //level 4 - string concatenation
 *
 **/

// c+=concatenation AND c+=concatenation
protected class BetweenList_Group extends GroupToken {
	
	public BetweenList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBetweenListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BetweenList_CAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBetweenListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// c+=concatenation
protected class BetweenList_CAssignment_0 extends AssignmentToken  {
	
	public BetweenList_CAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBetweenListAccess().getCAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concatenation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("c",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("c");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcatenationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBetweenListAccess().getCConcatenationParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// AND
protected class BetweenList_ANDParserRuleCall_1 extends UnassignedTextToken {

	public BetweenList_ANDParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBetweenListAccess().getANDParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BetweenList_CAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// c+=concatenation
protected class BetweenList_CAssignment_2 extends AssignmentToken  {
	
	public BetweenList_CAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBetweenListAccess().getCAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concatenation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("c",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("c");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getConcatenationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBetweenListAccess().getCConcatenationParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BetweenList_ANDParserRuleCall_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule betweenList ****************/


/************ begin Rule concatenation ****************
 *
 * concatenation:
 *   additiveExpression ("||" a+=additiveExpression ("||" a+=additiveExpression)*)?; 
 * 
 * //level 4 - string concatenation
 * 
 * 	   
 * 	    
 * 	  
 * 	         
 * 	  
 * 	
 * 
 * // level 3 - binary plus and minus
 *
 **/

// additiveExpression ("||" a+=additiveExpression ("||" a+=additiveExpression)*)?
protected class Concatenation_Group extends GroupToken {
	
	public Concatenation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcatenationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concatenation_Group_1(parent, this, 0, inst);
			case 1: return new Concatenation_AdditiveExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConcatenationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// additiveExpression
protected class Concatenation_AdditiveExpressionParserRuleCall_0 extends RuleCallToken {
	
	public Concatenation_AdditiveExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getConcatenationAccess().getAdditiveExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AdditiveExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ("||" a+=additiveExpression ("||" a+=additiveExpression)*)?
protected class Concatenation_Group_1 extends GroupToken {
	
	public Concatenation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcatenationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concatenation_Group_1_2(parent, this, 0, inst);
			case 1: return new Concatenation_AAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "||"
protected class Concatenation_VerticalLineVerticalLineKeyword_1_0 extends KeywordToken  {
	
	public Concatenation_VerticalLineVerticalLineKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcatenationAccess().getVerticalLineVerticalLineKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concatenation_AdditiveExpressionParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// a+=additiveExpression
protected class Concatenation_AAssignment_1_1 extends AssignmentToken  {
	
	public Concatenation_AAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcatenationAccess().getAAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("a",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("a");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConcatenationAccess().getAAdditiveExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Concatenation_VerticalLineVerticalLineKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("||" a+=additiveExpression)*
protected class Concatenation_Group_1_2 extends GroupToken {
	
	public Concatenation_Group_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConcatenationAccess().getGroup_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concatenation_AAssignment_1_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "||"
protected class Concatenation_VerticalLineVerticalLineKeyword_1_2_0 extends KeywordToken  {
	
	public Concatenation_VerticalLineVerticalLineKeyword_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConcatenationAccess().getVerticalLineVerticalLineKeyword_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Concatenation_Group_1_2(parent, this, 0, inst);
			case 1: return new Concatenation_AAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// a+=additiveExpression
protected class Concatenation_AAssignment_1_2_1 extends AssignmentToken  {
	
	public Concatenation_AAssignment_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConcatenationAccess().getAAssignment_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("a",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("a");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConcatenationAccess().getAAdditiveExpressionParserRuleCall_1_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Concatenation_VerticalLineVerticalLineKeyword_1_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule concatenation ****************/


/************ begin Rule additiveExpression ****************
 *
 * additiveExpression:
 *   m+=multiplyExpression (("+"|"-") m+=multiplyExpression)*; 
 * 
 * // level 3 - binary plus and minus
 * 
 * 	                  
 * 	
 * 
 * // level 2 - binary multiply and divide
 *
 **/

// m+=multiplyExpression (("+"|"-") m+=multiplyExpression)*
protected class AdditiveExpression_Group extends GroupToken {
	
	public AdditiveExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveExpression_MAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// m+=multiplyExpression
protected class AdditiveExpression_MAssignment_0 extends AssignmentToken  {
	
	public AdditiveExpression_MAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getMAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplyExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("m",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("m");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiplyExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditiveExpressionAccess().getMMultiplyExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (("+"|"-") m+=multiplyExpression)*
protected class AdditiveExpression_Group_1 extends GroupToken {
	
	public AdditiveExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_MAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "+"|"-"
protected class AdditiveExpression_Alternatives_1_0 extends AlternativesToken {

	public AdditiveExpression_Alternatives_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getAlternatives_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_PlusSignKeyword_1_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "+"
protected class AdditiveExpression_PlusSignKeyword_1_0_0 extends KeywordToken  {
	
	public AdditiveExpression_PlusSignKeyword_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getPlusSignKeyword_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveExpression_MAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// m+=multiplyExpression
protected class AdditiveExpression_MAssignment_1_1 extends AssignmentToken  {
	
	public AdditiveExpression_MAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getMAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplyExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("m",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("m");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiplyExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditiveExpressionAccess().getMMultiplyExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AdditiveExpression_Alternatives_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule additiveExpression ****************/


/************ begin Rule multiplyExpression ****************
 *
 * multiplyExpression:
 *   u+=unaryExpression (("*"|"/") u+=unaryExpression)*; 
 * 
 * // level 2 - binary multiply and divide
 * 
 * 	                  
 * 	
 * 	
 * // level 1 - unary minus, unary plus, not
 *
 **/

// u+=unaryExpression (("*"|"/") u+=unaryExpression)*
protected class MultiplyExpression_Group extends GroupToken {
	
	public MultiplyExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplyExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplyExpression_Group_1(parent, this, 0, inst);
			case 1: return new MultiplyExpression_UAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMultiplyExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// u+=unaryExpression
protected class MultiplyExpression_UAssignment_0 extends AssignmentToken  {
	
	public MultiplyExpression_UAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplyExpressionAccess().getUAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("u",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("u");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMultiplyExpressionAccess().getUUnaryExpressionParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (("*"|"/") u+=unaryExpression)*
protected class MultiplyExpression_Group_1 extends GroupToken {
	
	public MultiplyExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplyExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplyExpression_UAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "*"|"/"
protected class MultiplyExpression_Alternatives_1_0 extends AlternativesToken {

	public MultiplyExpression_Alternatives_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getMultiplyExpressionAccess().getAlternatives_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplyExpression_AsteriskKeyword_1_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "*"
protected class MultiplyExpression_AsteriskKeyword_1_0_0 extends KeywordToken  {
	
	public MultiplyExpression_AsteriskKeyword_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getMultiplyExpressionAccess().getAsteriskKeyword_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplyExpression_Group_1(parent, this, 0, inst);
			case 1: return new MultiplyExpression_UAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// u+=unaryExpression
protected class MultiplyExpression_UAssignment_1_1 extends AssignmentToken  {
	
	public MultiplyExpression_UAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplyExpressionAccess().getUAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("u",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("u");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMultiplyExpressionAccess().getUUnaryExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MultiplyExpression_Alternatives_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule multiplyExpression ****************/


/************ begin Rule unaryExpression ****************
 *
 * unaryExpression:
 *   "-" u=unaryExpression|"+" u=unaryExpression|caseExpression|quantifiedExpression|
 *   atom; 
 * 	
 * // level 1 - unary minus, unary plus, not
 *
 **/

// "-" u=unaryExpression|"+" u=unaryExpression|caseExpression|quantifiedExpression|
// atom 
// 	
// // level 1 - unary minus, unary plus, not
protected class UnaryExpression_Alternatives extends AlternativesToken {

	public UnaryExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Group_0(parent, this, 0, inst);
			case 1: return new UnaryExpression_Group_1(parent, this, 1, inst);
			case 2: return new UnaryExpression_CaseExpressionParserRuleCall_2(parent, this, 2, inst);
			case 3: return new UnaryExpression_QuantifiedExpressionParserRuleCall_3(parent, this, 3, inst);
			case 4: return new UnaryExpression_AtomParserRuleCall_4(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "-" u=unaryExpression
protected class UnaryExpression_Group_0 extends GroupToken {
	
	public UnaryExpression_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_UAssignment_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "-"
protected class UnaryExpression_HyphenMinusKeyword_0_0 extends KeywordToken  {
	
	public UnaryExpression_HyphenMinusKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getHyphenMinusKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// u=unaryExpression
protected class UnaryExpression_UAssignment_0_1 extends AssignmentToken  {
	
	public UnaryExpression_UAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getUAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("u",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("u");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnaryExpressionAccess().getUUnaryExpressionParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryExpression_HyphenMinusKeyword_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "+" u=unaryExpression
protected class UnaryExpression_Group_1 extends GroupToken {
	
	public UnaryExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_UAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "+"
protected class UnaryExpression_PlusSignKeyword_1_0 extends KeywordToken  {
	
	public UnaryExpression_PlusSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getPlusSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// u=unaryExpression
protected class UnaryExpression_UAssignment_1_1 extends AssignmentToken  {
	
	public UnaryExpression_UAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getUAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("u",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("u");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnaryExpressionAccess().getUUnaryExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryExpression_PlusSignKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// caseExpression
protected class UnaryExpression_CaseExpressionParserRuleCall_2 extends RuleCallToken {
	
	public UnaryExpression_CaseExpressionParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getCaseExpressionParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CaseExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CaseExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCaseExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// quantifiedExpression
protected class UnaryExpression_QuantifiedExpressionParserRuleCall_3 extends RuleCallToken {
	
	public UnaryExpression_QuantifiedExpressionParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getQuantifiedExpressionParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(QuantifiedExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getQuantifiedExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// atom
protected class UnaryExpression_AtomParserRuleCall_4 extends RuleCallToken {
	
	public UnaryExpression_AtomParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryExpressionAccess().getAtomParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Atom_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule unaryExpression ****************/


/************ begin Rule caseExpression ****************
 *
 * caseExpression:
 *   CASE w+=whenClause+ e=elseClause? END|CASE u=unaryExpression a+=altWhenClause+ e=
 *   elseClause? END;
 *
 **/

// CASE w+=whenClause+ e=elseClause? END|CASE u=unaryExpression a+=altWhenClause+ e=
// elseClause? END
protected class CaseExpression_Alternatives extends AlternativesToken {

	public CaseExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CaseExpression_Group_0(parent, this, 0, inst);
			case 1: return new CaseExpression_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCaseExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// CASE w+=whenClause+ e=elseClause? END
protected class CaseExpression_Group_0 extends GroupToken {
	
	public CaseExpression_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CaseExpression_ENDParserRuleCall_0_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// CASE
protected class CaseExpression_CASEParserRuleCall_0_0 extends UnassignedTextToken {

	public CaseExpression_CASEParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getCASEParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// w+=whenClause+
protected class CaseExpression_WAssignment_0_1 extends AssignmentToken  {
	
	public CaseExpression_WAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getWAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WhenClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("w",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("w");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getWhenClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCaseExpressionAccess().getWWhenClauseParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CaseExpression_WAssignment_0_1(parent, next, actIndex, consumed);
			case 1: return new CaseExpression_CASEParserRuleCall_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// e=elseClause?
protected class CaseExpression_EAssignment_0_2 extends AssignmentToken  {
	
	public CaseExpression_EAssignment_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getEAssignment_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ElseClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getElseClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCaseExpressionAccess().getEElseClauseParserRuleCall_0_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CaseExpression_WAssignment_0_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// END
protected class CaseExpression_ENDParserRuleCall_0_3 extends UnassignedTextToken {

	public CaseExpression_ENDParserRuleCall_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getENDParserRuleCall_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CaseExpression_EAssignment_0_2(parent, this, 0, inst);
			case 1: return new CaseExpression_WAssignment_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// CASE u=unaryExpression a+=altWhenClause+ e=elseClause? END
protected class CaseExpression_Group_1 extends GroupToken {
	
	public CaseExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CaseExpression_ENDParserRuleCall_1_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// CASE
protected class CaseExpression_CASEParserRuleCall_1_0 extends UnassignedTextToken {

	public CaseExpression_CASEParserRuleCall_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getCASEParserRuleCall_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// u=unaryExpression
protected class CaseExpression_UAssignment_1_1 extends AssignmentToken  {
	
	public CaseExpression_UAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getUAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("u",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("u");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCaseExpressionAccess().getUUnaryExpressionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CaseExpression_CASEParserRuleCall_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// a+=altWhenClause+
protected class CaseExpression_AAssignment_1_2 extends AssignmentToken  {
	
	public CaseExpression_AAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getAAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AltWhenClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("a",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("a");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAltWhenClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCaseExpressionAccess().getAAltWhenClauseParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CaseExpression_AAssignment_1_2(parent, next, actIndex, consumed);
			case 1: return new CaseExpression_UAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// e=elseClause?
protected class CaseExpression_EAssignment_1_3 extends AssignmentToken  {
	
	public CaseExpression_EAssignment_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getEAssignment_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ElseClause_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getElseClauseRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCaseExpressionAccess().getEElseClauseParserRuleCall_1_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CaseExpression_AAssignment_1_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// END
protected class CaseExpression_ENDParserRuleCall_1_4 extends UnassignedTextToken {

	public CaseExpression_ENDParserRuleCall_1_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCaseExpressionAccess().getENDParserRuleCall_1_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CaseExpression_EAssignment_1_3(parent, this, 0, inst);
			case 1: return new CaseExpression_AAssignment_1_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule caseExpression ****************/


/************ begin Rule whenClause ****************
 *
 * whenClause:
 *   WHEN whenExpr=expression THEN thenExpr=unaryExpression;
 *
 **/

// WHEN whenExpr=expression THEN thenExpr=unaryExpression
protected class WhenClause_Group extends GroupToken {
	
	public WhenClause_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWhenClauseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WhenClause_ThenExprAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWhenClauseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// WHEN
protected class WhenClause_WHENParserRuleCall_0 extends UnassignedTextToken {

	public WhenClause_WHENParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getWhenClauseAccess().getWHENParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// whenExpr=expression
protected class WhenClause_WhenExprAssignment_1 extends AssignmentToken  {
	
	public WhenClause_WhenExprAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWhenClauseAccess().getWhenExprAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("whenExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("whenExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWhenClauseAccess().getWhenExprExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WhenClause_WHENParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// THEN
protected class WhenClause_THENParserRuleCall_2 extends UnassignedTextToken {

	public WhenClause_THENParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getWhenClauseAccess().getTHENParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WhenClause_WhenExprAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// thenExpr=unaryExpression
protected class WhenClause_ThenExprAssignment_3 extends AssignmentToken  {
	
	public WhenClause_ThenExprAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWhenClauseAccess().getThenExprAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("thenExpr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("thenExpr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWhenClauseAccess().getThenExprUnaryExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WhenClause_THENParserRuleCall_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule whenClause ****************/


/************ begin Rule altWhenClause ****************
 *
 * altWhenClause:
 *   WHEN w=unaryExpression THEN t=unaryExpression;
 *
 **/

// WHEN w=unaryExpression THEN t=unaryExpression
protected class AltWhenClause_Group extends GroupToken {
	
	public AltWhenClause_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAltWhenClauseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AltWhenClause_TAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAltWhenClauseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// WHEN
protected class AltWhenClause_WHENParserRuleCall_0 extends UnassignedTextToken {

	public AltWhenClause_WHENParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAltWhenClauseAccess().getWHENParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// w=unaryExpression
protected class AltWhenClause_WAssignment_1 extends AssignmentToken  {
	
	public AltWhenClause_WAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAltWhenClauseAccess().getWAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("w",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("w");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAltWhenClauseAccess().getWUnaryExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AltWhenClause_WHENParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// THEN
protected class AltWhenClause_THENParserRuleCall_2 extends UnassignedTextToken {

	public AltWhenClause_THENParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAltWhenClauseAccess().getTHENParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AltWhenClause_WAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// t=unaryExpression
protected class AltWhenClause_TAssignment_3 extends AssignmentToken  {
	
	public AltWhenClause_TAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAltWhenClauseAccess().getTAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("t",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("t");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAltWhenClauseAccess().getTUnaryExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AltWhenClause_THENParserRuleCall_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule altWhenClause ****************/


/************ begin Rule elseClause ****************
 *
 * elseClause:
 *   ELSE u=unaryExpression;
 *
 **/

// ELSE u=unaryExpression
protected class ElseClause_Group extends GroupToken {
	
	public ElseClause_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getElseClauseAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ElseClause_UAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getElseClauseRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ELSE
protected class ElseClause_ELSEParserRuleCall_0 extends UnassignedTextToken {

	public ElseClause_ELSEParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getElseClauseAccess().getELSEParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// u=unaryExpression
protected class ElseClause_UAssignment_1 extends AssignmentToken  {
	
	public ElseClause_UAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getElseClauseAccess().getUAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("u",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("u");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getElseClauseAccess().getUUnaryExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ElseClause_ELSEParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule elseClause ****************/


/************ begin Rule quantifiedExpression ****************
 *
 * quantifiedExpression:
 *   {quantifiedExpression} (SOME|EXISTS|ALL|ANY) (identifier|collectionExpr|"(" s=
 *   unionRule ")"); 
 * 	
 * 
 * 	                   
 * 	                    
 * 	
 * 
 * // level 0 - expression atom
 * // ident qualifier ('.' ident ), array index ( [ expr ] ),
 * // method call ( '.' ident '(' exprList ') )
 *
 **/

// {quantifiedExpression} (SOME|EXISTS|ALL|ANY) (identifier|collectionExpr|"(" s=
// unionRule ")")
protected class QuantifiedExpression_Group extends GroupToken {
	
	public QuantifiedExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_Alternatives_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getQuantifiedExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {quantifiedExpression}
protected class QuantifiedExpression_QuantifiedExpressionAction_0 extends ActionToken  {

	public QuantifiedExpression_QuantifiedExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getQuantifiedExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getQuantifiedExpressionAccess().getQuantifiedExpressionAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// SOME|EXISTS|ALL|ANY
protected class QuantifiedExpression_Alternatives_1 extends AlternativesToken {

	public QuantifiedExpression_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_SOMEParserRuleCall_1_0(parent, this, 0, inst);
			case 1: return new QuantifiedExpression_EXISTSParserRuleCall_1_1(parent, this, 1, inst);
			case 2: return new QuantifiedExpression_ALLParserRuleCall_1_2(parent, this, 2, inst);
			case 3: return new QuantifiedExpression_ANYParserRuleCall_1_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
}

// SOME
protected class QuantifiedExpression_SOMEParserRuleCall_1_0 extends UnassignedTextToken {

	public QuantifiedExpression_SOMEParserRuleCall_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getSOMEParserRuleCall_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_QuantifiedExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// EXISTS
protected class QuantifiedExpression_EXISTSParserRuleCall_1_1 extends UnassignedTextToken {

	public QuantifiedExpression_EXISTSParserRuleCall_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getEXISTSParserRuleCall_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_QuantifiedExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ALL
protected class QuantifiedExpression_ALLParserRuleCall_1_2 extends UnassignedTextToken {

	public QuantifiedExpression_ALLParserRuleCall_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getALLParserRuleCall_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_QuantifiedExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ANY
protected class QuantifiedExpression_ANYParserRuleCall_1_3 extends UnassignedTextToken {

	public QuantifiedExpression_ANYParserRuleCall_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getANYParserRuleCall_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_QuantifiedExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// identifier|collectionExpr|"(" s=unionRule ")"
protected class QuantifiedExpression_Alternatives_2 extends AlternativesToken {

	public QuantifiedExpression_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_IdentifierParserRuleCall_2_0(parent, this, 0, inst);
			case 1: return new QuantifiedExpression_CollectionExprParserRuleCall_2_1(parent, this, 1, inst);
			case 2: return new QuantifiedExpression_Group_2_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// identifier
protected class QuantifiedExpression_IdentifierParserRuleCall_2_0 extends UnassignedTextToken {

	public QuantifiedExpression_IdentifierParserRuleCall_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getIdentifierParserRuleCall_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// collectionExpr
protected class QuantifiedExpression_CollectionExprParserRuleCall_2_1 extends UnassignedTextToken {

	public QuantifiedExpression_CollectionExprParserRuleCall_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getCollectionExprParserRuleCall_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "(" s=unionRule ")"
protected class QuantifiedExpression_Group_2_2 extends GroupToken {
	
	public QuantifiedExpression_Group_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getGroup_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_RightParenthesisKeyword_2_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class QuantifiedExpression_LeftParenthesisKeyword_2_2_0 extends KeywordToken  {
	
	public QuantifiedExpression_LeftParenthesisKeyword_2_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getLeftParenthesisKeyword_2_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// s=unionRule
protected class QuantifiedExpression_SAssignment_2_2_1 extends AssignmentToken  {
	
	public QuantifiedExpression_SAssignment_2_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getSAssignment_2_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnionRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("s",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("s");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnionRuleRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getQuantifiedExpressionAccess().getSUnionRuleParserRuleCall_2_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new QuantifiedExpression_LeftParenthesisKeyword_2_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class QuantifiedExpression_RightParenthesisKeyword_2_2_2 extends KeywordToken  {
	
	public QuantifiedExpression_RightParenthesisKeyword_2_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getQuantifiedExpressionAccess().getRightParenthesisKeyword_2_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new QuantifiedExpression_SAssignment_2_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}




/************ end Rule quantifiedExpression ****************/


/************ begin Rule atom ****************
 *
 * atom:
 *   primaryExpression ("." identifier ("(" e+=exprList ")")?|"[" exp+=expression "]")*; 
 * 
 * // level 0 - expression atom
 * // ident qualifier ('.' ident ), array index ( [ expr ] ),
 * // method call ( '.' ident '(' exprList ') )
 * 
 * 	   
 * 			                
 * 			     
 * 		
 * 	
 * 
 * // level 0 - the basic element of an expression
 *
 **/

// primaryExpression ("." identifier ("(" e+=exprList ")")?|"[" exp+=expression "]")*
protected class Atom_Group extends GroupToken {
	
	public Atom_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAtomAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_Alternatives_1(parent, this, 0, inst);
			case 1: return new Atom_PrimaryExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// primaryExpression
protected class Atom_PrimaryExpressionParserRuleCall_0 extends RuleCallToken {
	
	public Atom_PrimaryExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getPrimaryExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PrimaryExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ("." identifier ("(" e+=exprList ")")?|"[" exp+=expression "]")*
protected class Atom_Alternatives_1 extends AlternativesToken {

	public Atom_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAtomAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_Group_1_0(parent, this, 0, inst);
			case 1: return new Atom_Group_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "." identifier ("(" e+=exprList ")")?
protected class Atom_Group_1_0 extends GroupToken {
	
	public Atom_Group_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAtomAccess().getGroup_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_Group_1_0_2(parent, this, 0, inst);
			case 1: return new Atom_IdentifierParserRuleCall_1_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "."
protected class Atom_FullStopKeyword_1_0_0 extends KeywordToken  {
	
	public Atom_FullStopKeyword_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAtomAccess().getFullStopKeyword_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_Alternatives_1(parent, this, 0, inst);
			case 1: return new Atom_PrimaryExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// identifier
protected class Atom_IdentifierParserRuleCall_1_0_1 extends UnassignedTextToken {

	public Atom_IdentifierParserRuleCall_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAtomAccess().getIdentifierParserRuleCall_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_FullStopKeyword_1_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("(" e+=exprList ")")?
protected class Atom_Group_1_0_2 extends GroupToken {
	
	public Atom_Group_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAtomAccess().getGroup_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_RightParenthesisKeyword_1_0_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class Atom_LeftParenthesisKeyword_1_0_2_0 extends KeywordToken  {
	
	public Atom_LeftParenthesisKeyword_1_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAtomAccess().getLeftParenthesisKeyword_1_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_IdentifierParserRuleCall_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// e+=exprList
protected class Atom_EAssignment_1_0_2_1 extends AssignmentToken  {
	
	public Atom_EAssignment_1_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAtomAccess().getEAssignment_1_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExprListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAtomAccess().getEExprListParserRuleCall_1_0_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Atom_LeftParenthesisKeyword_1_0_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class Atom_RightParenthesisKeyword_1_0_2_2 extends KeywordToken  {
	
	public Atom_RightParenthesisKeyword_1_0_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAtomAccess().getRightParenthesisKeyword_1_0_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_EAssignment_1_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// "[" exp+=expression "]"
protected class Atom_Group_1_1 extends GroupToken {
	
	public Atom_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAtomAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_RightSquareBracketKeyword_1_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "["
protected class Atom_LeftSquareBracketKeyword_1_1_0 extends KeywordToken  {
	
	public Atom_LeftSquareBracketKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAtomAccess().getLeftSquareBracketKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_Alternatives_1(parent, this, 0, inst);
			case 1: return new Atom_PrimaryExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// exp+=expression
protected class Atom_ExpAssignment_1_1_1 extends AssignmentToken  {
	
	public Atom_ExpAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAtomAccess().getExpAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("exp",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("exp");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAtomAccess().getExpExpressionParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Atom_LeftSquareBracketKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "]"
protected class Atom_RightSquareBracketKeyword_1_1_2 extends KeywordToken  {
	
	public Atom_RightSquareBracketKeyword_1_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAtomAccess().getRightSquareBracketKeyword_1_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_ExpAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}




/************ end Rule atom ****************/


/************ begin Rule primaryExpression ****************
 *
 * primaryExpression:
 *   {primaryExpression} ident=identPrimary ("." CLASS)?|constant|":" identifier|"(" (
 *   expressionOrVector|s=unionRule) ")"|"?" INT?; 
 * 
 * // level 0 - the basic element of an expression
 * 
 * 	            
 * 	    
 * 	      
 * 	            
 * 	      
 * 	
 * 
 * // This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
 * // a parent VECTOR_EXPR node will be created for the list.
 *
 **/

// {primaryExpression} ident=identPrimary ("." CLASS)?|constant|":" identifier|"(" (
// expressionOrVector|s=unionRule) ")"|"?" INT? 
// 
// // level 0 - the basic element of an expression
// 
// 	            
// 	    
// 	      
// 	            
// 	      
// 	
// 
// // This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
// // a parent VECTOR_EXPR node will be created for the list.
protected class PrimaryExpression_Alternatives extends AlternativesToken {

	public PrimaryExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Group_0(parent, this, 0, inst);
			case 1: return new PrimaryExpression_ConstantParserRuleCall_1(parent, this, 1, inst);
			case 2: return new PrimaryExpression_Group_2(parent, this, 2, inst);
			case 3: return new PrimaryExpression_Group_3(parent, this, 3, inst);
			case 4: return new PrimaryExpression_Group_4(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {primaryExpression} ident=identPrimary ("." CLASS)?
protected class PrimaryExpression_Group_0 extends GroupToken {
	
	public PrimaryExpression_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Group_0_2(parent, this, 0, inst);
			case 1: return new PrimaryExpression_IdentAssignment_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// {primaryExpression}
protected class PrimaryExpression_PrimaryExpressionAction_0_0 extends ActionToken  {

	public PrimaryExpression_PrimaryExpressionAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getPrimaryExpressionAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionAccess().getPrimaryExpressionAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// ident=identPrimary
protected class PrimaryExpression_IdentAssignment_0_1 extends AssignmentToken  {
	
	public PrimaryExpression_IdentAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getIdentAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("ident",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ident");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getIdentPrimaryRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPrimaryExpressionAccess().getIdentIdentPrimaryParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PrimaryExpression_PrimaryExpressionAction_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("." CLASS)?
protected class PrimaryExpression_Group_0_2 extends GroupToken {
	
	public PrimaryExpression_Group_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getGroup_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_CLASSParserRuleCall_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "."
protected class PrimaryExpression_FullStopKeyword_0_2_0 extends KeywordToken  {
	
	public PrimaryExpression_FullStopKeyword_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getFullStopKeyword_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_IdentAssignment_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// CLASS
protected class PrimaryExpression_CLASSParserRuleCall_0_2_1 extends UnassignedTextToken {

	public PrimaryExpression_CLASSParserRuleCall_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getCLASSParserRuleCall_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_FullStopKeyword_0_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// constant
protected class PrimaryExpression_ConstantParserRuleCall_1 extends UnassignedTextToken {

	public PrimaryExpression_ConstantParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getConstantParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// ":" identifier
protected class PrimaryExpression_Group_2 extends GroupToken {
	
	public PrimaryExpression_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_IdentifierParserRuleCall_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class PrimaryExpression_ColonKeyword_2_0 extends KeywordToken  {
	
	public PrimaryExpression_ColonKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getColonKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// identifier
protected class PrimaryExpression_IdentifierParserRuleCall_2_1 extends UnassignedTextToken {

	public PrimaryExpression_IdentifierParserRuleCall_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getIdentifierParserRuleCall_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_ColonKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "(" (expressionOrVector|s=unionRule) ")"
protected class PrimaryExpression_Group_3 extends GroupToken {
	
	public PrimaryExpression_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_RightParenthesisKeyword_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class PrimaryExpression_LeftParenthesisKeyword_3_0 extends KeywordToken  {
	
	public PrimaryExpression_LeftParenthesisKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getLeftParenthesisKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// expressionOrVector|s=unionRule
protected class PrimaryExpression_Alternatives_3_1 extends AlternativesToken {

	public PrimaryExpression_Alternatives_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getAlternatives_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_ExpressionOrVectorParserRuleCall_3_1_0(parent, this, 0, inst);
			case 1: return new PrimaryExpression_SAssignment_3_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// expressionOrVector
protected class PrimaryExpression_ExpressionOrVectorParserRuleCall_3_1_0 extends RuleCallToken {
	
	public PrimaryExpression_ExpressionOrVectorParserRuleCall_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getExpressionOrVectorParserRuleCall_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExpressionOrVector_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ExpressionOrVector_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionOrVectorRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_LeftParenthesisKeyword_3_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// s=unionRule
protected class PrimaryExpression_SAssignment_3_1_1 extends AssignmentToken  {
	
	public PrimaryExpression_SAssignment_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getSAssignment_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnionRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("s",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("s");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnionRuleRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPrimaryExpressionAccess().getSUnionRuleParserRuleCall_3_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PrimaryExpression_LeftParenthesisKeyword_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ")"
protected class PrimaryExpression_RightParenthesisKeyword_3_2 extends KeywordToken  {
	
	public PrimaryExpression_RightParenthesisKeyword_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getRightParenthesisKeyword_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Alternatives_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "?" INT?
protected class PrimaryExpression_Group_4 extends GroupToken {
	
	public PrimaryExpression_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_INTTerminalRuleCall_4_1(parent, this, 0, inst);
			case 1: return new PrimaryExpression_QuestionMarkKeyword_4_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "?"
protected class PrimaryExpression_QuestionMarkKeyword_4_0 extends KeywordToken  {
	
	public PrimaryExpression_QuestionMarkKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getQuestionMarkKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// INT?
protected class PrimaryExpression_INTTerminalRuleCall_4_1 extends UnassignedTextToken {

	public PrimaryExpression_INTTerminalRuleCall_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getINTTerminalRuleCall_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_QuestionMarkKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule primaryExpression ****************/


/************ begin Rule expressionOrVector ****************
 *
 * expressionOrVector:
 *   expression v=vectorExpr?; 
 * 
 * // This parses normal expression and a list of expressions separated by commas.  If a comma is encountered
 * // a parent VECTOR_EXPR node will be created for the list.
 *
 **/

// expression v=vectorExpr?
protected class ExpressionOrVector_Group extends GroupToken {
	
	public ExpressionOrVector_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExpressionOrVectorAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExpressionOrVector_VAssignment_1(parent, this, 0, inst);
			case 1: return new ExpressionOrVector_ExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionOrVectorRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// expression
protected class ExpressionOrVector_ExpressionParserRuleCall_0 extends RuleCallToken {
	
	public ExpressionOrVector_ExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionOrVectorAccess().getExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Expression_LogicalOrExpressionParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// v=vectorExpr?
protected class ExpressionOrVector_VAssignment_1 extends AssignmentToken  {
	
	public ExpressionOrVector_VAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExpressionOrVectorAccess().getVAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VectorExpr_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("v",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("v");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVectorExprRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExpressionOrVectorAccess().getVVectorExprParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ExpressionOrVector_ExpressionParserRuleCall_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule expressionOrVector ****************/


/************ begin Rule vectorExpr ****************
 *
 * vectorExpr:
 *   "," e+=expression ("," e+=expression)*; 
 * 
 * 
 * 	        
 * 	
 * 
 * // identifier, followed by member refs (dot ident), or method calls.
 * // NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
 * // the method looks a head to find keywords after '.' and turns them into identifiers.
 *
 **/

// "," e+=expression ("," e+=expression)*
protected class VectorExpr_Group extends GroupToken {
	
	public VectorExpr_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVectorExprAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VectorExpr_Group_2(parent, this, 0, inst);
			case 1: return new VectorExpr_EAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVectorExprRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ","
protected class VectorExpr_CommaKeyword_0 extends KeywordToken  {
	
	public VectorExpr_CommaKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVectorExprAccess().getCommaKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// e+=expression
protected class VectorExpr_EAssignment_1 extends AssignmentToken  {
	
	public VectorExpr_EAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVectorExprAccess().getEAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVectorExprAccess().getEExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VectorExpr_CommaKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," e+=expression)*
protected class VectorExpr_Group_2 extends GroupToken {
	
	public VectorExpr_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVectorExprAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VectorExpr_EAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class VectorExpr_CommaKeyword_2_0 extends KeywordToken  {
	
	public VectorExpr_CommaKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVectorExprAccess().getCommaKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VectorExpr_Group_2(parent, this, 0, inst);
			case 1: return new VectorExpr_EAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// e+=expression
protected class VectorExpr_EAssignment_2_1 extends AssignmentToken  {
	
	public VectorExpr_EAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVectorExprAccess().getEAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVectorExprAccess().getEExpressionParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VectorExpr_CommaKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule vectorExpr ****************/


/************ begin Rule identPrimary ****************
 *
 * identPrimary:
 *   {identPrimary} identifier ("." identifier|"." ELEMENTS|"." OBJECT)* ("(" e=exprList ")")
 *   ?|aggregate; 
 * 
 * // identifier, followed by member refs (dot ident), or method calls.
 * // NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
 * // the method looks a head to find keywords after '.' and turns them into identifiers.
 * 
 * 	                           
 * 		         
 * 	 	 
 * 	
 * 
 * //## aggregate:
 * //##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
 * 
 * //## aggregateFunction:
 * //##     COUNT | 'sum' | 'avg' | 'max' | 'min';
 *
 **/

// {identPrimary} identifier ("." identifier|"." ELEMENTS|"." OBJECT)* ("(" e=exprList ")")
// ?|aggregate 
// 
// // identifier, followed by member refs (dot ident), or method calls.
// // NOTE: handleDotIdent() is called immediately after the first IDENT is recognized because
// // the method looks a head to find keywords after '.' and turns them into identifiers.
// 
// 	                           
// 		         
// 	 	 
// 	
// 
// //## aggregate:
// //##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
// 
// //## aggregateFunction:
// //##     COUNT | 'sum' | 'avg' | 'max' | 'min';
protected class IdentPrimary_Alternatives extends AlternativesToken {

	public IdentPrimary_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_Group_0(parent, this, 0, inst);
			case 1: return new IdentPrimary_AggregateParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIdentPrimaryRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {identPrimary} identifier ("." identifier|"." ELEMENTS|"." OBJECT)* ("(" e=exprList ")")
// ?
protected class IdentPrimary_Group_0 extends GroupToken {
	
	public IdentPrimary_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_Group_0_3(parent, this, 0, inst);
			case 1: return new IdentPrimary_Alternatives_0_2(parent, this, 1, inst);
			case 2: return new IdentPrimary_IdentifierParserRuleCall_0_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// {identPrimary}
protected class IdentPrimary_IdentPrimaryAction_0_0 extends ActionToken  {

	public IdentPrimary_IdentPrimaryAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getIdentPrimaryAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getIdentPrimaryAccess().getIdentPrimaryAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// identifier
protected class IdentPrimary_IdentifierParserRuleCall_0_1 extends UnassignedTextToken {

	public IdentPrimary_IdentifierParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getIdentifierParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_IdentPrimaryAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("." identifier|"." ELEMENTS|"." OBJECT)*
protected class IdentPrimary_Alternatives_0_2 extends AlternativesToken {

	public IdentPrimary_Alternatives_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getAlternatives_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_Group_0_2_0(parent, this, 0, inst);
			case 1: return new IdentPrimary_Group_0_2_1(parent, this, 1, inst);
			case 2: return new IdentPrimary_Group_0_2_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "." identifier
protected class IdentPrimary_Group_0_2_0 extends GroupToken {
	
	public IdentPrimary_Group_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getGroup_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_IdentifierParserRuleCall_0_2_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "."
protected class IdentPrimary_FullStopKeyword_0_2_0_0 extends KeywordToken  {
	
	public IdentPrimary_FullStopKeyword_0_2_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getFullStopKeyword_0_2_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_Alternatives_0_2(parent, this, 0, inst);
			case 1: return new IdentPrimary_IdentifierParserRuleCall_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// identifier
protected class IdentPrimary_IdentifierParserRuleCall_0_2_0_1 extends UnassignedTextToken {

	public IdentPrimary_IdentifierParserRuleCall_0_2_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getIdentifierParserRuleCall_0_2_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_FullStopKeyword_0_2_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "." ELEMENTS
protected class IdentPrimary_Group_0_2_1 extends GroupToken {
	
	public IdentPrimary_Group_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getGroup_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_ELEMENTSParserRuleCall_0_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "."
protected class IdentPrimary_FullStopKeyword_0_2_1_0 extends KeywordToken  {
	
	public IdentPrimary_FullStopKeyword_0_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getFullStopKeyword_0_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_Alternatives_0_2(parent, this, 0, inst);
			case 1: return new IdentPrimary_IdentifierParserRuleCall_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ELEMENTS
protected class IdentPrimary_ELEMENTSParserRuleCall_0_2_1_1 extends UnassignedTextToken {

	public IdentPrimary_ELEMENTSParserRuleCall_0_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getELEMENTSParserRuleCall_0_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_FullStopKeyword_0_2_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "." OBJECT
protected class IdentPrimary_Group_0_2_2 extends GroupToken {
	
	public IdentPrimary_Group_0_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getGroup_0_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_OBJECTParserRuleCall_0_2_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "."
protected class IdentPrimary_FullStopKeyword_0_2_2_0 extends KeywordToken  {
	
	public IdentPrimary_FullStopKeyword_0_2_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getFullStopKeyword_0_2_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_Alternatives_0_2(parent, this, 0, inst);
			case 1: return new IdentPrimary_IdentifierParserRuleCall_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// OBJECT
protected class IdentPrimary_OBJECTParserRuleCall_0_2_2_1 extends UnassignedTextToken {

	public IdentPrimary_OBJECTParserRuleCall_0_2_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getOBJECTParserRuleCall_0_2_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_FullStopKeyword_0_2_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// ("(" e=exprList ")")?
protected class IdentPrimary_Group_0_3 extends GroupToken {
	
	public IdentPrimary_Group_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getGroup_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_RightParenthesisKeyword_0_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class IdentPrimary_LeftParenthesisKeyword_0_3_0 extends KeywordToken  {
	
	public IdentPrimary_LeftParenthesisKeyword_0_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getLeftParenthesisKeyword_0_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_Alternatives_0_2(parent, this, 0, inst);
			case 1: return new IdentPrimary_IdentifierParserRuleCall_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// e=exprList
protected class IdentPrimary_EAssignment_0_3_1 extends AssignmentToken  {
	
	public IdentPrimary_EAssignment_0_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getEAssignment_0_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExprListRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIdentPrimaryAccess().getEExprListParserRuleCall_0_3_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IdentPrimary_LeftParenthesisKeyword_0_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class IdentPrimary_RightParenthesisKeyword_0_3_2 extends KeywordToken  {
	
	public IdentPrimary_RightParenthesisKeyword_0_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getRightParenthesisKeyword_0_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IdentPrimary_EAssignment_0_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



// aggregate
protected class IdentPrimary_AggregateParserRuleCall_1 extends RuleCallToken {
	
	public IdentPrimary_AggregateParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getIdentPrimaryAccess().getAggregateParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Aggregate_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAggregateRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule identPrimary ****************/


/************ begin Rule aggregate ****************
 *
 * aggregate:
 *   {aggregate} (SUM|AVG|MAX|MIN) "(" a=additiveExpression ")"|COUNT "(" ("*"|(DISTINCT|
 *   ALL)? (path|collectionExpr)) ")"|collectionExpr; 
 * 
 * //## aggregate:
 * //##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
 * 
 * //## aggregateFunction:
 * //##     COUNT | 'sum' | 'avg' | 'max' | 'min';
 * 
 * 
 * 	                           
 * 	// Special case for count - It's 'parameters' can be keywords.
 * 	                                         
 * 	   
 * 	
 * 
 * //## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN path CLOSE );
 *
 **/

// {aggregate} (SUM|AVG|MAX|MIN) "(" a=additiveExpression ")"|COUNT "(" ("*"|(DISTINCT|
// ALL)? (path|collectionExpr)) ")"|collectionExpr 
// 
// //## aggregate:
// //##     ( aggregateFunction OPEN path CLOSE ) | ( COUNT OPEN '*' CLOSE ) | ( COUNT OPEN (DISTINCT | ALL) path CLOSE );
// 
// //## aggregateFunction:
// //##     COUNT | 'sum' | 'avg' | 'max' | 'min';
// 
// 
// 	                           
// 	// Special case for count - It's 'parameters' can be keywords.
// 	                                         
// 	   
// 	
// 
// //## collection: ( OPEN query CLOSE ) | ( 'elements'|'indices' OPEN path CLOSE );
protected class Aggregate_Alternatives extends AlternativesToken {

	public Aggregate_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAggregateAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_Group_0(parent, this, 0, inst);
			case 1: return new Aggregate_Group_1(parent, this, 1, inst);
			case 2: return new Aggregate_CollectionExprParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAggregateRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {aggregate} (SUM|AVG|MAX|MIN) "(" a=additiveExpression ")"                            
// 	// Special case for count - It's 'parameters' can be keywords.
protected class Aggregate_Group_0 extends GroupToken {
	
	public Aggregate_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAggregateAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_RightParenthesisKeyword_0_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {aggregate}
protected class Aggregate_AggregateAction_0_0 extends ActionToken  {

	public Aggregate_AggregateAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAggregateAccess().getAggregateAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAggregateAccess().getAggregateAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// SUM|AVG|MAX|MIN
protected class Aggregate_Alternatives_0_1 extends AlternativesToken {

	public Aggregate_Alternatives_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAggregateAccess().getAlternatives_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_SUMParserRuleCall_0_1_0(parent, this, 0, inst);
			case 1: return new Aggregate_AVGParserRuleCall_0_1_1(parent, this, 1, inst);
			case 2: return new Aggregate_MAXParserRuleCall_0_1_2(parent, this, 2, inst);
			case 3: return new Aggregate_MINParserRuleCall_0_1_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
}

// SUM
protected class Aggregate_SUMParserRuleCall_0_1_0 extends UnassignedTextToken {

	public Aggregate_SUMParserRuleCall_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAggregateAccess().getSUMParserRuleCall_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_AggregateAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// AVG
protected class Aggregate_AVGParserRuleCall_0_1_1 extends UnassignedTextToken {

	public Aggregate_AVGParserRuleCall_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAggregateAccess().getAVGParserRuleCall_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_AggregateAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// MAX
protected class Aggregate_MAXParserRuleCall_0_1_2 extends UnassignedTextToken {

	public Aggregate_MAXParserRuleCall_0_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAggregateAccess().getMAXParserRuleCall_0_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_AggregateAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// MIN
protected class Aggregate_MINParserRuleCall_0_1_3 extends UnassignedTextToken {

	public Aggregate_MINParserRuleCall_0_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAggregateAccess().getMINParserRuleCall_0_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_AggregateAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "("
protected class Aggregate_LeftParenthesisKeyword_0_2 extends KeywordToken  {
	
	public Aggregate_LeftParenthesisKeyword_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAggregateAccess().getLeftParenthesisKeyword_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_Alternatives_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// a=additiveExpression
protected class Aggregate_AAssignment_0_3 extends AssignmentToken  {
	
	public Aggregate_AAssignment_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAggregateAccess().getAAssignment_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("a",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("a");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAggregateAccess().getAAdditiveExpressionParserRuleCall_0_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Aggregate_LeftParenthesisKeyword_0_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"    
// 	// Special case for count - It's 'parameters' can be keywords.
protected class Aggregate_RightParenthesisKeyword_0_4 extends KeywordToken  {
	
	public Aggregate_RightParenthesisKeyword_0_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAggregateAccess().getRightParenthesisKeyword_0_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_AAssignment_0_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// COUNT "(" ("*"|(DISTINCT|ALL)? (path|collectionExpr)) ")"
protected class Aggregate_Group_1 extends GroupToken {
	
	public Aggregate_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAggregateAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_RightParenthesisKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// COUNT
protected class Aggregate_COUNTParserRuleCall_1_0 extends UnassignedTextToken {

	public Aggregate_COUNTParserRuleCall_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAggregateAccess().getCOUNTParserRuleCall_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "("
protected class Aggregate_LeftParenthesisKeyword_1_1 extends KeywordToken  {
	
	public Aggregate_LeftParenthesisKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAggregateAccess().getLeftParenthesisKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_COUNTParserRuleCall_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "*"|(DISTINCT|ALL)? (path|collectionExpr)
protected class Aggregate_Alternatives_1_2 extends AlternativesToken {

	public Aggregate_Alternatives_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAggregateAccess().getAlternatives_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_AsteriskKeyword_1_2_0(parent, this, 0, inst);
			case 1: return new Aggregate_Group_1_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "*"
protected class Aggregate_AsteriskKeyword_1_2_0 extends KeywordToken  {
	
	public Aggregate_AsteriskKeyword_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAggregateAccess().getAsteriskKeyword_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_LeftParenthesisKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (DISTINCT|ALL)? (path|collectionExpr)
protected class Aggregate_Group_1_2_1 extends GroupToken {
	
	public Aggregate_Group_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAggregateAccess().getGroup_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_Alternatives_1_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (DISTINCT|ALL)?
protected class Aggregate_Alternatives_1_2_1_0 extends AlternativesToken {

	public Aggregate_Alternatives_1_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAggregateAccess().getAlternatives_1_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_DISTINCTParserRuleCall_1_2_1_0_0(parent, this, 0, inst);
			case 1: return new Aggregate_ALLParserRuleCall_1_2_1_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// DISTINCT
protected class Aggregate_DISTINCTParserRuleCall_1_2_1_0_0 extends UnassignedTextToken {

	public Aggregate_DISTINCTParserRuleCall_1_2_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAggregateAccess().getDISTINCTParserRuleCall_1_2_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_LeftParenthesisKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ALL
protected class Aggregate_ALLParserRuleCall_1_2_1_0_1 extends UnassignedTextToken {

	public Aggregate_ALLParserRuleCall_1_2_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAggregateAccess().getALLParserRuleCall_1_2_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_LeftParenthesisKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// path|collectionExpr
protected class Aggregate_Alternatives_1_2_1_1 extends AlternativesToken {

	public Aggregate_Alternatives_1_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAggregateAccess().getAlternatives_1_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_PathParserRuleCall_1_2_1_1_0(parent, this, 0, inst);
			case 1: return new Aggregate_CollectionExprParserRuleCall_1_2_1_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// path
protected class Aggregate_PathParserRuleCall_1_2_1_1_0 extends UnassignedTextToken {

	public Aggregate_PathParserRuleCall_1_2_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAggregateAccess().getPathParserRuleCall_1_2_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_Alternatives_1_2_1_0(parent, this, 0, inst);
			case 1: return new Aggregate_LeftParenthesisKeyword_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// collectionExpr
protected class Aggregate_CollectionExprParserRuleCall_1_2_1_1_1 extends UnassignedTextToken {

	public Aggregate_CollectionExprParserRuleCall_1_2_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAggregateAccess().getCollectionExprParserRuleCall_1_2_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_Alternatives_1_2_1_0(parent, this, 0, inst);
			case 1: return new Aggregate_LeftParenthesisKeyword_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}




// ")"
protected class Aggregate_RightParenthesisKeyword_1_3 extends KeywordToken  {
	
	public Aggregate_RightParenthesisKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAggregateAccess().getRightParenthesisKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Aggregate_Alternatives_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// collectionExpr
protected class Aggregate_CollectionExprParserRuleCall_2 extends UnassignedTextToken {

	public Aggregate_CollectionExprParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAggregateAccess().getCollectionExprParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}


/************ end Rule aggregate ****************/



/************ begin Rule compoundExpr ****************
 *
 * compoundExpr:
 *   collectionExpr|path|"(" (e+=expression ("," e+=expression)*|s=unionRule) ")"; 
 *                                            
 * // NOTE: compoundExpr can be a 'path' where the last token in the path is '.elements' or '.indicies'
 *
 **/

// collectionExpr|path|"(" (e+=expression ("," e+=expression)*|s=unionRule) ")" 
//                                            
// // NOTE: compoundExpr can be a 'path' where the last token in the path is '.elements' or '.indicies'
protected class CompoundExpr_Alternatives extends AlternativesToken {

	public CompoundExpr_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundExpr_CollectionExprParserRuleCall_0(parent, this, 0, inst);
			case 1: return new CompoundExpr_PathParserRuleCall_1(parent, this, 1, inst);
			case 2: return new CompoundExpr_Group_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCompoundExprRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// collectionExpr
protected class CompoundExpr_CollectionExprParserRuleCall_0 extends UnassignedTextToken {

	public CompoundExpr_CollectionExprParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getCollectionExprParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// path
protected class CompoundExpr_PathParserRuleCall_1 extends UnassignedTextToken {

	public CompoundExpr_PathParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getPathParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "(" (e+=expression ("," e+=expression)*|s=unionRule) ")"
protected class CompoundExpr_Group_2 extends GroupToken {
	
	public CompoundExpr_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundExpr_RightParenthesisKeyword_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class CompoundExpr_LeftParenthesisKeyword_2_0 extends KeywordToken  {
	
	public CompoundExpr_LeftParenthesisKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getLeftParenthesisKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// e+=expression ("," e+=expression)*|s=unionRule
protected class CompoundExpr_Alternatives_2_1 extends AlternativesToken {

	public CompoundExpr_Alternatives_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getAlternatives_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundExpr_Group_2_1_0(parent, this, 0, inst);
			case 1: return new CompoundExpr_SAssignment_2_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// e+=expression ("," e+=expression)*
protected class CompoundExpr_Group_2_1_0 extends GroupToken {
	
	public CompoundExpr_Group_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getGroup_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundExpr_Group_2_1_0_1(parent, this, 0, inst);
			case 1: return new CompoundExpr_EAssignment_2_1_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// e+=expression
protected class CompoundExpr_EAssignment_2_1_0_0 extends AssignmentToken  {
	
	public CompoundExpr_EAssignment_2_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getEAssignment_2_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompoundExprAccess().getEExpressionParserRuleCall_2_1_0_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompoundExpr_LeftParenthesisKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," e+=expression)*
protected class CompoundExpr_Group_2_1_0_1 extends GroupToken {
	
	public CompoundExpr_Group_2_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getGroup_2_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundExpr_EAssignment_2_1_0_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class CompoundExpr_CommaKeyword_2_1_0_1_0 extends KeywordToken  {
	
	public CompoundExpr_CommaKeyword_2_1_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getCommaKeyword_2_1_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundExpr_Group_2_1_0_1(parent, this, 0, inst);
			case 1: return new CompoundExpr_EAssignment_2_1_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// e+=expression
protected class CompoundExpr_EAssignment_2_1_0_1_1 extends AssignmentToken  {
	
	public CompoundExpr_EAssignment_2_1_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getEAssignment_2_1_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompoundExprAccess().getEExpressionParserRuleCall_2_1_0_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompoundExpr_CommaKeyword_2_1_0_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// s=unionRule
protected class CompoundExpr_SAssignment_2_1_1 extends AssignmentToken  {
	
	public CompoundExpr_SAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getSAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnionRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("s",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("s");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnionRuleRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompoundExprAccess().getSUnionRuleParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompoundExpr_LeftParenthesisKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ")"
protected class CompoundExpr_RightParenthesisKeyword_2_2 extends KeywordToken  {
	
	public CompoundExpr_RightParenthesisKeyword_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundExprAccess().getRightParenthesisKeyword_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundExpr_Alternatives_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule compoundExpr ****************/


/************ begin Rule exprList ****************
 *
 * exprList:
 *   (TRAILING|LEADING|BOTH)? (e+=expression (("," e+=expression)+|FROM e+=expression|AS
 *   id=identifier)?|FROM e+=expression)?;
 *
 **/

// (TRAILING|LEADING|BOTH)? (e+=expression (("," e+=expression)+|FROM e+=expression|AS
// id=identifier)?|FROM e+=expression)?
protected class ExprList_Group extends GroupToken {
	
	public ExprList_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExprListAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_Alternatives_1(parent, this, 0, inst);
			case 1: return new ExprList_Alternatives_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExprListRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// (TRAILING|LEADING|BOTH)?
protected class ExprList_Alternatives_0 extends AlternativesToken {

	public ExprList_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getExprListAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_TRAILINGParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new ExprList_LEADINGParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new ExprList_BOTHParserRuleCall_0_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// TRAILING
protected class ExprList_TRAILINGParserRuleCall_0_0 extends UnassignedTextToken {

	public ExprList_TRAILINGParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExprListAccess().getTRAILINGParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// LEADING
protected class ExprList_LEADINGParserRuleCall_0_1 extends UnassignedTextToken {

	public ExprList_LEADINGParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExprListAccess().getLEADINGParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// BOTH
protected class ExprList_BOTHParserRuleCall_0_2 extends UnassignedTextToken {

	public ExprList_BOTHParserRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExprListAccess().getBOTHParserRuleCall_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}


// (e+=expression (("," e+=expression)+|FROM e+=expression|AS id=identifier)?|FROM e+=
// expression)?
protected class ExprList_Alternatives_1 extends AlternativesToken {

	public ExprList_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getExprListAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_Group_1_0(parent, this, 0, inst);
			case 1: return new ExprList_Group_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// e+=expression (("," e+=expression)+|FROM e+=expression|AS id=identifier)?
protected class ExprList_Group_1_0 extends GroupToken {
	
	public ExprList_Group_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExprListAccess().getGroup_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_Alternatives_1_0_1(parent, this, 0, inst);
			case 1: return new ExprList_EAssignment_1_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// e+=expression
protected class ExprList_EAssignment_1_0_0 extends AssignmentToken  {
	
	public ExprList_EAssignment_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExprListAccess().getEAssignment_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExprListAccess().getEExpressionParserRuleCall_1_0_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ExprList_Alternatives_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

// (("," e+=expression)+|FROM e+=expression|AS id=identifier)?
protected class ExprList_Alternatives_1_0_1 extends AlternativesToken {

	public ExprList_Alternatives_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getExprListAccess().getAlternatives_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_Group_1_0_1_0(parent, this, 0, inst);
			case 1: return new ExprList_Group_1_0_1_1(parent, this, 1, inst);
			case 2: return new ExprList_Group_1_0_1_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// ("," e+=expression)+
protected class ExprList_Group_1_0_1_0 extends GroupToken {
	
	public ExprList_Group_1_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExprListAccess().getGroup_1_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_EAssignment_1_0_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ExprList_CommaKeyword_1_0_1_0_0 extends KeywordToken  {
	
	public ExprList_CommaKeyword_1_0_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getExprListAccess().getCommaKeyword_1_0_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_Group_1_0_1_0(parent, this, 0, inst);
			case 1: return new ExprList_EAssignment_1_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// e+=expression
protected class ExprList_EAssignment_1_0_1_0_1 extends AssignmentToken  {
	
	public ExprList_EAssignment_1_0_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExprListAccess().getEAssignment_1_0_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExprListAccess().getEExpressionParserRuleCall_1_0_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ExprList_CommaKeyword_1_0_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// FROM e+=expression
protected class ExprList_Group_1_0_1_1 extends GroupToken {
	
	public ExprList_Group_1_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExprListAccess().getGroup_1_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_EAssignment_1_0_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// FROM
protected class ExprList_FROMParserRuleCall_1_0_1_1_0 extends UnassignedTextToken {

	public ExprList_FROMParserRuleCall_1_0_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExprListAccess().getFROMParserRuleCall_1_0_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_EAssignment_1_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// e+=expression
protected class ExprList_EAssignment_1_0_1_1_1 extends AssignmentToken  {
	
	public ExprList_EAssignment_1_0_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExprListAccess().getEAssignment_1_0_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExprListAccess().getEExpressionParserRuleCall_1_0_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ExprList_FROMParserRuleCall_1_0_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// AS id=identifier
protected class ExprList_Group_1_0_1_2 extends GroupToken {
	
	public ExprList_Group_1_0_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExprListAccess().getGroup_1_0_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_IdAssignment_1_0_1_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// AS
protected class ExprList_ASParserRuleCall_1_0_1_2_0 extends UnassignedTextToken {

	public ExprList_ASParserRuleCall_1_0_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExprListAccess().getASParserRuleCall_1_0_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_EAssignment_1_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// id=identifier
protected class ExprList_IdAssignment_1_0_1_2_1 extends AssignmentToken  {
	
	public ExprList_IdAssignment_1_0_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExprListAccess().getIdAssignment_1_0_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_ASParserRuleCall_1_0_1_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getExprListAccess().getIdIdentifierParserRuleCall_1_0_1_2_1_0();
			return obj;
		}
		return null;
	}

}




// FROM e+=expression
protected class ExprList_Group_1_1 extends GroupToken {
	
	public ExprList_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExprListAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_EAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// FROM
protected class ExprList_FROMParserRuleCall_1_1_0 extends UnassignedTextToken {

	public ExprList_FROMParserRuleCall_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExprListAccess().getFROMParserRuleCall_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExprList_Alternatives_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// e+=expression
protected class ExprList_EAssignment_1_1_1 extends AssignmentToken  {
	
	public ExprList_EAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExprListAccess().getEAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LogicalOrExpressionParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("e",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("e");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExprListAccess().getEExpressionParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ExprList_FROMParserRuleCall_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule exprList ****************/
































































}
